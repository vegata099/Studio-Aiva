"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pixi-live2d-display";
exports.ids = ["vendor-chunks/pixi-live2d-display"];
exports.modules = {

/***/ "(ssr)/./node_modules/pixi-live2d-display/dist/cubism4.es.js":
/*!*************************************************************!*\
  !*** ./node_modules/pixi-live2d-display/dist/cubism4.es.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ACubismMotion: () => (/* binding */ ACubismMotion),\n/* harmony export */   BreathParameterData: () => (/* binding */ BreathParameterData),\n/* harmony export */   CSM_ASSERT: () => (/* binding */ CSM_ASSERT),\n/* harmony export */   Constant: () => (/* binding */ Constant),\n/* harmony export */   Cubism4ExpressionManager: () => (/* binding */ Cubism4ExpressionManager),\n/* harmony export */   Cubism4InternalModel: () => (/* binding */ Cubism4InternalModel),\n/* harmony export */   Cubism4ModelSettings: () => (/* binding */ Cubism4ModelSettings),\n/* harmony export */   Cubism4MotionManager: () => (/* binding */ Cubism4MotionManager),\n/* harmony export */   CubismBlendMode: () => (/* binding */ CubismBlendMode),\n/* harmony export */   CubismBreath: () => (/* binding */ CubismBreath),\n/* harmony export */   CubismClippingContext: () => (/* binding */ CubismClippingContext),\n/* harmony export */   CubismClippingManager_WebGL: () => (/* binding */ CubismClippingManager_WebGL),\n/* harmony export */   CubismConfig: () => (/* binding */ CubismConfig),\n/* harmony export */   CubismDebug: () => (/* binding */ CubismDebug),\n/* harmony export */   CubismExpressionMotion: () => (/* binding */ CubismExpressionMotion),\n/* harmony export */   CubismEyeBlink: () => (/* binding */ CubismEyeBlink),\n/* harmony export */   CubismFramework: () => (/* binding */ CubismFramework),\n/* harmony export */   CubismLogDebug: () => (/* binding */ CubismLogDebug),\n/* harmony export */   CubismLogError: () => (/* binding */ CubismLogError),\n/* harmony export */   CubismLogInfo: () => (/* binding */ CubismLogInfo),\n/* harmony export */   CubismLogVerbose: () => (/* binding */ CubismLogVerbose),\n/* harmony export */   CubismLogWarning: () => (/* binding */ CubismLogWarning),\n/* harmony export */   CubismMath: () => (/* binding */ CubismMath),\n/* harmony export */   CubismMatrix44: () => (/* binding */ CubismMatrix44),\n/* harmony export */   CubismMoc: () => (/* binding */ CubismMoc),\n/* harmony export */   CubismModel: () => (/* binding */ CubismModel),\n/* harmony export */   CubismModelSettingsJson: () => (/* binding */ CubismModelSettingsJson),\n/* harmony export */   CubismModelUserData: () => (/* binding */ CubismModelUserData),\n/* harmony export */   CubismModelUserDataJson: () => (/* binding */ CubismModelUserDataJson),\n/* harmony export */   CubismMotion: () => (/* binding */ CubismMotion),\n/* harmony export */   CubismMotionCurve: () => (/* binding */ CubismMotionCurve),\n/* harmony export */   CubismMotionCurveTarget: () => (/* binding */ CubismMotionCurveTarget),\n/* harmony export */   CubismMotionData: () => (/* binding */ CubismMotionData),\n/* harmony export */   CubismMotionEvent: () => (/* binding */ CubismMotionEvent),\n/* harmony export */   CubismMotionJson: () => (/* binding */ CubismMotionJson),\n/* harmony export */   CubismMotionManager: () => (/* binding */ CubismMotionManager),\n/* harmony export */   CubismMotionPoint: () => (/* binding */ CubismMotionPoint),\n/* harmony export */   CubismMotionQueueEntry: () => (/* binding */ CubismMotionQueueEntry),\n/* harmony export */   CubismMotionQueueManager: () => (/* binding */ CubismMotionQueueManager),\n/* harmony export */   CubismMotionSegment: () => (/* binding */ CubismMotionSegment),\n/* harmony export */   CubismMotionSegmentType: () => (/* binding */ CubismMotionSegmentType),\n/* harmony export */   CubismPhysics: () => (/* binding */ CubismPhysics),\n/* harmony export */   CubismPhysicsInput: () => (/* binding */ CubismPhysicsInput),\n/* harmony export */   CubismPhysicsJson: () => (/* binding */ CubismPhysicsJson),\n/* harmony export */   CubismPhysicsOutput: () => (/* binding */ CubismPhysicsOutput),\n/* harmony export */   CubismPhysicsParticle: () => (/* binding */ CubismPhysicsParticle),\n/* harmony export */   CubismPhysicsRig: () => (/* binding */ CubismPhysicsRig),\n/* harmony export */   CubismPhysicsSource: () => (/* binding */ CubismPhysicsSource),\n/* harmony export */   CubismPhysicsSubRig: () => (/* binding */ CubismPhysicsSubRig),\n/* harmony export */   CubismPhysicsTargetType: () => (/* binding */ CubismPhysicsTargetType),\n/* harmony export */   CubismPose: () => (/* binding */ CubismPose),\n/* harmony export */   CubismRenderTextureResource: () => (/* binding */ CubismRenderTextureResource),\n/* harmony export */   CubismRenderer: () => (/* binding */ CubismRenderer),\n/* harmony export */   CubismRenderer_WebGL: () => (/* binding */ CubismRenderer_WebGL),\n/* harmony export */   CubismShader_WebGL: () => (/* binding */ CubismShader_WebGL),\n/* harmony export */   CubismTextureColor: () => (/* binding */ CubismTextureColor),\n/* harmony export */   CubismVector2: () => (/* binding */ CubismVector2),\n/* harmony export */   EvaluationOptionFlag: () => (/* binding */ EvaluationOptionFlag),\n/* harmony export */   ExpressionBlendType: () => (/* binding */ ExpressionBlendType),\n/* harmony export */   ExpressionManager: () => (/* binding */ ExpressionManager),\n/* harmony export */   EyeState: () => (/* binding */ EyeState),\n/* harmony export */   FileLoader: () => (/* binding */ FileLoader),\n/* harmony export */   FocusController: () => (/* binding */ FocusController),\n/* harmony export */   HitAreaBody: () => (/* binding */ HitAreaBody),\n/* harmony export */   HitAreaHead: () => (/* binding */ HitAreaHead),\n/* harmony export */   HitAreaPrefix: () => (/* binding */ HitAreaPrefix),\n/* harmony export */   InteractionMixin: () => (/* binding */ InteractionMixin),\n/* harmony export */   InternalModel: () => (/* binding */ InternalModel),\n/* harmony export */   InvalidMotionQueueEntryHandleValue: () => (/* binding */ InvalidMotionQueueEntryHandleValue),\n/* harmony export */   LOGICAL_HEIGHT: () => (/* binding */ LOGICAL_HEIGHT),\n/* harmony export */   LOGICAL_WIDTH: () => (/* binding */ LOGICAL_WIDTH),\n/* harmony export */   Live2DFactory: () => (/* binding */ Live2DFactory),\n/* harmony export */   Live2DLoader: () => (/* binding */ Live2DLoader),\n/* harmony export */   Live2DModel: () => (/* binding */ Live2DModel),\n/* harmony export */   Live2DTransform: () => (/* binding */ Live2DTransform),\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   ModelSettings: () => (/* binding */ ModelSettings),\n/* harmony export */   MotionManager: () => (/* binding */ MotionManager),\n/* harmony export */   MotionPreloadStrategy: () => (/* binding */ MotionPreloadStrategy),\n/* harmony export */   MotionPriority: () => (/* binding */ MotionPriority),\n/* harmony export */   MotionState: () => (/* binding */ MotionState),\n/* harmony export */   Options: () => (/* binding */ Options),\n/* harmony export */   ParamAngleX: () => (/* binding */ ParamAngleX),\n/* harmony export */   ParamAngleY: () => (/* binding */ ParamAngleY),\n/* harmony export */   ParamAngleZ: () => (/* binding */ ParamAngleZ),\n/* harmony export */   ParamArmLA: () => (/* binding */ ParamArmLA),\n/* harmony export */   ParamArmLB: () => (/* binding */ ParamArmLB),\n/* harmony export */   ParamArmRA: () => (/* binding */ ParamArmRA),\n/* harmony export */   ParamArmRB: () => (/* binding */ ParamArmRB),\n/* harmony export */   ParamBaseX: () => (/* binding */ ParamBaseX),\n/* harmony export */   ParamBaseY: () => (/* binding */ ParamBaseY),\n/* harmony export */   ParamBodyAngleX: () => (/* binding */ ParamBodyAngleX),\n/* harmony export */   ParamBodyAngleY: () => (/* binding */ ParamBodyAngleY),\n/* harmony export */   ParamBodyAngleZ: () => (/* binding */ ParamBodyAngleZ),\n/* harmony export */   ParamBreath: () => (/* binding */ ParamBreath),\n/* harmony export */   ParamBrowLAngle: () => (/* binding */ ParamBrowLAngle),\n/* harmony export */   ParamBrowLForm: () => (/* binding */ ParamBrowLForm),\n/* harmony export */   ParamBrowLX: () => (/* binding */ ParamBrowLX),\n/* harmony export */   ParamBrowLY: () => (/* binding */ ParamBrowLY),\n/* harmony export */   ParamBrowRAngle: () => (/* binding */ ParamBrowRAngle),\n/* harmony export */   ParamBrowRForm: () => (/* binding */ ParamBrowRForm),\n/* harmony export */   ParamBrowRX: () => (/* binding */ ParamBrowRX),\n/* harmony export */   ParamBrowRY: () => (/* binding */ ParamBrowRY),\n/* harmony export */   ParamBustX: () => (/* binding */ ParamBustX),\n/* harmony export */   ParamBustY: () => (/* binding */ ParamBustY),\n/* harmony export */   ParamCheek: () => (/* binding */ ParamCheek),\n/* harmony export */   ParamEyeBallForm: () => (/* binding */ ParamEyeBallForm),\n/* harmony export */   ParamEyeBallX: () => (/* binding */ ParamEyeBallX),\n/* harmony export */   ParamEyeBallY: () => (/* binding */ ParamEyeBallY),\n/* harmony export */   ParamEyeLOpen: () => (/* binding */ ParamEyeLOpen),\n/* harmony export */   ParamEyeLSmile: () => (/* binding */ ParamEyeLSmile),\n/* harmony export */   ParamEyeROpen: () => (/* binding */ ParamEyeROpen),\n/* harmony export */   ParamEyeRSmile: () => (/* binding */ ParamEyeRSmile),\n/* harmony export */   ParamHairBack: () => (/* binding */ ParamHairBack),\n/* harmony export */   ParamHairFluffy: () => (/* binding */ ParamHairFluffy),\n/* harmony export */   ParamHairFront: () => (/* binding */ ParamHairFront),\n/* harmony export */   ParamHairSide: () => (/* binding */ ParamHairSide),\n/* harmony export */   ParamHandL: () => (/* binding */ ParamHandL),\n/* harmony export */   ParamHandR: () => (/* binding */ ParamHandR),\n/* harmony export */   ParamMouthForm: () => (/* binding */ ParamMouthForm),\n/* harmony export */   ParamMouthOpenY: () => (/* binding */ ParamMouthOpenY),\n/* harmony export */   ParamNONE: () => (/* binding */ ParamNONE),\n/* harmony export */   ParamShoulderY: () => (/* binding */ ParamShoulderY),\n/* harmony export */   PartData: () => (/* binding */ PartData),\n/* harmony export */   PartsArmLPrefix: () => (/* binding */ PartsArmLPrefix),\n/* harmony export */   PartsArmPrefix: () => (/* binding */ PartsArmPrefix),\n/* harmony export */   PartsArmRPrefix: () => (/* binding */ PartsArmRPrefix),\n/* harmony export */   PartsIdCore: () => (/* binding */ PartsIdCore),\n/* harmony export */   PhysicsJsonEffectiveForces: () => (/* binding */ PhysicsJsonEffectiveForces),\n/* harmony export */   ShaderNames: () => (/* binding */ ShaderNames),\n/* harmony export */   SoundManager: () => (/* binding */ SoundManager),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   XHRLoader: () => (/* binding */ XHRLoader),\n/* harmony export */   ZipLoader: () => (/* binding */ ZipLoader),\n/* harmony export */   applyMixins: () => (/* binding */ applyMixins),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   copyArray: () => (/* binding */ copyArray),\n/* harmony export */   copyProperty: () => (/* binding */ copyProperty),\n/* harmony export */   csmRect: () => (/* binding */ csmRect),\n/* harmony export */   cubism4Ready: () => (/* binding */ cubism4Ready),\n/* harmony export */   folderName: () => (/* binding */ folderName),\n/* harmony export */   fragmentShaderSrcMaskInvertedPremultipliedAlpha: () => (/* binding */ fragmentShaderSrcMaskInvertedPremultipliedAlpha),\n/* harmony export */   fragmentShaderSrcMaskPremultipliedAlpha: () => (/* binding */ fragmentShaderSrcMaskPremultipliedAlpha),\n/* harmony export */   fragmentShaderSrcPremultipliedAlpha: () => (/* binding */ fragmentShaderSrcPremultipliedAlpha),\n/* harmony export */   fragmentShaderSrcsetupMask: () => (/* binding */ fragmentShaderSrcsetupMask),\n/* harmony export */   logger: () => (/* binding */ logger),\n/* harmony export */   rand: () => (/* binding */ rand),\n/* harmony export */   remove: () => (/* binding */ remove),\n/* harmony export */   startUpCubism4: () => (/* binding */ startUpCubism4),\n/* harmony export */   vertexShaderSrc: () => (/* binding */ vertexShaderSrc),\n/* harmony export */   vertexShaderSrcMasked: () => (/* binding */ vertexShaderSrcMasked),\n/* harmony export */   vertexShaderSrcSetupMask: () => (/* binding */ vertexShaderSrcSetupMask)\n/* harmony export */ });\n/* harmony import */ var _pixi_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pixi/utils */ \"(ssr)/./node_modules/@pixi/utils/dist/esm/utils.mjs\");\n/* harmony import */ var _pixi_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pixi/math */ \"(ssr)/./node_modules/@pixi/math/dist/esm/math.mjs\");\n/* harmony import */ var _pixi_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pixi/core */ \"(ssr)/./node_modules/@pixi/core/dist/esm/core.mjs\");\n/* harmony import */ var _pixi_display__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @pixi/display */ \"(ssr)/./node_modules/@pixi/display/dist/esm/display.mjs\");\nvar __pow = Math.pow;\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n\n\n\nclass CubismBreath {\n  constructor() {\n    this._breathParameters = [];\n    this._currentTime = 0;\n  }\n  static create() {\n    return new CubismBreath();\n  }\n  setParameters(breathParameters) {\n    this._breathParameters = breathParameters;\n  }\n  getParameters() {\n    return this._breathParameters;\n  }\n  updateParameters(model, deltaTimeSeconds) {\n    this._currentTime += deltaTimeSeconds;\n    const t = this._currentTime * 2 * 3.14159;\n    for (let i = 0; i < this._breathParameters.length; ++i) {\n      const data = this._breathParameters[i];\n      model.addParameterValueById(data.parameterId, data.offset + data.peak * Math.sin(t / data.cycle), data.weight);\n    }\n  }\n}\nclass BreathParameterData {\n  constructor(parameterId, offset, peak, cycle, weight) {\n    this.parameterId = parameterId == void 0 ? void 0 : parameterId;\n    this.offset = offset == void 0 ? 0 : offset;\n    this.peak = peak == void 0 ? 0 : peak;\n    this.cycle = cycle == void 0 ? 0 : cycle;\n    this.weight = weight == void 0 ? 0 : weight;\n  }\n}\nconst _CubismEyeBlink = class {\n  static create(modelSetting) {\n    return new _CubismEyeBlink(modelSetting);\n  }\n  setBlinkingInterval(blinkingInterval) {\n    this._blinkingIntervalSeconds = blinkingInterval;\n  }\n  setBlinkingSetting(closing, closed, opening) {\n    this._closingSeconds = closing;\n    this._closedSeconds = closed;\n    this._openingSeconds = opening;\n  }\n  setParameterIds(parameterIds) {\n    this._parameterIds = parameterIds;\n  }\n  getParameterIds() {\n    return this._parameterIds;\n  }\n  updateParameters(model, deltaTimeSeconds) {\n    this._userTimeSeconds += deltaTimeSeconds;\n    let parameterValue;\n    let t = 0;\n    switch (this._blinkingState) {\n      case EyeState.EyeState_Closing:\n        t = (this._userTimeSeconds - this._stateStartTimeSeconds) / this._closingSeconds;\n        if (t >= 1) {\n          t = 1;\n          this._blinkingState = EyeState.EyeState_Closed;\n          this._stateStartTimeSeconds = this._userTimeSeconds;\n        }\n        parameterValue = 1 - t;\n        break;\n      case EyeState.EyeState_Closed:\n        t = (this._userTimeSeconds - this._stateStartTimeSeconds) / this._closedSeconds;\n        if (t >= 1) {\n          this._blinkingState = EyeState.EyeState_Opening;\n          this._stateStartTimeSeconds = this._userTimeSeconds;\n        }\n        parameterValue = 0;\n        break;\n      case EyeState.EyeState_Opening:\n        t = (this._userTimeSeconds - this._stateStartTimeSeconds) / this._openingSeconds;\n        if (t >= 1) {\n          t = 1;\n          this._blinkingState = EyeState.EyeState_Interval;\n          this._nextBlinkingTime = this.determinNextBlinkingTiming();\n        }\n        parameterValue = t;\n        break;\n      case EyeState.EyeState_Interval:\n        if (this._nextBlinkingTime < this._userTimeSeconds) {\n          this._blinkingState = EyeState.EyeState_Closing;\n          this._stateStartTimeSeconds = this._userTimeSeconds;\n        }\n        parameterValue = 1;\n        break;\n      case EyeState.EyeState_First:\n      default:\n        this._blinkingState = EyeState.EyeState_Interval;\n        this._nextBlinkingTime = this.determinNextBlinkingTiming();\n        parameterValue = 1;\n        break;\n    }\n    if (!_CubismEyeBlink.CloseIfZero) {\n      parameterValue = -parameterValue;\n    }\n    for (let i = 0; i < this._parameterIds.length; ++i) {\n      model.setParameterValueById(this._parameterIds[i], parameterValue);\n    }\n  }\n  constructor(modelSetting) {\n    var _a, _b;\n    this._blinkingState = EyeState.EyeState_First;\n    this._nextBlinkingTime = 0;\n    this._stateStartTimeSeconds = 0;\n    this._blinkingIntervalSeconds = 4;\n    this._closingSeconds = 0.1;\n    this._closedSeconds = 0.05;\n    this._openingSeconds = 0.15;\n    this._userTimeSeconds = 0;\n    this._parameterIds = [];\n    if (modelSetting == null) {\n      return;\n    }\n    this._parameterIds = (_b = (_a = modelSetting.getEyeBlinkParameters()) == null ? void 0 : _a.slice()) != null ? _b : this._parameterIds;\n  }\n  determinNextBlinkingTiming() {\n    const r = Math.random();\n    return this._userTimeSeconds + r * (2 * this._blinkingIntervalSeconds - 1);\n  }\n};\nlet CubismEyeBlink = _CubismEyeBlink;\nCubismEyeBlink.CloseIfZero = true;\nvar EyeState = /* @__PURE__ */ ((EyeState2) => {\n  EyeState2[EyeState2[\"EyeState_First\"] = 0] = \"EyeState_First\";\n  EyeState2[EyeState2[\"EyeState_Interval\"] = 1] = \"EyeState_Interval\";\n  EyeState2[EyeState2[\"EyeState_Closing\"] = 2] = \"EyeState_Closing\";\n  EyeState2[EyeState2[\"EyeState_Closed\"] = 3] = \"EyeState_Closed\";\n  EyeState2[EyeState2[\"EyeState_Opening\"] = 4] = \"EyeState_Opening\";\n  return EyeState2;\n})(EyeState || {});\nconst Epsilon = 1e-3;\nconst DefaultFadeInSeconds = 0.5;\nclass CubismPose {\n  static create(pose3json) {\n    const ret = new CubismPose();\n    if (typeof pose3json.FadeInTime === \"number\") {\n      ret._fadeTimeSeconds = pose3json.FadeInTime;\n      if (ret._fadeTimeSeconds <= 0) {\n        ret._fadeTimeSeconds = DefaultFadeInSeconds;\n      }\n    }\n    const poseListInfo = pose3json.Groups;\n    const poseCount = poseListInfo.length;\n    for (let poseIndex = 0; poseIndex < poseCount; ++poseIndex) {\n      const idListInfo = poseListInfo[poseIndex];\n      const idCount = idListInfo.length;\n      let groupCount = 0;\n      for (let groupIndex = 0; groupIndex < idCount; ++groupIndex) {\n        const partInfo = idListInfo[groupIndex];\n        const partData = new PartData();\n        partData.partId = partInfo.Id;\n        const linkListInfo = partInfo.Link;\n        if (linkListInfo) {\n          const linkCount = linkListInfo.length;\n          for (let linkIndex = 0; linkIndex < linkCount; ++linkIndex) {\n            const linkPart = new PartData();\n            linkPart.partId = linkListInfo[linkIndex];\n            partData.link.push(linkPart);\n          }\n        }\n        ret._partGroups.push(partData);\n        ++groupCount;\n      }\n      ret._partGroupCounts.push(groupCount);\n    }\n    return ret;\n  }\n  updateParameters(model, deltaTimeSeconds) {\n    if (model != this._lastModel) {\n      this.reset(model);\n    }\n    this._lastModel = model;\n    if (deltaTimeSeconds < 0) {\n      deltaTimeSeconds = 0;\n    }\n    let beginIndex = 0;\n    for (let i = 0; i < this._partGroupCounts.length; i++) {\n      const partGroupCount = this._partGroupCounts[i];\n      this.doFade(model, deltaTimeSeconds, beginIndex, partGroupCount);\n      beginIndex += partGroupCount;\n    }\n    this.copyPartOpacities(model);\n  }\n  reset(model) {\n    let beginIndex = 0;\n    for (let i = 0; i < this._partGroupCounts.length; ++i) {\n      const groupCount = this._partGroupCounts[i];\n      for (let j = beginIndex; j < beginIndex + groupCount; ++j) {\n        this._partGroups[j].initialize(model);\n        const partsIndex = this._partGroups[j].partIndex;\n        const paramIndex = this._partGroups[j].parameterIndex;\n        if (partsIndex < 0) {\n          continue;\n        }\n        model.setPartOpacityByIndex(partsIndex, j == beginIndex ? 1 : 0);\n        model.setParameterValueByIndex(paramIndex, j == beginIndex ? 1 : 0);\n        for (let k = 0; k < this._partGroups[j].link.length; ++k) {\n          this._partGroups[j].link[k].initialize(model);\n        }\n      }\n      beginIndex += groupCount;\n    }\n  }\n  copyPartOpacities(model) {\n    for (let groupIndex = 0; groupIndex < this._partGroups.length; ++groupIndex) {\n      const partData = this._partGroups[groupIndex];\n      if (partData.link.length == 0) {\n        continue;\n      }\n      const partIndex = this._partGroups[groupIndex].partIndex;\n      const opacity = model.getPartOpacityByIndex(partIndex);\n      for (let linkIndex = 0; linkIndex < partData.link.length; ++linkIndex) {\n        const linkPart = partData.link[linkIndex];\n        const linkPartIndex = linkPart.partIndex;\n        if (linkPartIndex < 0) {\n          continue;\n        }\n        model.setPartOpacityByIndex(linkPartIndex, opacity);\n      }\n    }\n  }\n  doFade(model, deltaTimeSeconds, beginIndex, partGroupCount) {\n    let visiblePartIndex = -1;\n    let newOpacity = 1;\n    const phi = 0.5;\n    const backOpacityThreshold = 0.15;\n    for (let i = beginIndex; i < beginIndex + partGroupCount; ++i) {\n      const partIndex = this._partGroups[i].partIndex;\n      const paramIndex = this._partGroups[i].parameterIndex;\n      if (model.getParameterValueByIndex(paramIndex) > Epsilon) {\n        if (visiblePartIndex >= 0) {\n          break;\n        }\n        visiblePartIndex = i;\n        newOpacity = model.getPartOpacityByIndex(partIndex);\n        newOpacity += deltaTimeSeconds / this._fadeTimeSeconds;\n        if (newOpacity > 1) {\n          newOpacity = 1;\n        }\n      }\n    }\n    if (visiblePartIndex < 0) {\n      visiblePartIndex = 0;\n      newOpacity = 1;\n    }\n    for (let i = beginIndex; i < beginIndex + partGroupCount; ++i) {\n      const partsIndex = this._partGroups[i].partIndex;\n      if (visiblePartIndex == i) {\n        model.setPartOpacityByIndex(partsIndex, newOpacity);\n      } else {\n        let opacity = model.getPartOpacityByIndex(partsIndex);\n        let a1;\n        if (newOpacity < phi) {\n          a1 = newOpacity * (phi - 1) / phi + 1;\n        } else {\n          a1 = (1 - newOpacity) * phi / (1 - phi);\n        }\n        const backOpacity = (1 - a1) * (1 - newOpacity);\n        if (backOpacity > backOpacityThreshold) {\n          a1 = 1 - backOpacityThreshold / (1 - newOpacity);\n        }\n        if (opacity > a1) {\n          opacity = a1;\n        }\n        model.setPartOpacityByIndex(partsIndex, opacity);\n      }\n    }\n  }\n  constructor() {\n    this._fadeTimeSeconds = DefaultFadeInSeconds;\n    this._lastModel = void 0;\n    this._partGroups = [];\n    this._partGroupCounts = [];\n  }\n}\nclass PartData {\n  constructor(v) {\n    this.parameterIndex = 0;\n    this.partIndex = 0;\n    this.partId = \"\";\n    this.link = [];\n    if (v != void 0) {\n      this.assignment(v);\n    }\n  }\n  assignment(v) {\n    this.partId = v.partId;\n    this.link = v.link.map((link) => link.clone());\n    return this;\n  }\n  initialize(model) {\n    this.parameterIndex = model.getParameterIndex(this.partId);\n    this.partIndex = model.getPartIndex(this.partId);\n    model.setParameterValueByIndex(this.parameterIndex, 1);\n  }\n  clone() {\n    const clonePartData = new PartData();\n    clonePartData.partId = this.partId;\n    clonePartData.parameterIndex = this.parameterIndex;\n    clonePartData.partIndex = this.partIndex;\n    clonePartData.link = this.link.map((link) => link.clone());\n    return clonePartData;\n  }\n}\nclass CubismVector2 {\n  constructor(x, y) {\n    this.x = x || 0;\n    this.y = y || 0;\n  }\n  add(vector2) {\n    const ret = new CubismVector2(0, 0);\n    ret.x = this.x + vector2.x;\n    ret.y = this.y + vector2.y;\n    return ret;\n  }\n  substract(vector2) {\n    const ret = new CubismVector2(0, 0);\n    ret.x = this.x - vector2.x;\n    ret.y = this.y - vector2.y;\n    return ret;\n  }\n  multiply(vector2) {\n    const ret = new CubismVector2(0, 0);\n    ret.x = this.x * vector2.x;\n    ret.y = this.y * vector2.y;\n    return ret;\n  }\n  multiplyByScaler(scalar) {\n    return this.multiply(new CubismVector2(scalar, scalar));\n  }\n  division(vector2) {\n    const ret = new CubismVector2(0, 0);\n    ret.x = this.x / vector2.x;\n    ret.y = this.y / vector2.y;\n    return ret;\n  }\n  divisionByScalar(scalar) {\n    return this.division(new CubismVector2(scalar, scalar));\n  }\n  getLength() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n  getDistanceWith(a) {\n    return Math.sqrt((this.x - a.x) * (this.x - a.x) + (this.y - a.y) * (this.y - a.y));\n  }\n  dot(a) {\n    return this.x * a.x + this.y * a.y;\n  }\n  normalize() {\n    const length = Math.pow(this.x * this.x + this.y * this.y, 0.5);\n    this.x = this.x / length;\n    this.y = this.y / length;\n  }\n  isEqual(rhs) {\n    return this.x == rhs.x && this.y == rhs.y;\n  }\n  isNotEqual(rhs) {\n    return !this.isEqual(rhs);\n  }\n}\nconst _CubismMath = class {\n  static range(value, min, max) {\n    if (value < min) {\n      value = min;\n    } else if (value > max) {\n      value = max;\n    }\n    return value;\n  }\n  static sin(x) {\n    return Math.sin(x);\n  }\n  static cos(x) {\n    return Math.cos(x);\n  }\n  static abs(x) {\n    return Math.abs(x);\n  }\n  static sqrt(x) {\n    return Math.sqrt(x);\n  }\n  static cbrt(x) {\n    if (x === 0) {\n      return x;\n    }\n    let cx = x;\n    const isNegativeNumber = cx < 0;\n    if (isNegativeNumber) {\n      cx = -cx;\n    }\n    let ret;\n    if (cx === Infinity) {\n      ret = Infinity;\n    } else {\n      ret = Math.exp(Math.log(cx) / 3);\n      ret = (cx / (ret * ret) + 2 * ret) / 3;\n    }\n    return isNegativeNumber ? -ret : ret;\n  }\n  static getEasingSine(value) {\n    if (value < 0) {\n      return 0;\n    } else if (value > 1) {\n      return 1;\n    }\n    return 0.5 - 0.5 * this.cos(value * Math.PI);\n  }\n  static max(left, right) {\n    return left > right ? left : right;\n  }\n  static min(left, right) {\n    return left > right ? right : left;\n  }\n  static degreesToRadian(degrees) {\n    return degrees / 180 * Math.PI;\n  }\n  static radianToDegrees(radian) {\n    return radian * 180 / Math.PI;\n  }\n  static directionToRadian(from, to) {\n    const q1 = Math.atan2(to.y, to.x);\n    const q2 = Math.atan2(from.y, from.x);\n    let ret = q1 - q2;\n    while (ret < -Math.PI) {\n      ret += Math.PI * 2;\n    }\n    while (ret > Math.PI) {\n      ret -= Math.PI * 2;\n    }\n    return ret;\n  }\n  static directionToDegrees(from, to) {\n    const radian = this.directionToRadian(from, to);\n    let degree = this.radianToDegrees(radian);\n    if (to.x - from.x > 0) {\n      degree = -degree;\n    }\n    return degree;\n  }\n  static radianToDirection(totalAngle) {\n    const ret = new CubismVector2();\n    ret.x = this.sin(totalAngle);\n    ret.y = this.cos(totalAngle);\n    return ret;\n  }\n  static quadraticEquation(a, b, c) {\n    if (this.abs(a) < _CubismMath.Epsilon) {\n      if (this.abs(b) < _CubismMath.Epsilon) {\n        return -c;\n      }\n      return -c / b;\n    }\n    return -(b + this.sqrt(b * b - 4 * a * c)) / (2 * a);\n  }\n  static cardanoAlgorithmForBezier(a, b, c, d) {\n    if (this.sqrt(a) < _CubismMath.Epsilon) {\n      return this.range(this.quadraticEquation(b, c, d), 0, 1);\n    }\n    const ba = b / a;\n    const ca = c / a;\n    const da = d / a;\n    const p = (3 * ca - ba * ba) / 3;\n    const p3 = p / 3;\n    const q = (2 * ba * ba * ba - 9 * ba * ca + 27 * da) / 27;\n    const q2 = q / 2;\n    const discriminant = q2 * q2 + p3 * p3 * p3;\n    const center = 0.5;\n    const threshold = center + 0.01;\n    if (discriminant < 0) {\n      const mp3 = -p / 3;\n      const mp33 = mp3 * mp3 * mp3;\n      const r = this.sqrt(mp33);\n      const t = -q / (2 * r);\n      const cosphi = this.range(t, -1, 1);\n      const phi = Math.acos(cosphi);\n      const crtr = this.cbrt(r);\n      const t1 = 2 * crtr;\n      const root12 = t1 * this.cos(phi / 3) - ba / 3;\n      if (this.abs(root12 - center) < threshold) {\n        return this.range(root12, 0, 1);\n      }\n      const root2 = t1 * this.cos((phi + 2 * Math.PI) / 3) - ba / 3;\n      if (this.abs(root2 - center) < threshold) {\n        return this.range(root2, 0, 1);\n      }\n      const root3 = t1 * this.cos((phi + 4 * Math.PI) / 3) - ba / 3;\n      return this.range(root3, 0, 1);\n    }\n    if (discriminant == 0) {\n      let u12;\n      if (q2 < 0) {\n        u12 = this.cbrt(-q2);\n      } else {\n        u12 = -this.cbrt(q2);\n      }\n      const root12 = 2 * u12 - ba / 3;\n      if (this.abs(root12 - center) < threshold) {\n        return this.range(root12, 0, 1);\n      }\n      const root2 = -u12 - ba / 3;\n      return this.range(root2, 0, 1);\n    }\n    const sd = this.sqrt(discriminant);\n    const u1 = this.cbrt(sd - q2);\n    const v1 = this.cbrt(sd + q2);\n    const root1 = u1 - v1 - ba / 3;\n    return this.range(root1, 0, 1);\n  }\n  constructor() {\n  }\n};\nlet CubismMath = _CubismMath;\nCubismMath.Epsilon = 1e-5;\nclass CubismMatrix44 {\n  constructor() {\n    this._tr = new Float32Array(16);\n    this.loadIdentity();\n  }\n  static multiply(a, b, dst) {\n    const c = new Float32Array([\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0\n    ]);\n    const n = 4;\n    for (let i = 0; i < n; ++i) {\n      for (let j = 0; j < n; ++j) {\n        for (let k = 0; k < n; ++k) {\n          c[j + i * 4] += a[k + i * 4] * b[j + k * 4];\n        }\n      }\n    }\n    for (let i = 0; i < 16; ++i) {\n      dst[i] = c[i];\n    }\n  }\n  loadIdentity() {\n    const c = new Float32Array([\n      1,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      1\n    ]);\n    this.setMatrix(c);\n  }\n  setMatrix(tr) {\n    for (let i = 0; i < 16; ++i) {\n      this._tr[i] = tr[i];\n    }\n  }\n  getArray() {\n    return this._tr;\n  }\n  getScaleX() {\n    return this._tr[0];\n  }\n  getScaleY() {\n    return this._tr[5];\n  }\n  getTranslateX() {\n    return this._tr[12];\n  }\n  getTranslateY() {\n    return this._tr[13];\n  }\n  transformX(src) {\n    return this._tr[0] * src + this._tr[12];\n  }\n  transformY(src) {\n    return this._tr[5] * src + this._tr[13];\n  }\n  invertTransformX(src) {\n    return (src - this._tr[12]) / this._tr[0];\n  }\n  invertTransformY(src) {\n    return (src - this._tr[13]) / this._tr[5];\n  }\n  translateRelative(x, y) {\n    const tr1 = new Float32Array([\n      1,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      x,\n      y,\n      0,\n      1\n    ]);\n    CubismMatrix44.multiply(tr1, this._tr, this._tr);\n  }\n  translate(x, y) {\n    this._tr[12] = x;\n    this._tr[13] = y;\n  }\n  translateX(x) {\n    this._tr[12] = x;\n  }\n  translateY(y) {\n    this._tr[13] = y;\n  }\n  scaleRelative(x, y) {\n    const tr1 = new Float32Array([\n      x,\n      0,\n      0,\n      0,\n      0,\n      y,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      1\n    ]);\n    CubismMatrix44.multiply(tr1, this._tr, this._tr);\n  }\n  scale(x, y) {\n    this._tr[0] = x;\n    this._tr[5] = y;\n  }\n  multiplyByMatrix(m) {\n    CubismMatrix44.multiply(m.getArray(), this._tr, this._tr);\n  }\n  clone() {\n    const cloneMatrix = new CubismMatrix44();\n    for (let i = 0; i < this._tr.length; i++) {\n      cloneMatrix._tr[i] = this._tr[i];\n    }\n    return cloneMatrix;\n  }\n}\nclass CubismRenderer {\n  initialize(model) {\n    this._model = model;\n  }\n  drawModel() {\n    if (this.getModel() == null)\n      return;\n    this.doDrawModel();\n  }\n  setMvpMatrix(matrix44) {\n    this._mvpMatrix4x4.setMatrix(matrix44.getArray());\n  }\n  getMvpMatrix() {\n    return this._mvpMatrix4x4;\n  }\n  setModelColor(red, green, blue, alpha) {\n    if (red < 0) {\n      red = 0;\n    } else if (red > 1) {\n      red = 1;\n    }\n    if (green < 0) {\n      green = 0;\n    } else if (green > 1) {\n      green = 1;\n    }\n    if (blue < 0) {\n      blue = 0;\n    } else if (blue > 1) {\n      blue = 1;\n    }\n    if (alpha < 0) {\n      alpha = 0;\n    } else if (alpha > 1) {\n      alpha = 1;\n    }\n    this._modelColor.R = red;\n    this._modelColor.G = green;\n    this._modelColor.B = blue;\n    this._modelColor.A = alpha;\n  }\n  getModelColor() {\n    return Object.assign({}, this._modelColor);\n  }\n  setIsPremultipliedAlpha(enable) {\n    this._isPremultipliedAlpha = enable;\n  }\n  isPremultipliedAlpha() {\n    return this._isPremultipliedAlpha;\n  }\n  setIsCulling(culling) {\n    this._isCulling = culling;\n  }\n  isCulling() {\n    return this._isCulling;\n  }\n  setAnisotropy(n) {\n    this._anisortopy = n;\n  }\n  getAnisotropy() {\n    return this._anisortopy;\n  }\n  getModel() {\n    return this._model;\n  }\n  constructor() {\n    this._isCulling = false;\n    this._isPremultipliedAlpha = false;\n    this._anisortopy = 0;\n    this._modelColor = new CubismTextureColor();\n    this._mvpMatrix4x4 = new CubismMatrix44();\n    this._mvpMatrix4x4.loadIdentity();\n  }\n}\nvar CubismBlendMode = /* @__PURE__ */ ((CubismBlendMode2) => {\n  CubismBlendMode2[CubismBlendMode2[\"CubismBlendMode_Normal\"] = 0] = \"CubismBlendMode_Normal\";\n  CubismBlendMode2[CubismBlendMode2[\"CubismBlendMode_Additive\"] = 1] = \"CubismBlendMode_Additive\";\n  CubismBlendMode2[CubismBlendMode2[\"CubismBlendMode_Multiplicative\"] = 2] = \"CubismBlendMode_Multiplicative\";\n  return CubismBlendMode2;\n})(CubismBlendMode || {});\nclass CubismTextureColor {\n  constructor() {\n    this.R = 1;\n    this.G = 1;\n    this.B = 1;\n    this.A = 1;\n  }\n}\nlet s_isStarted = false;\nlet s_isInitialized = false;\nlet s_option = void 0;\nconst Constant = {\n  vertexOffset: 0,\n  vertexStep: 2\n};\nclass CubismFramework {\n  static startUp(option) {\n    if (s_isStarted) {\n      CubismLogInfo(\"CubismFramework.startUp() is already done.\");\n      return s_isStarted;\n    }\n    if (Live2DCubismCore._isStarted) {\n      s_isStarted = true;\n      return true;\n    }\n    Live2DCubismCore._isStarted = true;\n    s_option = option;\n    if (s_option) {\n      Live2DCubismCore.Logging.csmSetLogFunction(s_option.logFunction);\n    }\n    s_isStarted = true;\n    if (s_isStarted) {\n      const version = Live2DCubismCore.Version.csmGetVersion();\n      const major = (version & 4278190080) >> 24;\n      const minor = (version & 16711680) >> 16;\n      const patch = version & 65535;\n      const versionNumber = version;\n      CubismLogInfo(`Live2D Cubism Core version: {0}.{1}.{2} ({3})`, (\"00\" + major).slice(-2), (\"00\" + minor).slice(-2), (\"0000\" + patch).slice(-4), versionNumber);\n    }\n    CubismLogInfo(\"CubismFramework.startUp() is complete.\");\n    return s_isStarted;\n  }\n  static cleanUp() {\n    s_isStarted = false;\n    s_isInitialized = false;\n    s_option = void 0;\n  }\n  static initialize() {\n    if (!s_isStarted) {\n      CubismLogWarning(\"CubismFramework is not started.\");\n      return;\n    }\n    if (s_isInitialized) {\n      CubismLogWarning(\"CubismFramework.initialize() skipped, already initialized.\");\n      return;\n    }\n    s_isInitialized = true;\n    CubismLogInfo(\"CubismFramework.initialize() is complete.\");\n  }\n  static dispose() {\n    if (!s_isStarted) {\n      CubismLogWarning(\"CubismFramework is not started.\");\n      return;\n    }\n    if (!s_isInitialized) {\n      CubismLogWarning(\"CubismFramework.dispose() skipped, not initialized.\");\n      return;\n    }\n    CubismRenderer.staticRelease();\n    s_isInitialized = false;\n    CubismLogInfo(\"CubismFramework.dispose() is complete.\");\n  }\n  static isStarted() {\n    return s_isStarted;\n  }\n  static isInitialized() {\n    return s_isInitialized;\n  }\n  static coreLogFunction(message) {\n    if (!Live2DCubismCore.Logging.csmGetLogFunction()) {\n      return;\n    }\n    Live2DCubismCore.Logging.csmGetLogFunction()(message);\n  }\n  static getLoggingLevel() {\n    if (s_option != null) {\n      return s_option.loggingLevel;\n    }\n    return LogLevel.LogLevel_Off;\n  }\n  constructor() {\n  }\n}\nvar LogLevel = /* @__PURE__ */ ((LogLevel2) => {\n  LogLevel2[LogLevel2[\"LogLevel_Verbose\"] = 0] = \"LogLevel_Verbose\";\n  LogLevel2[LogLevel2[\"LogLevel_Debug\"] = 1] = \"LogLevel_Debug\";\n  LogLevel2[LogLevel2[\"LogLevel_Info\"] = 2] = \"LogLevel_Info\";\n  LogLevel2[LogLevel2[\"LogLevel_Warning\"] = 3] = \"LogLevel_Warning\";\n  LogLevel2[LogLevel2[\"LogLevel_Error\"] = 4] = \"LogLevel_Error\";\n  LogLevel2[LogLevel2[\"LogLevel_Off\"] = 5] = \"LogLevel_Off\";\n  return LogLevel2;\n})(LogLevel || {});\nconst CSM_ASSERT = () => {\n};\nfunction CubismLogVerbose(fmt, ...args) {\n  CubismDebug.print(LogLevel.LogLevel_Verbose, \"[CSM][V]\" + fmt + \"\\n\", args);\n}\nfunction CubismLogDebug(fmt, ...args) {\n  CubismDebug.print(LogLevel.LogLevel_Debug, \"[CSM][D]\" + fmt + \"\\n\", args);\n}\nfunction CubismLogInfo(fmt, ...args) {\n  CubismDebug.print(LogLevel.LogLevel_Info, \"[CSM][I]\" + fmt + \"\\n\", args);\n}\nfunction CubismLogWarning(fmt, ...args) {\n  CubismDebug.print(LogLevel.LogLevel_Warning, \"[CSM][W]\" + fmt + \"\\n\", args);\n}\nfunction CubismLogError(fmt, ...args) {\n  CubismDebug.print(LogLevel.LogLevel_Error, \"[CSM][E]\" + fmt + \"\\n\", args);\n}\nclass CubismDebug {\n  static print(logLevel, format, args) {\n    if (logLevel < CubismFramework.getLoggingLevel()) {\n      return;\n    }\n    const logPrint = CubismFramework.coreLogFunction;\n    if (!logPrint)\n      return;\n    const buffer = format.replace(/{(\\d+)}/g, (m, k) => {\n      return args[k];\n    });\n    logPrint(buffer);\n  }\n  static dumpBytes(logLevel, data, length) {\n    for (let i = 0; i < length; i++) {\n      if (i % 16 == 0 && i > 0)\n        this.print(logLevel, \"\\n\");\n      else if (i % 8 == 0 && i > 0)\n        this.print(logLevel, \"  \");\n      this.print(logLevel, \"{0} \", [data[i] & 255]);\n    }\n    this.print(logLevel, \"\\n\");\n  }\n  constructor() {\n  }\n}\nclass CubismModel {\n  update() {\n    this._model.update();\n    this._model.drawables.resetDynamicFlags();\n  }\n  getCanvasWidth() {\n    if (this._model == null) {\n      return 0;\n    }\n    return this._model.canvasinfo.CanvasWidth / this._model.canvasinfo.PixelsPerUnit;\n  }\n  getCanvasHeight() {\n    if (this._model == null) {\n      return 0;\n    }\n    return this._model.canvasinfo.CanvasHeight / this._model.canvasinfo.PixelsPerUnit;\n  }\n  saveParameters() {\n    const parameterCount = this._model.parameters.count;\n    const savedParameterCount = this._savedParameters.length;\n    for (let i = 0; i < parameterCount; ++i) {\n      if (i < savedParameterCount) {\n        this._savedParameters[i] = this._parameterValues[i];\n      } else {\n        this._savedParameters.push(this._parameterValues[i]);\n      }\n    }\n  }\n  getModel() {\n    return this._model;\n  }\n  getPartIndex(partId) {\n    let partIndex;\n    const partCount = this._model.parts.count;\n    for (partIndex = 0; partIndex < partCount; ++partIndex) {\n      if (partId == this._partIds[partIndex]) {\n        return partIndex;\n      }\n    }\n    if (partId in this._notExistPartId) {\n      return this._notExistPartId[partId];\n    }\n    partIndex = partCount + this._notExistPartId.length;\n    this._notExistPartId[partId] = partIndex;\n    this._notExistPartOpacities[partIndex] = 0;\n    return partIndex;\n  }\n  getPartCount() {\n    return this._model.parts.count;\n  }\n  setPartOpacityByIndex(partIndex, opacity) {\n    if (partIndex in this._notExistPartOpacities) {\n      this._notExistPartOpacities[partIndex] = opacity;\n      return;\n    }\n    CSM_ASSERT(0 <= partIndex && partIndex < this.getPartCount());\n    this._partOpacities[partIndex] = opacity;\n  }\n  setPartOpacityById(partId, opacity) {\n    const index = this.getPartIndex(partId);\n    if (index < 0) {\n      return;\n    }\n    this.setPartOpacityByIndex(index, opacity);\n  }\n  getPartOpacityByIndex(partIndex) {\n    if (partIndex in this._notExistPartOpacities) {\n      return this._notExistPartOpacities[partIndex];\n    }\n    CSM_ASSERT(0 <= partIndex && partIndex < this.getPartCount());\n    return this._partOpacities[partIndex];\n  }\n  getPartOpacityById(partId) {\n    const index = this.getPartIndex(partId);\n    if (index < 0) {\n      return 0;\n    }\n    return this.getPartOpacityByIndex(index);\n  }\n  getParameterIndex(parameterId) {\n    let parameterIndex;\n    const idCount = this._model.parameters.count;\n    for (parameterIndex = 0; parameterIndex < idCount; ++parameterIndex) {\n      if (parameterId != this._parameterIds[parameterIndex]) {\n        continue;\n      }\n      return parameterIndex;\n    }\n    if (parameterId in this._notExistParameterId) {\n      return this._notExistParameterId[parameterId];\n    }\n    parameterIndex = this._model.parameters.count + Object.keys(this._notExistParameterId).length;\n    this._notExistParameterId[parameterId] = parameterIndex;\n    this._notExistParameterValues[parameterIndex] = 0;\n    return parameterIndex;\n  }\n  getParameterCount() {\n    return this._model.parameters.count;\n  }\n  getParameterMaximumValue(parameterIndex) {\n    return this._model.parameters.maximumValues[parameterIndex];\n  }\n  getParameterMinimumValue(parameterIndex) {\n    return this._model.parameters.minimumValues[parameterIndex];\n  }\n  getParameterDefaultValue(parameterIndex) {\n    return this._model.parameters.defaultValues[parameterIndex];\n  }\n  getParameterValueByIndex(parameterIndex) {\n    if (parameterIndex in this._notExistParameterValues) {\n      return this._notExistParameterValues[parameterIndex];\n    }\n    CSM_ASSERT(0 <= parameterIndex && parameterIndex < this.getParameterCount());\n    return this._parameterValues[parameterIndex];\n  }\n  getParameterValueById(parameterId) {\n    const parameterIndex = this.getParameterIndex(parameterId);\n    return this.getParameterValueByIndex(parameterIndex);\n  }\n  setParameterValueByIndex(parameterIndex, value, weight = 1) {\n    if (parameterIndex in this._notExistParameterValues) {\n      this._notExistParameterValues[parameterIndex] = weight == 1 ? value : this._notExistParameterValues[parameterIndex] * (1 - weight) + value * weight;\n      return;\n    }\n    CSM_ASSERT(0 <= parameterIndex && parameterIndex < this.getParameterCount());\n    if (this._model.parameters.maximumValues[parameterIndex] < value) {\n      value = this._model.parameters.maximumValues[parameterIndex];\n    }\n    if (this._model.parameters.minimumValues[parameterIndex] > value) {\n      value = this._model.parameters.minimumValues[parameterIndex];\n    }\n    this._parameterValues[parameterIndex] = weight == 1 ? value : this._parameterValues[parameterIndex] = this._parameterValues[parameterIndex] * (1 - weight) + value * weight;\n  }\n  setParameterValueById(parameterId, value, weight = 1) {\n    const index = this.getParameterIndex(parameterId);\n    this.setParameterValueByIndex(index, value, weight);\n  }\n  addParameterValueByIndex(parameterIndex, value, weight = 1) {\n    this.setParameterValueByIndex(parameterIndex, this.getParameterValueByIndex(parameterIndex) + value * weight);\n  }\n  addParameterValueById(parameterId, value, weight = 1) {\n    const index = this.getParameterIndex(parameterId);\n    this.addParameterValueByIndex(index, value, weight);\n  }\n  multiplyParameterValueById(parameterId, value, weight = 1) {\n    const index = this.getParameterIndex(parameterId);\n    this.multiplyParameterValueByIndex(index, value, weight);\n  }\n  multiplyParameterValueByIndex(parameterIndex, value, weight = 1) {\n    this.setParameterValueByIndex(parameterIndex, this.getParameterValueByIndex(parameterIndex) * (1 + (value - 1) * weight));\n  }\n  getDrawableIds() {\n    return this._drawableIds.slice();\n  }\n  getDrawableIndex(drawableId) {\n    const drawableCount = this._model.drawables.count;\n    for (let drawableIndex = 0; drawableIndex < drawableCount; ++drawableIndex) {\n      if (this._drawableIds[drawableIndex] == drawableId) {\n        return drawableIndex;\n      }\n    }\n    return -1;\n  }\n  getDrawableCount() {\n    return this._model.drawables.count;\n  }\n  getDrawableId(drawableIndex) {\n    return this._model.drawables.ids[drawableIndex];\n  }\n  getDrawableRenderOrders() {\n    return this._model.drawables.renderOrders;\n  }\n  getDrawableTextureIndices(drawableIndex) {\n    return this._model.drawables.textureIndices[drawableIndex];\n  }\n  getDrawableDynamicFlagVertexPositionsDidChange(drawableIndex) {\n    const dynamicFlags = this._model.drawables.dynamicFlags;\n    return Live2DCubismCore.Utils.hasVertexPositionsDidChangeBit(dynamicFlags[drawableIndex]);\n  }\n  getDrawableVertexIndexCount(drawableIndex) {\n    return this._model.drawables.indexCounts[drawableIndex];\n  }\n  getDrawableVertexCount(drawableIndex) {\n    return this._model.drawables.vertexCounts[drawableIndex];\n  }\n  getDrawableVertices(drawableIndex) {\n    return this.getDrawableVertexPositions(drawableIndex);\n  }\n  getDrawableVertexIndices(drawableIndex) {\n    return this._model.drawables.indices[drawableIndex];\n  }\n  getDrawableVertexPositions(drawableIndex) {\n    return this._model.drawables.vertexPositions[drawableIndex];\n  }\n  getDrawableVertexUvs(drawableIndex) {\n    return this._model.drawables.vertexUvs[drawableIndex];\n  }\n  getDrawableOpacity(drawableIndex) {\n    return this._model.drawables.opacities[drawableIndex];\n  }\n  getDrawableCulling(drawableIndex) {\n    const constantFlags = this._model.drawables.constantFlags;\n    return !Live2DCubismCore.Utils.hasIsDoubleSidedBit(constantFlags[drawableIndex]);\n  }\n  getDrawableBlendMode(drawableIndex) {\n    const constantFlags = this._model.drawables.constantFlags;\n    return Live2DCubismCore.Utils.hasBlendAdditiveBit(constantFlags[drawableIndex]) ? CubismBlendMode.CubismBlendMode_Additive : Live2DCubismCore.Utils.hasBlendMultiplicativeBit(constantFlags[drawableIndex]) ? CubismBlendMode.CubismBlendMode_Multiplicative : CubismBlendMode.CubismBlendMode_Normal;\n  }\n  getDrawableInvertedMaskBit(drawableIndex) {\n    const constantFlags = this._model.drawables.constantFlags;\n    return Live2DCubismCore.Utils.hasIsInvertedMaskBit(constantFlags[drawableIndex]);\n  }\n  getDrawableMasks() {\n    return this._model.drawables.masks;\n  }\n  getDrawableMaskCounts() {\n    return this._model.drawables.maskCounts;\n  }\n  isUsingMasking() {\n    for (let d = 0; d < this._model.drawables.count; ++d) {\n      if (this._model.drawables.maskCounts[d] <= 0) {\n        continue;\n      }\n      return true;\n    }\n    return false;\n  }\n  getDrawableDynamicFlagIsVisible(drawableIndex) {\n    const dynamicFlags = this._model.drawables.dynamicFlags;\n    return Live2DCubismCore.Utils.hasIsVisibleBit(dynamicFlags[drawableIndex]);\n  }\n  getDrawableDynamicFlagVisibilityDidChange(drawableIndex) {\n    const dynamicFlags = this._model.drawables.dynamicFlags;\n    return Live2DCubismCore.Utils.hasVisibilityDidChangeBit(dynamicFlags[drawableIndex]);\n  }\n  getDrawableDynamicFlagOpacityDidChange(drawableIndex) {\n    const dynamicFlags = this._model.drawables.dynamicFlags;\n    return Live2DCubismCore.Utils.hasOpacityDidChangeBit(dynamicFlags[drawableIndex]);\n  }\n  getDrawableDynamicFlagRenderOrderDidChange(drawableIndex) {\n    const dynamicFlags = this._model.drawables.dynamicFlags;\n    return Live2DCubismCore.Utils.hasRenderOrderDidChangeBit(dynamicFlags[drawableIndex]);\n  }\n  loadParameters() {\n    let parameterCount = this._model.parameters.count;\n    const savedParameterCount = this._savedParameters.length;\n    if (parameterCount > savedParameterCount) {\n      parameterCount = savedParameterCount;\n    }\n    for (let i = 0; i < parameterCount; ++i) {\n      this._parameterValues[i] = this._savedParameters[i];\n    }\n  }\n  initialize() {\n    this._parameterValues = this._model.parameters.values;\n    this._partOpacities = this._model.parts.opacities;\n    this._parameterMaximumValues = this._model.parameters.maximumValues;\n    this._parameterMinimumValues = this._model.parameters.minimumValues;\n    {\n      const parameterIds = this._model.parameters.ids;\n      const parameterCount = this._model.parameters.count;\n      for (let i = 0; i < parameterCount; ++i) {\n        this._parameterIds.push(parameterIds[i]);\n      }\n    }\n    {\n      const partIds = this._model.parts.ids;\n      const partCount = this._model.parts.count;\n      for (let i = 0; i < partCount; ++i) {\n        this._partIds.push(partIds[i]);\n      }\n    }\n    {\n      const drawableIds = this._model.drawables.ids;\n      const drawableCount = this._model.drawables.count;\n      for (let i = 0; i < drawableCount; ++i) {\n        this._drawableIds.push(drawableIds[i]);\n      }\n    }\n  }\n  constructor(model) {\n    this._model = model;\n    this._savedParameters = [];\n    this._parameterIds = [];\n    this._drawableIds = [];\n    this._partIds = [];\n    this._notExistPartId = {};\n    this._notExistParameterId = {};\n    this._notExistParameterValues = {};\n    this._notExistPartOpacities = {};\n    this.initialize();\n  }\n  release() {\n    this._model.release();\n    this._model = void 0;\n  }\n}\nclass CubismMoc {\n  static create(mocBytes) {\n    const moc = Live2DCubismCore.Moc.fromArrayBuffer(mocBytes);\n    if (moc) {\n      return new CubismMoc(moc);\n    }\n    throw new Error(\"Unknown error\");\n  }\n  createModel() {\n    let cubismModel;\n    const model = Live2DCubismCore.Model.fromMoc(this._moc);\n    if (model) {\n      cubismModel = new CubismModel(model);\n      ++this._modelCount;\n      return cubismModel;\n    }\n    throw new Error(\"Unknown error\");\n  }\n  deleteModel(model) {\n    if (model != null) {\n      --this._modelCount;\n    }\n  }\n  constructor(moc) {\n    this._moc = moc;\n    this._modelCount = 0;\n  }\n  release() {\n    this._moc._release();\n    this._moc = void 0;\n  }\n}\nclass CubismModelUserDataJson {\n  constructor(json, size) {\n    this._json = json;\n  }\n  release() {\n    this._json = void 0;\n  }\n  getUserDataCount() {\n    return this._json.Meta.UserDataCount;\n  }\n  getTotalUserDataSize() {\n    return this._json.Meta.TotalUserDataSize;\n  }\n  getUserDataTargetType(i) {\n    return this._json.UserData[i].Target;\n  }\n  getUserDataId(i) {\n    return this._json.UserData[i].Id;\n  }\n  getUserDataValue(i) {\n    return this._json.UserData[i].Value;\n  }\n}\nconst ArtMesh = \"ArtMesh\";\nclass CubismModelUserData {\n  static create(json, size) {\n    const ret = new CubismModelUserData();\n    ret.parseUserData(json, size);\n    return ret;\n  }\n  getArtMeshUserDatas() {\n    return this._artMeshUserDataNode;\n  }\n  parseUserData(data, size) {\n    let json = new CubismModelUserDataJson(data, size);\n    const typeOfArtMesh = ArtMesh;\n    const nodeCount = json.getUserDataCount();\n    for (let i = 0; i < nodeCount; i++) {\n      const addNode = {\n        targetId: json.getUserDataId(i),\n        targetType: json.getUserDataTargetType(i),\n        value: json.getUserDataValue(i)\n      };\n      this._userDataNodes.push(addNode);\n      if (addNode.targetType == typeOfArtMesh) {\n        this._artMeshUserDataNode.push(addNode);\n      }\n    }\n    json.release();\n  }\n  constructor() {\n    this._userDataNodes = [];\n    this._artMeshUserDataNode = [];\n  }\n  release() {\n    this._userDataNodes = null;\n  }\n}\nclass ACubismMotion {\n  constructor() {\n    this._fadeInSeconds = -1;\n    this._fadeOutSeconds = -1;\n    this._weight = 1;\n    this._offsetSeconds = 0;\n    this._firedEventValues = [];\n  }\n  release() {\n    this._weight = 0;\n  }\n  updateParameters(model, motionQueueEntry, userTimeSeconds) {\n    if (!motionQueueEntry.isAvailable() || motionQueueEntry.isFinished()) {\n      return;\n    }\n    if (!motionQueueEntry.isStarted()) {\n      motionQueueEntry.setIsStarted(true);\n      motionQueueEntry.setStartTime(userTimeSeconds - this._offsetSeconds);\n      motionQueueEntry.setFadeInStartTime(userTimeSeconds);\n      const duration = this.getDuration();\n      if (motionQueueEntry.getEndTime() < 0) {\n        motionQueueEntry.setEndTime(duration <= 0 ? -1 : motionQueueEntry.getStartTime() + duration);\n      }\n    }\n    let fadeWeight = this._weight;\n    const fadeIn = this._fadeInSeconds == 0 ? 1 : CubismMath.getEasingSine((userTimeSeconds - motionQueueEntry.getFadeInStartTime()) / this._fadeInSeconds);\n    const fadeOut = this._fadeOutSeconds == 0 || motionQueueEntry.getEndTime() < 0 ? 1 : CubismMath.getEasingSine((motionQueueEntry.getEndTime() - userTimeSeconds) / this._fadeOutSeconds);\n    fadeWeight = fadeWeight * fadeIn * fadeOut;\n    motionQueueEntry.setState(userTimeSeconds, fadeWeight);\n    this.doUpdateParameters(model, userTimeSeconds, fadeWeight, motionQueueEntry);\n    if (motionQueueEntry.getEndTime() > 0 && motionQueueEntry.getEndTime() < userTimeSeconds) {\n      motionQueueEntry.setIsFinished(true);\n    }\n  }\n  setFadeInTime(fadeInSeconds) {\n    this._fadeInSeconds = fadeInSeconds;\n  }\n  setFadeOutTime(fadeOutSeconds) {\n    this._fadeOutSeconds = fadeOutSeconds;\n  }\n  getFadeOutTime() {\n    return this._fadeOutSeconds;\n  }\n  getFadeInTime() {\n    return this._fadeInSeconds;\n  }\n  setWeight(weight) {\n    this._weight = weight;\n  }\n  getWeight() {\n    return this._weight;\n  }\n  getDuration() {\n    return -1;\n  }\n  getLoopDuration() {\n    return -1;\n  }\n  setOffsetTime(offsetSeconds) {\n    this._offsetSeconds = offsetSeconds;\n  }\n  getFiredEvent(beforeCheckTimeSeconds, motionTimeSeconds) {\n    return this._firedEventValues;\n  }\n  setFinishedMotionHandler(onFinishedMotionHandler) {\n    this._onFinishedMotion = onFinishedMotionHandler;\n  }\n  getFinishedMotionHandler() {\n    return this._onFinishedMotion;\n  }\n}\nconst DefaultFadeTime = 1;\nclass CubismExpressionMotion extends ACubismMotion {\n  constructor() {\n    super();\n    this._parameters = [];\n  }\n  static create(json) {\n    const expression = new CubismExpressionMotion();\n    const fadeInTime = json.FadeInTime;\n    const fadeOutTime = json.FadeOutTime;\n    expression.setFadeInTime(fadeInTime !== void 0 ? fadeInTime : DefaultFadeTime);\n    expression.setFadeOutTime(fadeOutTime !== void 0 ? fadeOutTime : DefaultFadeTime);\n    const parameters = json.Parameters || [];\n    for (let i = 0; i < parameters.length; ++i) {\n      const param = parameters[i];\n      const parameterId = param.Id;\n      const value = param.Value;\n      let blendType;\n      switch (param.Blend) {\n        case \"Multiply\":\n          blendType = ExpressionBlendType.ExpressionBlendType_Multiply;\n          break;\n        case \"Overwrite\":\n          blendType = ExpressionBlendType.ExpressionBlendType_Overwrite;\n          break;\n        case \"Add\":\n        default:\n          blendType = ExpressionBlendType.ExpressionBlendType_Add;\n          break;\n      }\n      const item = {\n        parameterId,\n        blendType,\n        value\n      };\n      expression._parameters.push(item);\n    }\n    return expression;\n  }\n  doUpdateParameters(model, userTimeSeconds, weight, motionQueueEntry) {\n    for (let i = 0; i < this._parameters.length; ++i) {\n      const parameter = this._parameters[i];\n      switch (parameter.blendType) {\n        case ExpressionBlendType.ExpressionBlendType_Add: {\n          model.addParameterValueById(parameter.parameterId, parameter.value, weight);\n          break;\n        }\n        case ExpressionBlendType.ExpressionBlendType_Multiply: {\n          model.multiplyParameterValueById(parameter.parameterId, parameter.value, weight);\n          break;\n        }\n        case ExpressionBlendType.ExpressionBlendType_Overwrite: {\n          model.setParameterValueById(parameter.parameterId, parameter.value, weight);\n          break;\n        }\n      }\n    }\n  }\n}\nvar ExpressionBlendType = /* @__PURE__ */ ((ExpressionBlendType2) => {\n  ExpressionBlendType2[ExpressionBlendType2[\"ExpressionBlendType_Add\"] = 0] = \"ExpressionBlendType_Add\";\n  ExpressionBlendType2[ExpressionBlendType2[\"ExpressionBlendType_Multiply\"] = 1] = \"ExpressionBlendType_Multiply\";\n  ExpressionBlendType2[ExpressionBlendType2[\"ExpressionBlendType_Overwrite\"] = 2] = \"ExpressionBlendType_Overwrite\";\n  return ExpressionBlendType2;\n})(ExpressionBlendType || {});\nvar CubismConfig;\n((CubismConfig2) => {\n  CubismConfig2.supportMoreMaskDivisions = true;\n  CubismConfig2.setOpacityFromMotion = false;\n})(CubismConfig || (CubismConfig = {}));\nvar CubismMotionCurveTarget = /* @__PURE__ */ ((CubismMotionCurveTarget2) => {\n  CubismMotionCurveTarget2[CubismMotionCurveTarget2[\"CubismMotionCurveTarget_Model\"] = 0] = \"CubismMotionCurveTarget_Model\";\n  CubismMotionCurveTarget2[CubismMotionCurveTarget2[\"CubismMotionCurveTarget_Parameter\"] = 1] = \"CubismMotionCurveTarget_Parameter\";\n  CubismMotionCurveTarget2[CubismMotionCurveTarget2[\"CubismMotionCurveTarget_PartOpacity\"] = 2] = \"CubismMotionCurveTarget_PartOpacity\";\n  return CubismMotionCurveTarget2;\n})(CubismMotionCurveTarget || {});\nvar CubismMotionSegmentType = /* @__PURE__ */ ((CubismMotionSegmentType2) => {\n  CubismMotionSegmentType2[CubismMotionSegmentType2[\"CubismMotionSegmentType_Linear\"] = 0] = \"CubismMotionSegmentType_Linear\";\n  CubismMotionSegmentType2[CubismMotionSegmentType2[\"CubismMotionSegmentType_Bezier\"] = 1] = \"CubismMotionSegmentType_Bezier\";\n  CubismMotionSegmentType2[CubismMotionSegmentType2[\"CubismMotionSegmentType_Stepped\"] = 2] = \"CubismMotionSegmentType_Stepped\";\n  CubismMotionSegmentType2[CubismMotionSegmentType2[\"CubismMotionSegmentType_InverseStepped\"] = 3] = \"CubismMotionSegmentType_InverseStepped\";\n  return CubismMotionSegmentType2;\n})(CubismMotionSegmentType || {});\nclass CubismMotionPoint {\n  constructor(time = 0, value = 0) {\n    this.time = time;\n    this.value = value;\n  }\n}\nclass CubismMotionSegment {\n  constructor() {\n    this.basePointIndex = 0;\n    this.segmentType = 0;\n  }\n}\nclass CubismMotionCurve {\n  constructor() {\n    this.id = \"\";\n    this.type = 0;\n    this.segmentCount = 0;\n    this.baseSegmentIndex = 0;\n    this.fadeInTime = 0;\n    this.fadeOutTime = 0;\n  }\n}\nclass CubismMotionEvent {\n  constructor() {\n    this.fireTime = 0;\n    this.value = \"\";\n  }\n}\nclass CubismMotionData {\n  constructor() {\n    this.duration = 0;\n    this.loop = false;\n    this.curveCount = 0;\n    this.eventCount = 0;\n    this.fps = 0;\n    this.curves = [];\n    this.segments = [];\n    this.points = [];\n    this.events = [];\n  }\n}\nclass CubismMotionJson {\n  constructor(json) {\n    this._json = json;\n  }\n  release() {\n    this._json = void 0;\n  }\n  getMotionDuration() {\n    return this._json.Meta.Duration;\n  }\n  isMotionLoop() {\n    return this._json.Meta.Loop || false;\n  }\n  getEvaluationOptionFlag(flagType) {\n    if (EvaluationOptionFlag.EvaluationOptionFlag_AreBeziersRistricted == flagType) {\n      return !!this._json.Meta.AreBeziersRestricted;\n    }\n    return false;\n  }\n  getMotionCurveCount() {\n    return this._json.Meta.CurveCount;\n  }\n  getMotionFps() {\n    return this._json.Meta.Fps;\n  }\n  getMotionTotalSegmentCount() {\n    return this._json.Meta.TotalSegmentCount;\n  }\n  getMotionTotalPointCount() {\n    return this._json.Meta.TotalPointCount;\n  }\n  getMotionFadeInTime() {\n    return this._json.Meta.FadeInTime;\n  }\n  getMotionFadeOutTime() {\n    return this._json.Meta.FadeOutTime;\n  }\n  getMotionCurveTarget(curveIndex) {\n    return this._json.Curves[curveIndex].Target;\n  }\n  getMotionCurveId(curveIndex) {\n    return this._json.Curves[curveIndex].Id;\n  }\n  getMotionCurveFadeInTime(curveIndex) {\n    return this._json.Curves[curveIndex].FadeInTime;\n  }\n  getMotionCurveFadeOutTime(curveIndex) {\n    return this._json.Curves[curveIndex].FadeOutTime;\n  }\n  getMotionCurveSegmentCount(curveIndex) {\n    return this._json.Curves[curveIndex].Segments.length;\n  }\n  getMotionCurveSegment(curveIndex, segmentIndex) {\n    return this._json.Curves[curveIndex].Segments[segmentIndex];\n  }\n  getEventCount() {\n    return this._json.Meta.UserDataCount || 0;\n  }\n  getTotalEventValueSize() {\n    return this._json.Meta.TotalUserDataSize;\n  }\n  getEventTime(userDataIndex) {\n    return this._json.UserData[userDataIndex].Time;\n  }\n  getEventValue(userDataIndex) {\n    return this._json.UserData[userDataIndex].Value;\n  }\n}\nvar EvaluationOptionFlag = /* @__PURE__ */ ((EvaluationOptionFlag2) => {\n  EvaluationOptionFlag2[EvaluationOptionFlag2[\"EvaluationOptionFlag_AreBeziersRistricted\"] = 0] = \"EvaluationOptionFlag_AreBeziersRistricted\";\n  return EvaluationOptionFlag2;\n})(EvaluationOptionFlag || {});\nconst EffectNameEyeBlink = \"EyeBlink\";\nconst EffectNameLipSync = \"LipSync\";\nconst TargetNameModel = \"Model\";\nconst TargetNameParameter = \"Parameter\";\nconst TargetNamePartOpacity = \"PartOpacity\";\nconst UseOldBeziersCurveMotion = false;\nfunction lerpPoints(a, b, t) {\n  const result = new CubismMotionPoint();\n  result.time = a.time + (b.time - a.time) * t;\n  result.value = a.value + (b.value - a.value) * t;\n  return result;\n}\nfunction linearEvaluate(points, time) {\n  let t = (time - points[0].time) / (points[1].time - points[0].time);\n  if (t < 0) {\n    t = 0;\n  }\n  return points[0].value + (points[1].value - points[0].value) * t;\n}\nfunction bezierEvaluate(points, time) {\n  let t = (time - points[0].time) / (points[3].time - points[0].time);\n  if (t < 0) {\n    t = 0;\n  }\n  const p01 = lerpPoints(points[0], points[1], t);\n  const p12 = lerpPoints(points[1], points[2], t);\n  const p23 = lerpPoints(points[2], points[3], t);\n  const p012 = lerpPoints(p01, p12, t);\n  const p123 = lerpPoints(p12, p23, t);\n  return lerpPoints(p012, p123, t).value;\n}\nfunction bezierEvaluateCardanoInterpretation(points, time) {\n  const x = time;\n  const x1 = points[0].time;\n  const x2 = points[3].time;\n  const cx1 = points[1].time;\n  const cx2 = points[2].time;\n  const a = x2 - 3 * cx2 + 3 * cx1 - x1;\n  const b = 3 * cx2 - 6 * cx1 + 3 * x1;\n  const c = 3 * cx1 - 3 * x1;\n  const d = x1 - x;\n  const t = CubismMath.cardanoAlgorithmForBezier(a, b, c, d);\n  const p01 = lerpPoints(points[0], points[1], t);\n  const p12 = lerpPoints(points[1], points[2], t);\n  const p23 = lerpPoints(points[2], points[3], t);\n  const p012 = lerpPoints(p01, p12, t);\n  const p123 = lerpPoints(p12, p23, t);\n  return lerpPoints(p012, p123, t).value;\n}\nfunction steppedEvaluate(points, time) {\n  return points[0].value;\n}\nfunction inverseSteppedEvaluate(points, time) {\n  return points[1].value;\n}\nfunction evaluateCurve(motionData, index, time) {\n  const curve = motionData.curves[index];\n  let target = -1;\n  const totalSegmentCount = curve.baseSegmentIndex + curve.segmentCount;\n  let pointPosition = 0;\n  for (let i = curve.baseSegmentIndex; i < totalSegmentCount; ++i) {\n    pointPosition = motionData.segments[i].basePointIndex + (motionData.segments[i].segmentType == CubismMotionSegmentType.CubismMotionSegmentType_Bezier ? 3 : 1);\n    if (motionData.points[pointPosition].time > time) {\n      target = i;\n      break;\n    }\n  }\n  if (target == -1) {\n    return motionData.points[pointPosition].value;\n  }\n  const segment = motionData.segments[target];\n  return segment.evaluate(motionData.points.slice(segment.basePointIndex), time);\n}\nclass CubismMotion extends ACubismMotion {\n  constructor() {\n    super();\n    this._eyeBlinkParameterIds = [];\n    this._lipSyncParameterIds = [];\n    this._sourceFrameRate = 30;\n    this._loopDurationSeconds = -1;\n    this._isLoop = false;\n    this._isLoopFadeIn = true;\n    this._lastWeight = 0;\n  }\n  static create(json, onFinishedMotionHandler) {\n    const ret = new CubismMotion();\n    ret.parse(json);\n    ret._sourceFrameRate = ret._motionData.fps;\n    ret._loopDurationSeconds = ret._motionData.duration;\n    ret._onFinishedMotion = onFinishedMotionHandler;\n    return ret;\n  }\n  doUpdateParameters(model, userTimeSeconds, fadeWeight, motionQueueEntry) {\n    if (this._modelCurveIdEyeBlink == null) {\n      this._modelCurveIdEyeBlink = EffectNameEyeBlink;\n    }\n    if (this._modelCurveIdLipSync == null) {\n      this._modelCurveIdLipSync = EffectNameLipSync;\n    }\n    let timeOffsetSeconds = userTimeSeconds - motionQueueEntry.getStartTime();\n    if (timeOffsetSeconds < 0) {\n      timeOffsetSeconds = 0;\n    }\n    let lipSyncValue = Number.MAX_VALUE;\n    let eyeBlinkValue = Number.MAX_VALUE;\n    const MaxTargetSize = 64;\n    let lipSyncFlags = 0;\n    let eyeBlinkFlags = 0;\n    if (this._eyeBlinkParameterIds.length > MaxTargetSize) {\n      CubismLogDebug(\"too many eye blink targets : {0}\", this._eyeBlinkParameterIds.length);\n    }\n    if (this._lipSyncParameterIds.length > MaxTargetSize) {\n      CubismLogDebug(\"too many lip sync targets : {0}\", this._lipSyncParameterIds.length);\n    }\n    const tmpFadeIn = this._fadeInSeconds <= 0 ? 1 : CubismMath.getEasingSine((userTimeSeconds - motionQueueEntry.getFadeInStartTime()) / this._fadeInSeconds);\n    const tmpFadeOut = this._fadeOutSeconds <= 0 || motionQueueEntry.getEndTime() < 0 ? 1 : CubismMath.getEasingSine((motionQueueEntry.getEndTime() - userTimeSeconds) / this._fadeOutSeconds);\n    let value;\n    let c, parameterIndex;\n    let time = timeOffsetSeconds;\n    if (this._isLoop) {\n      while (time > this._motionData.duration) {\n        time -= this._motionData.duration;\n      }\n    }\n    const curves = this._motionData.curves;\n    for (c = 0; c < this._motionData.curveCount && curves[c].type == CubismMotionCurveTarget.CubismMotionCurveTarget_Model; ++c) {\n      value = evaluateCurve(this._motionData, c, time);\n      if (curves[c].id == this._modelCurveIdEyeBlink) {\n        eyeBlinkValue = value;\n      } else if (curves[c].id == this._modelCurveIdLipSync) {\n        lipSyncValue = value;\n      }\n    }\n    for (; c < this._motionData.curveCount && curves[c].type == CubismMotionCurveTarget.CubismMotionCurveTarget_Parameter; ++c) {\n      parameterIndex = model.getParameterIndex(curves[c].id);\n      if (parameterIndex == -1) {\n        continue;\n      }\n      const sourceValue = model.getParameterValueByIndex(parameterIndex);\n      value = evaluateCurve(this._motionData, c, time);\n      if (eyeBlinkValue != Number.MAX_VALUE) {\n        for (let i = 0; i < this._eyeBlinkParameterIds.length && i < MaxTargetSize; ++i) {\n          if (this._eyeBlinkParameterIds[i] == curves[c].id) {\n            value *= eyeBlinkValue;\n            eyeBlinkFlags |= 1 << i;\n            break;\n          }\n        }\n      }\n      if (lipSyncValue != Number.MAX_VALUE) {\n        for (let i = 0; i < this._lipSyncParameterIds.length && i < MaxTargetSize; ++i) {\n          if (this._lipSyncParameterIds[i] == curves[c].id) {\n            value += lipSyncValue;\n            lipSyncFlags |= 1 << i;\n            break;\n          }\n        }\n      }\n      let v;\n      if (curves[c].fadeInTime < 0 && curves[c].fadeOutTime < 0) {\n        v = sourceValue + (value - sourceValue) * fadeWeight;\n      } else {\n        let fin;\n        let fout;\n        if (curves[c].fadeInTime < 0) {\n          fin = tmpFadeIn;\n        } else {\n          fin = curves[c].fadeInTime == 0 ? 1 : CubismMath.getEasingSine((userTimeSeconds - motionQueueEntry.getFadeInStartTime()) / curves[c].fadeInTime);\n        }\n        if (curves[c].fadeOutTime < 0) {\n          fout = tmpFadeOut;\n        } else {\n          fout = curves[c].fadeOutTime == 0 || motionQueueEntry.getEndTime() < 0 ? 1 : CubismMath.getEasingSine((motionQueueEntry.getEndTime() - userTimeSeconds) / curves[c].fadeOutTime);\n        }\n        const paramWeight = this._weight * fin * fout;\n        v = sourceValue + (value - sourceValue) * paramWeight;\n      }\n      model.setParameterValueByIndex(parameterIndex, v, 1);\n    }\n    {\n      if (eyeBlinkValue != Number.MAX_VALUE) {\n        for (let i = 0; i < this._eyeBlinkParameterIds.length && i < MaxTargetSize; ++i) {\n          const sourceValue = model.getParameterValueById(this._eyeBlinkParameterIds[i]);\n          if (eyeBlinkFlags >> i & 1) {\n            continue;\n          }\n          const v = sourceValue + (eyeBlinkValue - sourceValue) * fadeWeight;\n          model.setParameterValueById(this._eyeBlinkParameterIds[i], v);\n        }\n      }\n      if (lipSyncValue != Number.MAX_VALUE) {\n        for (let i = 0; i < this._lipSyncParameterIds.length && i < MaxTargetSize; ++i) {\n          const sourceValue = model.getParameterValueById(this._lipSyncParameterIds[i]);\n          if (lipSyncFlags >> i & 1) {\n            continue;\n          }\n          const v = sourceValue + (lipSyncValue - sourceValue) * fadeWeight;\n          model.setParameterValueById(this._lipSyncParameterIds[i], v);\n        }\n      }\n    }\n    for (; c < this._motionData.curveCount && curves[c].type == CubismMotionCurveTarget.CubismMotionCurveTarget_PartOpacity; ++c) {\n      value = evaluateCurve(this._motionData, c, time);\n      if (CubismConfig.setOpacityFromMotion) {\n        model.setPartOpacityById(curves[c].id, value);\n      } else {\n        parameterIndex = model.getParameterIndex(curves[c].id);\n        if (parameterIndex == -1) {\n          continue;\n        }\n        model.setParameterValueByIndex(parameterIndex, value);\n      }\n    }\n    if (timeOffsetSeconds >= this._motionData.duration) {\n      if (this._isLoop) {\n        motionQueueEntry.setStartTime(userTimeSeconds);\n        if (this._isLoopFadeIn) {\n          motionQueueEntry.setFadeInStartTime(userTimeSeconds);\n        }\n      } else {\n        if (this._onFinishedMotion) {\n          this._onFinishedMotion(this);\n        }\n        motionQueueEntry.setIsFinished(true);\n      }\n    }\n    this._lastWeight = fadeWeight;\n  }\n  setIsLoop(loop) {\n    this._isLoop = loop;\n  }\n  isLoop() {\n    return this._isLoop;\n  }\n  setIsLoopFadeIn(loopFadeIn) {\n    this._isLoopFadeIn = loopFadeIn;\n  }\n  isLoopFadeIn() {\n    return this._isLoopFadeIn;\n  }\n  getDuration() {\n    return this._isLoop ? -1 : this._loopDurationSeconds;\n  }\n  getLoopDuration() {\n    return this._loopDurationSeconds;\n  }\n  setParameterFadeInTime(parameterId, value) {\n    const curves = this._motionData.curves;\n    for (let i = 0; i < this._motionData.curveCount; ++i) {\n      if (parameterId == curves[i].id) {\n        curves[i].fadeInTime = value;\n        return;\n      }\n    }\n  }\n  setParameterFadeOutTime(parameterId, value) {\n    const curves = this._motionData.curves;\n    for (let i = 0; i < this._motionData.curveCount; ++i) {\n      if (parameterId == curves[i].id) {\n        curves[i].fadeOutTime = value;\n        return;\n      }\n    }\n  }\n  getParameterFadeInTime(parameterId) {\n    const curves = this._motionData.curves;\n    for (let i = 0; i < this._motionData.curveCount; ++i) {\n      if (parameterId == curves[i].id) {\n        return curves[i].fadeInTime;\n      }\n    }\n    return -1;\n  }\n  getParameterFadeOutTime(parameterId) {\n    const curves = this._motionData.curves;\n    for (let i = 0; i < this._motionData.curveCount; ++i) {\n      if (parameterId == curves[i].id) {\n        return curves[i].fadeOutTime;\n      }\n    }\n    return -1;\n  }\n  setEffectIds(eyeBlinkParameterIds, lipSyncParameterIds) {\n    this._eyeBlinkParameterIds = eyeBlinkParameterIds;\n    this._lipSyncParameterIds = lipSyncParameterIds;\n  }\n  release() {\n    this._motionData = void 0;\n  }\n  parse(motionJson) {\n    this._motionData = new CubismMotionData();\n    let json = new CubismMotionJson(motionJson);\n    this._motionData.duration = json.getMotionDuration();\n    this._motionData.loop = json.isMotionLoop();\n    this._motionData.curveCount = json.getMotionCurveCount();\n    this._motionData.fps = json.getMotionFps();\n    this._motionData.eventCount = json.getEventCount();\n    const areBeziersRestructed = json.getEvaluationOptionFlag(EvaluationOptionFlag.EvaluationOptionFlag_AreBeziersRistricted);\n    const fadeInSeconds = json.getMotionFadeInTime();\n    const fadeOutSeconds = json.getMotionFadeOutTime();\n    if (fadeInSeconds !== void 0) {\n      this._fadeInSeconds = fadeInSeconds < 0 ? 1 : fadeInSeconds;\n    } else {\n      this._fadeInSeconds = 1;\n    }\n    if (fadeOutSeconds !== void 0) {\n      this._fadeOutSeconds = fadeOutSeconds < 0 ? 1 : fadeOutSeconds;\n    } else {\n      this._fadeOutSeconds = 1;\n    }\n    this._motionData.curves = Array.from({ length: this._motionData.curveCount }).map(() => new CubismMotionCurve());\n    this._motionData.segments = Array.from({ length: json.getMotionTotalSegmentCount() }).map(() => new CubismMotionSegment());\n    this._motionData.events = Array.from({ length: this._motionData.eventCount }).map(() => new CubismMotionEvent());\n    this._motionData.points = [];\n    let totalPointCount = 0;\n    let totalSegmentCount = 0;\n    for (let curveCount = 0; curveCount < this._motionData.curveCount; ++curveCount) {\n      const curve = this._motionData.curves[curveCount];\n      switch (json.getMotionCurveTarget(curveCount)) {\n        case TargetNameModel:\n          curve.type = CubismMotionCurveTarget.CubismMotionCurveTarget_Model;\n          break;\n        case TargetNameParameter:\n          curve.type = CubismMotionCurveTarget.CubismMotionCurveTarget_Parameter;\n          break;\n        case TargetNamePartOpacity:\n          curve.type = CubismMotionCurveTarget.CubismMotionCurveTarget_PartOpacity;\n          break;\n        default:\n          CubismLogWarning('Warning : Unable to get segment type from Curve! The number of \"CurveCount\" may be incorrect!');\n      }\n      curve.id = json.getMotionCurveId(curveCount);\n      curve.baseSegmentIndex = totalSegmentCount;\n      const fadeInTime = json.getMotionCurveFadeInTime(curveCount);\n      const fadeOutTime = json.getMotionCurveFadeOutTime(curveCount);\n      curve.fadeInTime = fadeInTime !== void 0 ? fadeInTime : -1;\n      curve.fadeOutTime = fadeOutTime !== void 0 ? fadeOutTime : -1;\n      for (let segmentPosition = 0; segmentPosition < json.getMotionCurveSegmentCount(curveCount); ) {\n        if (segmentPosition == 0) {\n          this._motionData.segments[totalSegmentCount].basePointIndex = totalPointCount;\n          this._motionData.points[totalPointCount] = new CubismMotionPoint(json.getMotionCurveSegment(curveCount, segmentPosition), json.getMotionCurveSegment(curveCount, segmentPosition + 1));\n          totalPointCount += 1;\n          segmentPosition += 2;\n        } else {\n          this._motionData.segments[totalSegmentCount].basePointIndex = totalPointCount - 1;\n        }\n        const segment = json.getMotionCurveSegment(curveCount, segmentPosition);\n        switch (segment) {\n          case CubismMotionSegmentType.CubismMotionSegmentType_Linear: {\n            this._motionData.segments[totalSegmentCount].segmentType = CubismMotionSegmentType.CubismMotionSegmentType_Linear;\n            this._motionData.segments[totalSegmentCount].evaluate = linearEvaluate;\n            this._motionData.points[totalPointCount] = new CubismMotionPoint(json.getMotionCurveSegment(curveCount, segmentPosition + 1), json.getMotionCurveSegment(curveCount, segmentPosition + 2));\n            totalPointCount += 1;\n            segmentPosition += 3;\n            break;\n          }\n          case CubismMotionSegmentType.CubismMotionSegmentType_Bezier: {\n            this._motionData.segments[totalSegmentCount].segmentType = CubismMotionSegmentType.CubismMotionSegmentType_Bezier;\n            if (areBeziersRestructed || UseOldBeziersCurveMotion) {\n              this._motionData.segments[totalSegmentCount].evaluate = bezierEvaluate;\n            } else {\n              this._motionData.segments[totalSegmentCount].evaluate = bezierEvaluateCardanoInterpretation;\n            }\n            this._motionData.points[totalPointCount] = new CubismMotionPoint(json.getMotionCurveSegment(curveCount, segmentPosition + 1), json.getMotionCurveSegment(curveCount, segmentPosition + 2));\n            this._motionData.points[totalPointCount + 1] = new CubismMotionPoint(json.getMotionCurveSegment(curveCount, segmentPosition + 3), json.getMotionCurveSegment(curveCount, segmentPosition + 4));\n            this._motionData.points[totalPointCount + 2] = new CubismMotionPoint(json.getMotionCurveSegment(curveCount, segmentPosition + 5), json.getMotionCurveSegment(curveCount, segmentPosition + 6));\n            totalPointCount += 3;\n            segmentPosition += 7;\n            break;\n          }\n          case CubismMotionSegmentType.CubismMotionSegmentType_Stepped: {\n            this._motionData.segments[totalSegmentCount].segmentType = CubismMotionSegmentType.CubismMotionSegmentType_Stepped;\n            this._motionData.segments[totalSegmentCount].evaluate = steppedEvaluate;\n            this._motionData.points[totalPointCount] = new CubismMotionPoint(json.getMotionCurveSegment(curveCount, segmentPosition + 1), json.getMotionCurveSegment(curveCount, segmentPosition + 2));\n            totalPointCount += 1;\n            segmentPosition += 3;\n            break;\n          }\n          case CubismMotionSegmentType.CubismMotionSegmentType_InverseStepped: {\n            this._motionData.segments[totalSegmentCount].segmentType = CubismMotionSegmentType.CubismMotionSegmentType_InverseStepped;\n            this._motionData.segments[totalSegmentCount].evaluate = inverseSteppedEvaluate;\n            this._motionData.points[totalPointCount] = new CubismMotionPoint(json.getMotionCurveSegment(curveCount, segmentPosition + 1), json.getMotionCurveSegment(curveCount, segmentPosition + 2));\n            totalPointCount += 1;\n            segmentPosition += 3;\n            break;\n          }\n        }\n        ++curve.segmentCount;\n        ++totalSegmentCount;\n      }\n      this._motionData.curves.push(curve);\n    }\n    for (let userdatacount = 0; userdatacount < json.getEventCount(); ++userdatacount) {\n      this._motionData.events[userdatacount].fireTime = json.getEventTime(userdatacount);\n      this._motionData.events[userdatacount].value = json.getEventValue(userdatacount);\n    }\n    json.release();\n  }\n  getFiredEvent(beforeCheckTimeSeconds, motionTimeSeconds) {\n    this._firedEventValues.length = 0;\n    for (let u = 0; u < this._motionData.eventCount; ++u) {\n      if (this._motionData.events[u].fireTime > beforeCheckTimeSeconds && this._motionData.events[u].fireTime <= motionTimeSeconds) {\n        this._firedEventValues.push(this._motionData.events[u].value);\n      }\n    }\n    return this._firedEventValues;\n  }\n}\nclass CubismMotionQueueEntry {\n  constructor() {\n    this._autoDelete = false;\n    this._available = true;\n    this._finished = false;\n    this._started = false;\n    this._startTimeSeconds = -1;\n    this._fadeInStartTimeSeconds = 0;\n    this._endTimeSeconds = -1;\n    this._stateTimeSeconds = 0;\n    this._stateWeight = 0;\n    this._lastEventCheckSeconds = 0;\n    this._motionQueueEntryHandle = this;\n    this._fadeOutSeconds = 0;\n    this._isTriggeredFadeOut = false;\n  }\n  release() {\n    if (this._autoDelete && this._motion) {\n      this._motion.release();\n    }\n  }\n  setFadeOut(fadeOutSeconds) {\n    this._fadeOutSeconds = fadeOutSeconds;\n    this._isTriggeredFadeOut = true;\n  }\n  startFadeOut(fadeOutSeconds, userTimeSeconds) {\n    const newEndTimeSeconds = userTimeSeconds + fadeOutSeconds;\n    this._isTriggeredFadeOut = true;\n    if (this._endTimeSeconds < 0 || newEndTimeSeconds < this._endTimeSeconds) {\n      this._endTimeSeconds = newEndTimeSeconds;\n    }\n  }\n  isFinished() {\n    return this._finished;\n  }\n  isStarted() {\n    return this._started;\n  }\n  getStartTime() {\n    return this._startTimeSeconds;\n  }\n  getFadeInStartTime() {\n    return this._fadeInStartTimeSeconds;\n  }\n  getEndTime() {\n    return this._endTimeSeconds;\n  }\n  setStartTime(startTime) {\n    this._startTimeSeconds = startTime;\n  }\n  setFadeInStartTime(startTime) {\n    this._fadeInStartTimeSeconds = startTime;\n  }\n  setEndTime(endTime) {\n    this._endTimeSeconds = endTime;\n  }\n  setIsFinished(f) {\n    this._finished = f;\n  }\n  setIsStarted(f) {\n    this._started = f;\n  }\n  isAvailable() {\n    return this._available;\n  }\n  setIsAvailable(v) {\n    this._available = v;\n  }\n  setState(timeSeconds, weight) {\n    this._stateTimeSeconds = timeSeconds;\n    this._stateWeight = weight;\n  }\n  getStateTime() {\n    return this._stateTimeSeconds;\n  }\n  getStateWeight() {\n    return this._stateWeight;\n  }\n  getLastCheckEventSeconds() {\n    return this._lastEventCheckSeconds;\n  }\n  setLastCheckEventSeconds(checkSeconds) {\n    this._lastEventCheckSeconds = checkSeconds;\n  }\n  isTriggeredFadeOut() {\n    return this._isTriggeredFadeOut;\n  }\n  getFadeOutSeconds() {\n    return this._fadeOutSeconds;\n  }\n}\nclass CubismMotionQueueManager {\n  constructor() {\n    this._userTimeSeconds = 0;\n    this._eventCustomData = null;\n    this._motions = [];\n  }\n  release() {\n    for (let i = 0; i < this._motions.length; ++i) {\n      if (this._motions[i]) {\n        this._motions[i].release();\n      }\n    }\n    this._motions = void 0;\n  }\n  startMotion(motion, autoDelete, userTimeSeconds) {\n    if (motion == null) {\n      return InvalidMotionQueueEntryHandleValue;\n    }\n    let motionQueueEntry;\n    for (let i = 0; i < this._motions.length; ++i) {\n      motionQueueEntry = this._motions[i];\n      if (motionQueueEntry == null) {\n        continue;\n      }\n      motionQueueEntry.setFadeOut(motionQueueEntry._motion.getFadeOutTime());\n    }\n    motionQueueEntry = new CubismMotionQueueEntry();\n    motionQueueEntry._autoDelete = autoDelete;\n    motionQueueEntry._motion = motion;\n    this._motions.push(motionQueueEntry);\n    return motionQueueEntry._motionQueueEntryHandle;\n  }\n  isFinished() {\n    let i = 0;\n    while (i < this._motions.length) {\n      const motionQueueEntry = this._motions[i];\n      if (motionQueueEntry == null) {\n        this._motions.splice(i, 1);\n        continue;\n      }\n      const motion = motionQueueEntry._motion;\n      if (motion == null) {\n        motionQueueEntry.release();\n        this._motions.splice(i, 1);\n        continue;\n      }\n      if (!motionQueueEntry.isFinished()) {\n        return false;\n      }\n      i++;\n    }\n    return true;\n  }\n  isFinishedByHandle(motionQueueEntryNumber) {\n    for (let i = 0; i < this._motions.length; i++) {\n      const motionQueueEntry = this._motions[i];\n      if (motionQueueEntry == null) {\n        continue;\n      }\n      if (motionQueueEntry._motionQueueEntryHandle == motionQueueEntryNumber && !motionQueueEntry.isFinished()) {\n        return false;\n      }\n    }\n    return true;\n  }\n  stopAllMotions() {\n    for (let i = 0; i < this._motions.length; i++) {\n      const motionQueueEntry = this._motions[i];\n      if (motionQueueEntry != null) {\n        motionQueueEntry.release();\n      }\n    }\n    this._motions = [];\n  }\n  getCubismMotionQueueEntry(motionQueueEntryNumber) {\n    return this._motions.find((entry) => entry != null && entry._motionQueueEntryHandle == motionQueueEntryNumber);\n  }\n  setEventCallback(callback, customData = null) {\n    this._eventCallBack = callback;\n    this._eventCustomData = customData;\n  }\n  doUpdateMotion(model, userTimeSeconds) {\n    let updated = false;\n    let i = 0;\n    while (i < this._motions.length) {\n      const motionQueueEntry = this._motions[i];\n      if (motionQueueEntry == null) {\n        this._motions.splice(i, 1);\n        continue;\n      }\n      const motion = motionQueueEntry._motion;\n      if (motion == null) {\n        motionQueueEntry.release();\n        this._motions.splice(i, 1);\n        continue;\n      }\n      motion.updateParameters(model, motionQueueEntry, userTimeSeconds);\n      updated = true;\n      const firedList = motion.getFiredEvent(motionQueueEntry.getLastCheckEventSeconds() - motionQueueEntry.getStartTime(), userTimeSeconds - motionQueueEntry.getStartTime());\n      for (let i2 = 0; i2 < firedList.length; ++i2) {\n        this._eventCallBack(this, firedList[i2], this._eventCustomData);\n      }\n      motionQueueEntry.setLastCheckEventSeconds(userTimeSeconds);\n      if (motionQueueEntry.isFinished()) {\n        motionQueueEntry.release();\n        this._motions.splice(i, 1);\n      } else {\n        if (motionQueueEntry.isTriggeredFadeOut()) {\n          motionQueueEntry.startFadeOut(motionQueueEntry.getFadeOutSeconds(), userTimeSeconds);\n        }\n        i++;\n      }\n    }\n    return updated;\n  }\n}\nconst InvalidMotionQueueEntryHandleValue = -1;\nclass CubismMotionManager extends CubismMotionQueueManager {\n  constructor() {\n    super();\n    this._currentPriority = 0;\n    this._reservePriority = 0;\n  }\n  getCurrentPriority() {\n    return this._currentPriority;\n  }\n  getReservePriority() {\n    return this._reservePriority;\n  }\n  setReservePriority(val) {\n    this._reservePriority = val;\n  }\n  startMotionPriority(motion, autoDelete, priority) {\n    if (priority == this._reservePriority) {\n      this._reservePriority = 0;\n    }\n    this._currentPriority = priority;\n    return super.startMotion(motion, autoDelete, this._userTimeSeconds);\n  }\n  updateMotion(model, deltaTimeSeconds) {\n    this._userTimeSeconds += deltaTimeSeconds;\n    const updated = super.doUpdateMotion(model, this._userTimeSeconds);\n    if (this.isFinished()) {\n      this._currentPriority = 0;\n    }\n    return updated;\n  }\n  reserveMotion(priority) {\n    if (priority <= this._reservePriority || priority <= this._currentPriority) {\n      return false;\n    }\n    this._reservePriority = priority;\n    return true;\n  }\n}\nvar CubismPhysicsTargetType = /* @__PURE__ */ ((CubismPhysicsTargetType2) => {\n  CubismPhysicsTargetType2[CubismPhysicsTargetType2[\"CubismPhysicsTargetType_Parameter\"] = 0] = \"CubismPhysicsTargetType_Parameter\";\n  return CubismPhysicsTargetType2;\n})(CubismPhysicsTargetType || {});\nvar CubismPhysicsSource = /* @__PURE__ */ ((CubismPhysicsSource2) => {\n  CubismPhysicsSource2[CubismPhysicsSource2[\"CubismPhysicsSource_X\"] = 0] = \"CubismPhysicsSource_X\";\n  CubismPhysicsSource2[CubismPhysicsSource2[\"CubismPhysicsSource_Y\"] = 1] = \"CubismPhysicsSource_Y\";\n  CubismPhysicsSource2[CubismPhysicsSource2[\"CubismPhysicsSource_Angle\"] = 2] = \"CubismPhysicsSource_Angle\";\n  return CubismPhysicsSource2;\n})(CubismPhysicsSource || {});\nclass PhysicsJsonEffectiveForces {\n  constructor() {\n    this.gravity = new CubismVector2(0, 0);\n    this.wind = new CubismVector2(0, 0);\n  }\n}\nclass CubismPhysicsParticle {\n  constructor() {\n    this.initialPosition = new CubismVector2(0, 0);\n    this.position = new CubismVector2(0, 0);\n    this.lastPosition = new CubismVector2(0, 0);\n    this.lastGravity = new CubismVector2(0, 0);\n    this.force = new CubismVector2(0, 0);\n    this.velocity = new CubismVector2(0, 0);\n  }\n}\nclass CubismPhysicsSubRig {\n  constructor() {\n    this.normalizationPosition = {};\n    this.normalizationAngle = {};\n  }\n}\nclass CubismPhysicsInput {\n  constructor() {\n    this.source = {};\n  }\n}\nclass CubismPhysicsOutput {\n  constructor() {\n    this.destination = {};\n    this.translationScale = new CubismVector2(0, 0);\n  }\n}\nclass CubismPhysicsRig {\n  constructor() {\n    this.settings = [];\n    this.inputs = [];\n    this.outputs = [];\n    this.particles = [];\n    this.gravity = new CubismVector2(0, 0);\n    this.wind = new CubismVector2(0, 0);\n  }\n}\nclass CubismPhysicsJson {\n  constructor(json) {\n    this._json = json;\n  }\n  release() {\n    this._json = void 0;\n  }\n  getGravity() {\n    const ret = new CubismVector2(0, 0);\n    ret.x = this._json.Meta.EffectiveForces.Gravity.X;\n    ret.y = this._json.Meta.EffectiveForces.Gravity.Y;\n    return ret;\n  }\n  getWind() {\n    const ret = new CubismVector2(0, 0);\n    ret.x = this._json.Meta.EffectiveForces.Wind.X;\n    ret.y = this._json.Meta.EffectiveForces.Wind.Y;\n    return ret;\n  }\n  getSubRigCount() {\n    return this._json.Meta.PhysicsSettingCount;\n  }\n  getTotalInputCount() {\n    return this._json.Meta.TotalInputCount;\n  }\n  getTotalOutputCount() {\n    return this._json.Meta.TotalOutputCount;\n  }\n  getVertexCount() {\n    return this._json.Meta.VertexCount;\n  }\n  getNormalizationPositionMinimumValue(physicsSettingIndex) {\n    return this._json.PhysicsSettings[physicsSettingIndex].Normalization.Position.Minimum;\n  }\n  getNormalizationPositionMaximumValue(physicsSettingIndex) {\n    return this._json.PhysicsSettings[physicsSettingIndex].Normalization.Position.Maximum;\n  }\n  getNormalizationPositionDefaultValue(physicsSettingIndex) {\n    return this._json.PhysicsSettings[physicsSettingIndex].Normalization.Position.Default;\n  }\n  getNormalizationAngleMinimumValue(physicsSettingIndex) {\n    return this._json.PhysicsSettings[physicsSettingIndex].Normalization.Angle.Minimum;\n  }\n  getNormalizationAngleMaximumValue(physicsSettingIndex) {\n    return this._json.PhysicsSettings[physicsSettingIndex].Normalization.Angle.Maximum;\n  }\n  getNormalizationAngleDefaultValue(physicsSettingIndex) {\n    return this._json.PhysicsSettings[physicsSettingIndex].Normalization.Angle.Default;\n  }\n  getInputCount(physicsSettingIndex) {\n    return this._json.PhysicsSettings[physicsSettingIndex].Input.length;\n  }\n  getInputWeight(physicsSettingIndex, inputIndex) {\n    return this._json.PhysicsSettings[physicsSettingIndex].Input[inputIndex].Weight;\n  }\n  getInputReflect(physicsSettingIndex, inputIndex) {\n    return this._json.PhysicsSettings[physicsSettingIndex].Input[inputIndex].Reflect;\n  }\n  getInputType(physicsSettingIndex, inputIndex) {\n    return this._json.PhysicsSettings[physicsSettingIndex].Input[inputIndex].Type;\n  }\n  getInputSourceId(physicsSettingIndex, inputIndex) {\n    return this._json.PhysicsSettings[physicsSettingIndex].Input[inputIndex].Source.Id;\n  }\n  getOutputCount(physicsSettingIndex) {\n    return this._json.PhysicsSettings[physicsSettingIndex].Output.length;\n  }\n  getOutputVertexIndex(physicsSettingIndex, outputIndex) {\n    return this._json.PhysicsSettings[physicsSettingIndex].Output[outputIndex].VertexIndex;\n  }\n  getOutputAngleScale(physicsSettingIndex, outputIndex) {\n    return this._json.PhysicsSettings[physicsSettingIndex].Output[outputIndex].Scale;\n  }\n  getOutputWeight(physicsSettingIndex, outputIndex) {\n    return this._json.PhysicsSettings[physicsSettingIndex].Output[outputIndex].Weight;\n  }\n  getOutputDestinationId(physicsSettingIndex, outputIndex) {\n    return this._json.PhysicsSettings[physicsSettingIndex].Output[outputIndex].Destination.Id;\n  }\n  getOutputType(physicsSettingIndex, outputIndex) {\n    return this._json.PhysicsSettings[physicsSettingIndex].Output[outputIndex].Type;\n  }\n  getOutputReflect(physicsSettingIndex, outputIndex) {\n    return this._json.PhysicsSettings[physicsSettingIndex].Output[outputIndex].Reflect;\n  }\n  getParticleCount(physicsSettingIndex) {\n    return this._json.PhysicsSettings[physicsSettingIndex].Vertices.length;\n  }\n  getParticleMobility(physicsSettingIndex, vertexIndex) {\n    return this._json.PhysicsSettings[physicsSettingIndex].Vertices[vertexIndex].Mobility;\n  }\n  getParticleDelay(physicsSettingIndex, vertexIndex) {\n    return this._json.PhysicsSettings[physicsSettingIndex].Vertices[vertexIndex].Delay;\n  }\n  getParticleAcceleration(physicsSettingIndex, vertexIndex) {\n    return this._json.PhysicsSettings[physicsSettingIndex].Vertices[vertexIndex].Acceleration;\n  }\n  getParticleRadius(physicsSettingIndex, vertexIndex) {\n    return this._json.PhysicsSettings[physicsSettingIndex].Vertices[vertexIndex].Radius;\n  }\n  getParticlePosition(physicsSettingIndex, vertexIndex) {\n    const ret = new CubismVector2(0, 0);\n    ret.x = this._json.PhysicsSettings[physicsSettingIndex].Vertices[vertexIndex].Position.X;\n    ret.y = this._json.PhysicsSettings[physicsSettingIndex].Vertices[vertexIndex].Position.Y;\n    return ret;\n  }\n}\nconst PhysicsTypeTagX = \"X\";\nconst PhysicsTypeTagY = \"Y\";\nconst PhysicsTypeTagAngle = \"Angle\";\nconst AirResistance = 5;\nconst MaximumWeight = 100;\nconst MovementThreshold = 1e-3;\nclass CubismPhysics {\n  static create(json) {\n    const ret = new CubismPhysics();\n    ret.parse(json);\n    ret._physicsRig.gravity.y = 0;\n    return ret;\n  }\n  evaluate(model, deltaTimeSeconds) {\n    let totalAngle;\n    let weight;\n    let radAngle;\n    let outputValue;\n    const totalTranslation = new CubismVector2();\n    let currentSetting;\n    let currentInput;\n    let currentOutput;\n    let currentParticles;\n    let parameterValue;\n    let parameterMaximumValue;\n    let parameterMinimumValue;\n    let parameterDefaultValue;\n    parameterValue = model.getModel().parameters.values;\n    parameterMaximumValue = model.getModel().parameters.maximumValues;\n    parameterMinimumValue = model.getModel().parameters.minimumValues;\n    parameterDefaultValue = model.getModel().parameters.defaultValues;\n    for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {\n      totalAngle = { angle: 0 };\n      totalTranslation.x = 0;\n      totalTranslation.y = 0;\n      currentSetting = this._physicsRig.settings[settingIndex];\n      currentInput = this._physicsRig.inputs.slice(currentSetting.baseInputIndex);\n      currentOutput = this._physicsRig.outputs.slice(currentSetting.baseOutputIndex);\n      currentParticles = this._physicsRig.particles.slice(currentSetting.baseParticleIndex);\n      for (let i = 0; i < currentSetting.inputCount; ++i) {\n        weight = currentInput[i].weight / MaximumWeight;\n        if (currentInput[i].sourceParameterIndex == -1) {\n          currentInput[i].sourceParameterIndex = model.getParameterIndex(currentInput[i].source.id);\n        }\n        currentInput[i].getNormalizedParameterValue(totalTranslation, totalAngle, parameterValue[currentInput[i].sourceParameterIndex], parameterMinimumValue[currentInput[i].sourceParameterIndex], parameterMaximumValue[currentInput[i].sourceParameterIndex], parameterDefaultValue[currentInput[i].sourceParameterIndex], currentSetting.normalizationPosition, currentSetting.normalizationAngle, currentInput[i].reflect, weight);\n      }\n      radAngle = CubismMath.degreesToRadian(-totalAngle.angle);\n      totalTranslation.x = totalTranslation.x * CubismMath.cos(radAngle) - totalTranslation.y * CubismMath.sin(radAngle);\n      totalTranslation.y = totalTranslation.x * CubismMath.sin(radAngle) + totalTranslation.y * CubismMath.cos(radAngle);\n      updateParticles(currentParticles, currentSetting.particleCount, totalTranslation, totalAngle.angle, this._options.wind, MovementThreshold * currentSetting.normalizationPosition.maximum, deltaTimeSeconds, AirResistance);\n      for (let i = 0; i < currentSetting.outputCount; ++i) {\n        const particleIndex = currentOutput[i].vertexIndex;\n        if (particleIndex < 1 || particleIndex >= currentSetting.particleCount) {\n          break;\n        }\n        if (currentOutput[i].destinationParameterIndex == -1) {\n          currentOutput[i].destinationParameterIndex = model.getParameterIndex(currentOutput[i].destination.id);\n        }\n        const translation = new CubismVector2();\n        translation.x = currentParticles[particleIndex].position.x - currentParticles[particleIndex - 1].position.x;\n        translation.y = currentParticles[particleIndex].position.y - currentParticles[particleIndex - 1].position.y;\n        outputValue = currentOutput[i].getValue(translation, currentParticles, particleIndex, currentOutput[i].reflect, this._options.gravity);\n        const destinationParameterIndex = currentOutput[i].destinationParameterIndex;\n        const outParameterValue = !Float32Array.prototype.slice && \"subarray\" in Float32Array.prototype ? JSON.parse(JSON.stringify(parameterValue.subarray(destinationParameterIndex))) : parameterValue.slice(destinationParameterIndex);\n        updateOutputParameterValue(outParameterValue, parameterMinimumValue[destinationParameterIndex], parameterMaximumValue[destinationParameterIndex], outputValue, currentOutput[i]);\n        for (let offset = destinationParameterIndex, outParamIndex = 0; offset < parameterValue.length; offset++, outParamIndex++) {\n          parameterValue[offset] = outParameterValue[outParamIndex];\n        }\n      }\n    }\n  }\n  setOptions(options) {\n    this._options = options;\n  }\n  getOption() {\n    return this._options;\n  }\n  constructor() {\n    this._options = new Options();\n    this._options.gravity.y = -1;\n    this._options.gravity.x = 0;\n    this._options.wind.x = 0;\n    this._options.wind.y = 0;\n  }\n  release() {\n    this._physicsRig = void 0;\n  }\n  parse(physicsJson) {\n    this._physicsRig = new CubismPhysicsRig();\n    let json = new CubismPhysicsJson(physicsJson);\n    this._physicsRig.gravity = json.getGravity();\n    this._physicsRig.wind = json.getWind();\n    this._physicsRig.subRigCount = json.getSubRigCount();\n    let inputIndex = 0, outputIndex = 0, particleIndex = 0;\n    for (let i = 0; i < this._physicsRig.subRigCount; ++i) {\n      const setting = new CubismPhysicsSubRig();\n      setting.normalizationPosition.minimum = json.getNormalizationPositionMinimumValue(i);\n      setting.normalizationPosition.maximum = json.getNormalizationPositionMaximumValue(i);\n      setting.normalizationPosition.defalut = json.getNormalizationPositionDefaultValue(i);\n      setting.normalizationAngle.minimum = json.getNormalizationAngleMinimumValue(i);\n      setting.normalizationAngle.maximum = json.getNormalizationAngleMaximumValue(i);\n      setting.normalizationAngle.defalut = json.getNormalizationAngleDefaultValue(i);\n      setting.inputCount = json.getInputCount(i);\n      setting.baseInputIndex = inputIndex;\n      inputIndex += setting.inputCount;\n      for (let j = 0; j < setting.inputCount; ++j) {\n        const input = new CubismPhysicsInput();\n        input.sourceParameterIndex = -1;\n        input.weight = json.getInputWeight(i, j);\n        input.reflect = json.getInputReflect(i, j);\n        switch (json.getInputType(i, j)) {\n          case PhysicsTypeTagX:\n            input.type = CubismPhysicsSource.CubismPhysicsSource_X;\n            input.getNormalizedParameterValue = getInputTranslationXFromNormalizedParameterValue;\n            break;\n          case PhysicsTypeTagY:\n            input.type = CubismPhysicsSource.CubismPhysicsSource_Y;\n            input.getNormalizedParameterValue = getInputTranslationYFromNormalizedParamterValue;\n            break;\n          case PhysicsTypeTagAngle:\n            input.type = CubismPhysicsSource.CubismPhysicsSource_Angle;\n            input.getNormalizedParameterValue = getInputAngleFromNormalizedParameterValue;\n            break;\n        }\n        input.source.targetType = CubismPhysicsTargetType.CubismPhysicsTargetType_Parameter;\n        input.source.id = json.getInputSourceId(i, j);\n        this._physicsRig.inputs.push(input);\n      }\n      setting.outputCount = json.getOutputCount(i);\n      setting.baseOutputIndex = outputIndex;\n      outputIndex += setting.outputCount;\n      for (let j = 0; j < setting.outputCount; ++j) {\n        const output = new CubismPhysicsOutput();\n        output.destinationParameterIndex = -1;\n        output.vertexIndex = json.getOutputVertexIndex(i, j);\n        output.angleScale = json.getOutputAngleScale(i, j);\n        output.weight = json.getOutputWeight(i, j);\n        output.destination.targetType = CubismPhysicsTargetType.CubismPhysicsTargetType_Parameter;\n        output.destination.id = json.getOutputDestinationId(i, j);\n        switch (json.getOutputType(i, j)) {\n          case PhysicsTypeTagX:\n            output.type = CubismPhysicsSource.CubismPhysicsSource_X;\n            output.getValue = getOutputTranslationX;\n            output.getScale = getOutputScaleTranslationX;\n            break;\n          case PhysicsTypeTagY:\n            output.type = CubismPhysicsSource.CubismPhysicsSource_Y;\n            output.getValue = getOutputTranslationY;\n            output.getScale = getOutputScaleTranslationY;\n            break;\n          case PhysicsTypeTagAngle:\n            output.type = CubismPhysicsSource.CubismPhysicsSource_Angle;\n            output.getValue = getOutputAngle;\n            output.getScale = getOutputScaleAngle;\n            break;\n        }\n        output.reflect = json.getOutputReflect(i, j);\n        this._physicsRig.outputs.push(output);\n      }\n      setting.particleCount = json.getParticleCount(i);\n      setting.baseParticleIndex = particleIndex;\n      particleIndex += setting.particleCount;\n      for (let j = 0; j < setting.particleCount; ++j) {\n        const particle = new CubismPhysicsParticle();\n        particle.mobility = json.getParticleMobility(i, j);\n        particle.delay = json.getParticleDelay(i, j);\n        particle.acceleration = json.getParticleAcceleration(i, j);\n        particle.radius = json.getParticleRadius(i, j);\n        particle.position = json.getParticlePosition(i, j);\n        this._physicsRig.particles.push(particle);\n      }\n      this._physicsRig.settings.push(setting);\n    }\n    this.initialize();\n    json.release();\n  }\n  initialize() {\n    let strand;\n    let currentSetting;\n    let radius;\n    for (let settingIndex = 0; settingIndex < this._physicsRig.subRigCount; ++settingIndex) {\n      currentSetting = this._physicsRig.settings[settingIndex];\n      strand = this._physicsRig.particles.slice(currentSetting.baseParticleIndex);\n      strand[0].initialPosition = new CubismVector2(0, 0);\n      strand[0].lastPosition = new CubismVector2(strand[0].initialPosition.x, strand[0].initialPosition.y);\n      strand[0].lastGravity = new CubismVector2(0, -1);\n      strand[0].lastGravity.y *= -1;\n      strand[0].velocity = new CubismVector2(0, 0);\n      strand[0].force = new CubismVector2(0, 0);\n      for (let i = 1; i < currentSetting.particleCount; ++i) {\n        radius = new CubismVector2(0, 0);\n        radius.y = strand[i].radius;\n        strand[i].initialPosition = new CubismVector2(strand[i - 1].initialPosition.x + radius.x, strand[i - 1].initialPosition.y + radius.y);\n        strand[i].position = new CubismVector2(strand[i].initialPosition.x, strand[i].initialPosition.y);\n        strand[i].lastPosition = new CubismVector2(strand[i].initialPosition.x, strand[i].initialPosition.y);\n        strand[i].lastGravity = new CubismVector2(0, -1);\n        strand[i].lastGravity.y *= -1;\n        strand[i].velocity = new CubismVector2(0, 0);\n        strand[i].force = new CubismVector2(0, 0);\n      }\n    }\n  }\n}\nclass Options {\n  constructor() {\n    this.gravity = new CubismVector2(0, 0);\n    this.wind = new CubismVector2(0, 0);\n  }\n}\nfunction getInputTranslationXFromNormalizedParameterValue(targetTranslation, targetAngle, value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition, normalizationAngle, isInverted, weight) {\n  targetTranslation.x += normalizeParameterValue(value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition.minimum, normalizationPosition.maximum, normalizationPosition.defalut, isInverted) * weight;\n}\nfunction getInputTranslationYFromNormalizedParamterValue(targetTranslation, targetAngle, value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition, normalizationAngle, isInverted, weight) {\n  targetTranslation.y += normalizeParameterValue(value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationPosition.minimum, normalizationPosition.maximum, normalizationPosition.defalut, isInverted) * weight;\n}\nfunction getInputAngleFromNormalizedParameterValue(targetTranslation, targetAngle, value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizaitionPosition, normalizationAngle, isInverted, weight) {\n  targetAngle.angle += normalizeParameterValue(value, parameterMinimumValue, parameterMaximumValue, parameterDefaultValue, normalizationAngle.minimum, normalizationAngle.maximum, normalizationAngle.defalut, isInverted) * weight;\n}\nfunction getOutputTranslationX(translation, particles, particleIndex, isInverted, parentGravity) {\n  let outputValue = translation.x;\n  if (isInverted) {\n    outputValue *= -1;\n  }\n  return outputValue;\n}\nfunction getOutputTranslationY(translation, particles, particleIndex, isInverted, parentGravity) {\n  let outputValue = translation.y;\n  if (isInverted) {\n    outputValue *= -1;\n  }\n  return outputValue;\n}\nfunction getOutputAngle(translation, particles, particleIndex, isInverted, parentGravity) {\n  let outputValue;\n  if (particleIndex >= 2) {\n    parentGravity = particles[particleIndex - 1].position.substract(particles[particleIndex - 2].position);\n  } else {\n    parentGravity = parentGravity.multiplyByScaler(-1);\n  }\n  outputValue = CubismMath.directionToRadian(parentGravity, translation);\n  if (isInverted) {\n    outputValue *= -1;\n  }\n  return outputValue;\n}\nfunction getRangeValue(min, max) {\n  return Math.abs(Math.max(min, max) - Math.min(min, max));\n}\nfunction getDefaultValue(min, max) {\n  const minValue = Math.min(min, max);\n  return minValue + getRangeValue(min, max) / 2;\n}\nfunction getOutputScaleTranslationX(translationScale, angleScale) {\n  return translationScale.x;\n}\nfunction getOutputScaleTranslationY(translationScale, angleScale) {\n  return translationScale.y;\n}\nfunction getOutputScaleAngle(translationScale, angleScale) {\n  return angleScale;\n}\nfunction updateParticles(strand, strandCount, totalTranslation, totalAngle, windDirection, thresholdValue, deltaTimeSeconds, airResistance) {\n  let totalRadian;\n  let delay;\n  let radian;\n  let currentGravity;\n  let direction = new CubismVector2(0, 0);\n  let velocity = new CubismVector2(0, 0);\n  let force = new CubismVector2(0, 0);\n  let newDirection = new CubismVector2(0, 0);\n  strand[0].position = new CubismVector2(totalTranslation.x, totalTranslation.y);\n  totalRadian = CubismMath.degreesToRadian(totalAngle);\n  currentGravity = CubismMath.radianToDirection(totalRadian);\n  currentGravity.normalize();\n  for (let i = 1; i < strandCount; ++i) {\n    strand[i].force = currentGravity.multiplyByScaler(strand[i].acceleration).add(windDirection);\n    strand[i].lastPosition = new CubismVector2(strand[i].position.x, strand[i].position.y);\n    delay = strand[i].delay * deltaTimeSeconds * 30;\n    direction = strand[i].position.substract(strand[i - 1].position);\n    radian = CubismMath.directionToRadian(strand[i].lastGravity, currentGravity) / airResistance;\n    direction.x = CubismMath.cos(radian) * direction.x - direction.y * CubismMath.sin(radian);\n    direction.y = CubismMath.sin(radian) * direction.x + direction.y * CubismMath.cos(radian);\n    strand[i].position = strand[i - 1].position.add(direction);\n    velocity = strand[i].velocity.multiplyByScaler(delay);\n    force = strand[i].force.multiplyByScaler(delay).multiplyByScaler(delay);\n    strand[i].position = strand[i].position.add(velocity).add(force);\n    newDirection = strand[i].position.substract(strand[i - 1].position);\n    newDirection.normalize();\n    strand[i].position = strand[i - 1].position.add(newDirection.multiplyByScaler(strand[i].radius));\n    if (CubismMath.abs(strand[i].position.x) < thresholdValue) {\n      strand[i].position.x = 0;\n    }\n    if (delay != 0) {\n      strand[i].velocity = strand[i].position.substract(strand[i].lastPosition);\n      strand[i].velocity = strand[i].velocity.divisionByScalar(delay);\n      strand[i].velocity = strand[i].velocity.multiplyByScaler(strand[i].mobility);\n    }\n    strand[i].force = new CubismVector2(0, 0);\n    strand[i].lastGravity = new CubismVector2(currentGravity.x, currentGravity.y);\n  }\n}\nfunction updateOutputParameterValue(parameterValue, parameterValueMinimum, parameterValueMaximum, translation, output) {\n  let outputScale;\n  let value;\n  let weight;\n  outputScale = output.getScale(output.translationScale, output.angleScale);\n  value = translation * outputScale;\n  if (value < parameterValueMinimum) {\n    if (value < output.valueBelowMinimum) {\n      output.valueBelowMinimum = value;\n    }\n    value = parameterValueMinimum;\n  } else if (value > parameterValueMaximum) {\n    if (value > output.valueExceededMaximum) {\n      output.valueExceededMaximum = value;\n    }\n    value = parameterValueMaximum;\n  }\n  weight = output.weight / MaximumWeight;\n  if (weight >= 1) {\n    parameterValue[0] = value;\n  } else {\n    value = parameterValue[0] * (1 - weight) + value * weight;\n    parameterValue[0] = value;\n  }\n}\nfunction normalizeParameterValue(value, parameterMinimum, parameterMaximum, parameterDefault, normalizedMinimum, normalizedMaximum, normalizedDefault, isInverted) {\n  let result = 0;\n  const maxValue = CubismMath.max(parameterMaximum, parameterMinimum);\n  if (maxValue < value) {\n    value = maxValue;\n  }\n  const minValue = CubismMath.min(parameterMaximum, parameterMinimum);\n  if (minValue > value) {\n    value = minValue;\n  }\n  const minNormValue = CubismMath.min(normalizedMinimum, normalizedMaximum);\n  const maxNormValue = CubismMath.max(normalizedMinimum, normalizedMaximum);\n  const middleNormValue = normalizedDefault;\n  const middleValue = getDefaultValue(minValue, maxValue);\n  const paramValue = value - middleValue;\n  switch (Math.sign(paramValue)) {\n    case 1: {\n      const nLength = maxNormValue - middleNormValue;\n      const pLength = maxValue - middleValue;\n      if (pLength != 0) {\n        result = paramValue * (nLength / pLength);\n        result += middleNormValue;\n      }\n      break;\n    }\n    case -1: {\n      const nLength = minNormValue - middleNormValue;\n      const pLength = minValue - middleValue;\n      if (pLength != 0) {\n        result = paramValue * (nLength / pLength);\n        result += middleNormValue;\n      }\n      break;\n    }\n    case 0: {\n      result = middleNormValue;\n      break;\n    }\n  }\n  return isInverted ? result : result * -1;\n}\nclass csmRect {\n  constructor(x = 0, y = 0, w = 0, h = 0) {\n    this.x = x;\n    this.y = y;\n    this.width = w;\n    this.height = h;\n  }\n  getCenterX() {\n    return this.x + 0.5 * this.width;\n  }\n  getCenterY() {\n    return this.y + 0.5 * this.height;\n  }\n  getRight() {\n    return this.x + this.width;\n  }\n  getBottom() {\n    return this.y + this.height;\n  }\n  setRect(r) {\n    this.x = r.x;\n    this.y = r.y;\n    this.width = r.width;\n    this.height = r.height;\n  }\n  expand(w, h) {\n    this.x -= w;\n    this.y -= h;\n    this.width += w * 2;\n    this.height += h * 2;\n  }\n}\nconst ColorChannelCount = 4;\nconst shaderCount = 10;\nlet s_instance;\nlet s_viewport;\nlet s_fbo;\nclass CubismClippingManager_WebGL {\n  getChannelFlagAsColor(channelNo) {\n    return this._channelColors[channelNo];\n  }\n  getMaskRenderTexture() {\n    let ret = 0;\n    if (this._maskTexture && this._maskTexture.texture != 0) {\n      this._maskTexture.frameNo = this._currentFrameNo;\n      ret = this._maskTexture.texture;\n    }\n    if (ret == 0) {\n      const size = this._clippingMaskBufferSize;\n      this._colorBuffer = this.gl.createTexture();\n      this.gl.bindTexture(this.gl.TEXTURE_2D, this._colorBuffer);\n      this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, size, size, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);\n      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\n      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\n      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);\n      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);\n      this.gl.bindTexture(this.gl.TEXTURE_2D, null);\n      ret = this.gl.createFramebuffer();\n      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, ret);\n      this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, this._colorBuffer, 0);\n      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, s_fbo);\n      this._maskTexture = new CubismRenderTextureResource(this._currentFrameNo, ret);\n    }\n    return ret;\n  }\n  setGL(gl) {\n    this.gl = gl;\n  }\n  calcClippedDrawTotalBounds(model, clippingContext) {\n    let clippedDrawTotalMinX = Number.MAX_VALUE;\n    let clippedDrawTotalMinY = Number.MAX_VALUE;\n    let clippedDrawTotalMaxX = Number.MIN_VALUE;\n    let clippedDrawTotalMaxY = Number.MIN_VALUE;\n    const clippedDrawCount = clippingContext._clippedDrawableIndexList.length;\n    for (let clippedDrawableIndex = 0; clippedDrawableIndex < clippedDrawCount; clippedDrawableIndex++) {\n      const drawableIndex = clippingContext._clippedDrawableIndexList[clippedDrawableIndex];\n      const drawableVertexCount = model.getDrawableVertexCount(drawableIndex);\n      const drawableVertexes = model.getDrawableVertices(drawableIndex);\n      let minX = Number.MAX_VALUE;\n      let minY = Number.MAX_VALUE;\n      let maxX = Number.MIN_VALUE;\n      let maxY = Number.MIN_VALUE;\n      const loop = drawableVertexCount * Constant.vertexStep;\n      for (let pi = Constant.vertexOffset; pi < loop; pi += Constant.vertexStep) {\n        const x = drawableVertexes[pi];\n        const y = drawableVertexes[pi + 1];\n        if (x < minX) {\n          minX = x;\n        }\n        if (x > maxX) {\n          maxX = x;\n        }\n        if (y < minY) {\n          minY = y;\n        }\n        if (y > maxY) {\n          maxY = y;\n        }\n      }\n      if (minX == Number.MAX_VALUE) {\n        continue;\n      }\n      if (minX < clippedDrawTotalMinX) {\n        clippedDrawTotalMinX = minX;\n      }\n      if (minY < clippedDrawTotalMinY) {\n        clippedDrawTotalMinY = minY;\n      }\n      if (maxX > clippedDrawTotalMaxX) {\n        clippedDrawTotalMaxX = maxX;\n      }\n      if (maxY > clippedDrawTotalMaxY) {\n        clippedDrawTotalMaxY = maxY;\n      }\n      if (clippedDrawTotalMinX == Number.MAX_VALUE) {\n        clippingContext._allClippedDrawRect.x = 0;\n        clippingContext._allClippedDrawRect.y = 0;\n        clippingContext._allClippedDrawRect.width = 0;\n        clippingContext._allClippedDrawRect.height = 0;\n        clippingContext._isUsing = false;\n      } else {\n        clippingContext._isUsing = true;\n        const w = clippedDrawTotalMaxX - clippedDrawTotalMinX;\n        const h = clippedDrawTotalMaxY - clippedDrawTotalMinY;\n        clippingContext._allClippedDrawRect.x = clippedDrawTotalMinX;\n        clippingContext._allClippedDrawRect.y = clippedDrawTotalMinY;\n        clippingContext._allClippedDrawRect.width = w;\n        clippingContext._allClippedDrawRect.height = h;\n      }\n    }\n  }\n  constructor() {\n    this._maskRenderTexture = null;\n    this._colorBuffer = null;\n    this._currentFrameNo = 0;\n    this._clippingMaskBufferSize = 256;\n    this._clippingContextListForMask = [];\n    this._clippingContextListForDraw = [];\n    this._channelColors = [];\n    this._tmpBoundsOnModel = new csmRect();\n    this._tmpMatrix = new CubismMatrix44();\n    this._tmpMatrixForMask = new CubismMatrix44();\n    this._tmpMatrixForDraw = new CubismMatrix44();\n    let tmp = new CubismTextureColor();\n    tmp.R = 1;\n    tmp.G = 0;\n    tmp.B = 0;\n    tmp.A = 0;\n    this._channelColors.push(tmp);\n    tmp = new CubismTextureColor();\n    tmp.R = 0;\n    tmp.G = 1;\n    tmp.B = 0;\n    tmp.A = 0;\n    this._channelColors.push(tmp);\n    tmp = new CubismTextureColor();\n    tmp.R = 0;\n    tmp.G = 0;\n    tmp.B = 1;\n    tmp.A = 0;\n    this._channelColors.push(tmp);\n    tmp = new CubismTextureColor();\n    tmp.R = 0;\n    tmp.G = 0;\n    tmp.B = 0;\n    tmp.A = 1;\n    this._channelColors.push(tmp);\n  }\n  release() {\n    var _a, _b, _c;\n    const self = this;\n    for (let i = 0; i < this._clippingContextListForMask.length; i++) {\n      if (this._clippingContextListForMask[i]) {\n        (_a = this._clippingContextListForMask[i]) == null ? void 0 : _a.release();\n      }\n    }\n    self._clippingContextListForMask = void 0;\n    self._clippingContextListForDraw = void 0;\n    if (this._maskTexture) {\n      (_b = this.gl) == null ? void 0 : _b.deleteFramebuffer(this._maskTexture.texture);\n      self._maskTexture = void 0;\n    }\n    self._channelColors = void 0;\n    (_c = this.gl) == null ? void 0 : _c.deleteTexture(this._colorBuffer);\n    this._colorBuffer = null;\n  }\n  initialize(model, drawableCount, drawableMasks, drawableMaskCounts) {\n    for (let i = 0; i < drawableCount; i++) {\n      if (drawableMaskCounts[i] <= 0) {\n        this._clippingContextListForDraw.push(null);\n        continue;\n      }\n      let clippingContext = this.findSameClip(drawableMasks[i], drawableMaskCounts[i]);\n      if (clippingContext == null) {\n        clippingContext = new CubismClippingContext(this, drawableMasks[i], drawableMaskCounts[i]);\n        this._clippingContextListForMask.push(clippingContext);\n      }\n      clippingContext.addClippedDrawable(i);\n      this._clippingContextListForDraw.push(clippingContext);\n    }\n  }\n  setupClippingContext(model, renderer) {\n    this._currentFrameNo++;\n    let usingClipCount = 0;\n    for (let clipIndex = 0; clipIndex < this._clippingContextListForMask.length; clipIndex++) {\n      const cc = this._clippingContextListForMask[clipIndex];\n      this.calcClippedDrawTotalBounds(model, cc);\n      if (cc._isUsing) {\n        usingClipCount++;\n      }\n    }\n    if (usingClipCount > 0) {\n      this.gl.viewport(0, 0, this._clippingMaskBufferSize, this._clippingMaskBufferSize);\n      this._maskRenderTexture = this.getMaskRenderTexture();\n      renderer.getMvpMatrix();\n      renderer.preDraw();\n      this.setupLayoutBounds(usingClipCount);\n      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this._maskRenderTexture);\n      this.gl.clearColor(1, 1, 1, 1);\n      this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n      for (let clipIndex = 0; clipIndex < this._clippingContextListForMask.length; clipIndex++) {\n        const clipContext = this._clippingContextListForMask[clipIndex];\n        const allClipedDrawRect = clipContext._allClippedDrawRect;\n        const layoutBoundsOnTex01 = clipContext._layoutBounds;\n        const MARGIN = 0.05;\n        this._tmpBoundsOnModel.setRect(allClipedDrawRect);\n        this._tmpBoundsOnModel.expand(allClipedDrawRect.width * MARGIN, allClipedDrawRect.height * MARGIN);\n        const scaleX = layoutBoundsOnTex01.width / this._tmpBoundsOnModel.width;\n        const scaleY = layoutBoundsOnTex01.height / this._tmpBoundsOnModel.height;\n        {\n          this._tmpMatrix.loadIdentity();\n          {\n            this._tmpMatrix.translateRelative(-1, -1);\n            this._tmpMatrix.scaleRelative(2, 2);\n          }\n          {\n            this._tmpMatrix.translateRelative(layoutBoundsOnTex01.x, layoutBoundsOnTex01.y);\n            this._tmpMatrix.scaleRelative(scaleX, scaleY);\n            this._tmpMatrix.translateRelative(-this._tmpBoundsOnModel.x, -this._tmpBoundsOnModel.y);\n          }\n          this._tmpMatrixForMask.setMatrix(this._tmpMatrix.getArray());\n        }\n        {\n          this._tmpMatrix.loadIdentity();\n          {\n            this._tmpMatrix.translateRelative(layoutBoundsOnTex01.x, layoutBoundsOnTex01.y);\n            this._tmpMatrix.scaleRelative(scaleX, scaleY);\n            this._tmpMatrix.translateRelative(-this._tmpBoundsOnModel.x, -this._tmpBoundsOnModel.y);\n          }\n          this._tmpMatrixForDraw.setMatrix(this._tmpMatrix.getArray());\n        }\n        clipContext._matrixForMask.setMatrix(this._tmpMatrixForMask.getArray());\n        clipContext._matrixForDraw.setMatrix(this._tmpMatrixForDraw.getArray());\n        const clipDrawCount = clipContext._clippingIdCount;\n        for (let i = 0; i < clipDrawCount; i++) {\n          const clipDrawIndex = clipContext._clippingIdList[i];\n          if (!model.getDrawableDynamicFlagVertexPositionsDidChange(clipDrawIndex)) {\n            continue;\n          }\n          renderer.setIsCulling(model.getDrawableCulling(clipDrawIndex) != false);\n          renderer.setClippingContextBufferForMask(clipContext);\n          renderer.drawMesh(model.getDrawableTextureIndices(clipDrawIndex), model.getDrawableVertexIndexCount(clipDrawIndex), model.getDrawableVertexCount(clipDrawIndex), model.getDrawableVertexIndices(clipDrawIndex), model.getDrawableVertices(clipDrawIndex), model.getDrawableVertexUvs(clipDrawIndex), model.getDrawableOpacity(clipDrawIndex), CubismBlendMode.CubismBlendMode_Normal, false);\n        }\n      }\n      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, s_fbo);\n      renderer.setClippingContextBufferForMask(null);\n      this.gl.viewport(s_viewport[0], s_viewport[1], s_viewport[2], s_viewport[3]);\n    }\n  }\n  findSameClip(drawableMasks, drawableMaskCounts) {\n    for (let i = 0; i < this._clippingContextListForMask.length; i++) {\n      const clippingContext = this._clippingContextListForMask[i];\n      const count = clippingContext._clippingIdCount;\n      if (count != drawableMaskCounts) {\n        continue;\n      }\n      let sameCount = 0;\n      for (let j = 0; j < count; j++) {\n        const clipId = clippingContext._clippingIdList[j];\n        for (let k = 0; k < count; k++) {\n          if (drawableMasks[k] == clipId) {\n            sameCount++;\n            break;\n          }\n        }\n      }\n      if (sameCount == count) {\n        return clippingContext;\n      }\n    }\n    return null;\n  }\n  setupLayoutBounds(usingClipCount) {\n    let div = usingClipCount / ColorChannelCount;\n    let mod = usingClipCount % ColorChannelCount;\n    div = ~~div;\n    mod = ~~mod;\n    let curClipIndex = 0;\n    for (let channelNo = 0; channelNo < ColorChannelCount; channelNo++) {\n      const layoutCount = div + (channelNo < mod ? 1 : 0);\n      if (layoutCount == 0)\n        ;\n      else if (layoutCount == 1) {\n        const clipContext = this._clippingContextListForMask[curClipIndex++];\n        clipContext._layoutChannelNo = channelNo;\n        clipContext._layoutBounds.x = 0;\n        clipContext._layoutBounds.y = 0;\n        clipContext._layoutBounds.width = 1;\n        clipContext._layoutBounds.height = 1;\n      } else if (layoutCount == 2) {\n        for (let i = 0; i < layoutCount; i++) {\n          let xpos = i % 2;\n          xpos = ~~xpos;\n          const cc = this._clippingContextListForMask[curClipIndex++];\n          cc._layoutChannelNo = channelNo;\n          cc._layoutBounds.x = xpos * 0.5;\n          cc._layoutBounds.y = 0;\n          cc._layoutBounds.width = 0.5;\n          cc._layoutBounds.height = 1;\n        }\n      } else if (layoutCount <= 4) {\n        for (let i = 0; i < layoutCount; i++) {\n          let xpos = i % 2;\n          let ypos = i / 2;\n          xpos = ~~xpos;\n          ypos = ~~ypos;\n          const cc = this._clippingContextListForMask[curClipIndex++];\n          cc._layoutChannelNo = channelNo;\n          cc._layoutBounds.x = xpos * 0.5;\n          cc._layoutBounds.y = ypos * 0.5;\n          cc._layoutBounds.width = 0.5;\n          cc._layoutBounds.height = 0.5;\n        }\n      } else if (layoutCount <= 9) {\n        for (let i = 0; i < layoutCount; i++) {\n          let xpos = i % 3;\n          let ypos = i / 3;\n          xpos = ~~xpos;\n          ypos = ~~ypos;\n          const cc = this._clippingContextListForMask[curClipIndex++];\n          cc._layoutChannelNo = channelNo;\n          cc._layoutBounds.x = xpos / 3;\n          cc._layoutBounds.y = ypos / 3;\n          cc._layoutBounds.width = 1 / 3;\n          cc._layoutBounds.height = 1 / 3;\n        }\n      } else if (CubismConfig.supportMoreMaskDivisions && layoutCount <= 16) {\n        for (let i = 0; i < layoutCount; i++) {\n          let xpos = i % 4;\n          let ypos = i / 4;\n          xpos = ~~xpos;\n          ypos = ~~ypos;\n          const cc = this._clippingContextListForMask[curClipIndex++];\n          cc._layoutChannelNo = channelNo;\n          cc._layoutBounds.x = xpos / 4;\n          cc._layoutBounds.y = ypos / 4;\n          cc._layoutBounds.width = 1 / 4;\n          cc._layoutBounds.height = 1 / 4;\n        }\n      } else {\n        CubismLogError(\"not supported mask count : {0}\", layoutCount);\n      }\n    }\n  }\n  getColorBuffer() {\n    return this._colorBuffer;\n  }\n  getClippingContextListForDraw() {\n    return this._clippingContextListForDraw;\n  }\n  setClippingMaskBufferSize(size) {\n    this._clippingMaskBufferSize = size;\n  }\n  getClippingMaskBufferSize() {\n    return this._clippingMaskBufferSize;\n  }\n}\nclass CubismRenderTextureResource {\n  constructor(frameNo, texture) {\n    this.frameNo = frameNo;\n    this.texture = texture;\n  }\n}\nclass CubismClippingContext {\n  constructor(manager, clippingDrawableIndices, clipCount) {\n    this._isUsing = false;\n    this._owner = manager;\n    this._clippingIdList = clippingDrawableIndices;\n    this._clippingIdCount = clipCount;\n    this._allClippedDrawRect = new csmRect();\n    this._layoutBounds = new csmRect();\n    this._clippedDrawableIndexList = [];\n    this._matrixForMask = new CubismMatrix44();\n    this._matrixForDraw = new CubismMatrix44();\n  }\n  release() {\n    const self = this;\n    self._layoutBounds = void 0;\n    self._allClippedDrawRect = void 0;\n    self._clippedDrawableIndexList = void 0;\n  }\n  addClippedDrawable(drawableIndex) {\n    this._clippedDrawableIndexList.push(drawableIndex);\n  }\n  getClippingManager() {\n    return this._owner;\n  }\n  setGl(gl) {\n    this._owner.setGL(gl);\n  }\n}\nclass CubismShader_WebGL {\n  static getInstance() {\n    if (s_instance == null) {\n      s_instance = new CubismShader_WebGL();\n      return s_instance;\n    }\n    return s_instance;\n  }\n  static deleteInstance() {\n    if (s_instance) {\n      s_instance.release();\n      s_instance = void 0;\n    }\n  }\n  constructor() {\n    this._shaderSets = [];\n  }\n  release() {\n    this.releaseShaderProgram();\n  }\n  setupShaderProgram(renderer, textureId, vertexCount, vertexArray, indexArray, uvArray, bufferData, opacity, colorBlendMode, baseColor, isPremultipliedAlpha, matrix4x4, invertedMask) {\n    if (!isPremultipliedAlpha) {\n      CubismLogError(\"NoPremultipliedAlpha is not allowed\");\n    }\n    if (this._shaderSets.length == 0) {\n      this.generateShaders();\n    }\n    let SRC_COLOR;\n    let DST_COLOR;\n    let SRC_ALPHA;\n    let DST_ALPHA;\n    const clippingContextBufferForMask = renderer.getClippingContextBufferForMask();\n    if (clippingContextBufferForMask != null) {\n      const shaderSet = this._shaderSets[ShaderNames.ShaderNames_SetupMask];\n      this.gl.useProgram(shaderSet.shaderProgram);\n      this.gl.activeTexture(this.gl.TEXTURE0);\n      this.gl.bindTexture(this.gl.TEXTURE_2D, textureId);\n      this.gl.uniform1i(shaderSet.samplerTexture0Location, 0);\n      if (bufferData.vertex == null) {\n        bufferData.vertex = this.gl.createBuffer();\n      }\n      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, bufferData.vertex);\n      this.gl.bufferData(this.gl.ARRAY_BUFFER, vertexArray, this.gl.DYNAMIC_DRAW);\n      this.gl.enableVertexAttribArray(shaderSet.attributePositionLocation);\n      this.gl.vertexAttribPointer(shaderSet.attributePositionLocation, 2, this.gl.FLOAT, false, 0, 0);\n      if (bufferData.uv == null) {\n        bufferData.uv = this.gl.createBuffer();\n      }\n      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, bufferData.uv);\n      this.gl.bufferData(this.gl.ARRAY_BUFFER, uvArray, this.gl.DYNAMIC_DRAW);\n      this.gl.enableVertexAttribArray(shaderSet.attributeTexCoordLocation);\n      this.gl.vertexAttribPointer(shaderSet.attributeTexCoordLocation, 2, this.gl.FLOAT, false, 0, 0);\n      const channelNo = clippingContextBufferForMask._layoutChannelNo;\n      const colorChannel = clippingContextBufferForMask.getClippingManager().getChannelFlagAsColor(channelNo);\n      this.gl.uniform4f(shaderSet.uniformChannelFlagLocation, colorChannel.R, colorChannel.G, colorChannel.B, colorChannel.A);\n      this.gl.uniformMatrix4fv(shaderSet.uniformClipMatrixLocation, false, clippingContextBufferForMask._matrixForMask.getArray());\n      const rect = clippingContextBufferForMask._layoutBounds;\n      this.gl.uniform4f(shaderSet.uniformBaseColorLocation, rect.x * 2 - 1, rect.y * 2 - 1, rect.getRight() * 2 - 1, rect.getBottom() * 2 - 1);\n      SRC_COLOR = this.gl.ZERO;\n      DST_COLOR = this.gl.ONE_MINUS_SRC_COLOR;\n      SRC_ALPHA = this.gl.ZERO;\n      DST_ALPHA = this.gl.ONE_MINUS_SRC_ALPHA;\n    } else {\n      const clippingContextBufferForDraw = renderer.getClippingContextBufferForDraw();\n      const masked = clippingContextBufferForDraw != null;\n      const offset = masked ? invertedMask ? 2 : 1 : 0;\n      let shaderSet;\n      switch (colorBlendMode) {\n        case CubismBlendMode.CubismBlendMode_Normal:\n        default:\n          shaderSet = this._shaderSets[ShaderNames.ShaderNames_NormalPremultipliedAlpha + offset];\n          SRC_COLOR = this.gl.ONE;\n          DST_COLOR = this.gl.ONE_MINUS_SRC_ALPHA;\n          SRC_ALPHA = this.gl.ONE;\n          DST_ALPHA = this.gl.ONE_MINUS_SRC_ALPHA;\n          break;\n        case CubismBlendMode.CubismBlendMode_Additive:\n          shaderSet = this._shaderSets[ShaderNames.ShaderNames_AddPremultipliedAlpha + offset];\n          SRC_COLOR = this.gl.ONE;\n          DST_COLOR = this.gl.ONE;\n          SRC_ALPHA = this.gl.ZERO;\n          DST_ALPHA = this.gl.ONE;\n          break;\n        case CubismBlendMode.CubismBlendMode_Multiplicative:\n          shaderSet = this._shaderSets[ShaderNames.ShaderNames_MultPremultipliedAlpha + offset];\n          SRC_COLOR = this.gl.DST_COLOR;\n          DST_COLOR = this.gl.ONE_MINUS_SRC_ALPHA;\n          SRC_ALPHA = this.gl.ZERO;\n          DST_ALPHA = this.gl.ONE;\n          break;\n      }\n      this.gl.useProgram(shaderSet.shaderProgram);\n      if (bufferData.vertex == null) {\n        bufferData.vertex = this.gl.createBuffer();\n      }\n      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, bufferData.vertex);\n      this.gl.bufferData(this.gl.ARRAY_BUFFER, vertexArray, this.gl.DYNAMIC_DRAW);\n      this.gl.enableVertexAttribArray(shaderSet.attributePositionLocation);\n      this.gl.vertexAttribPointer(shaderSet.attributePositionLocation, 2, this.gl.FLOAT, false, 0, 0);\n      if (bufferData.uv == null) {\n        bufferData.uv = this.gl.createBuffer();\n      }\n      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, bufferData.uv);\n      this.gl.bufferData(this.gl.ARRAY_BUFFER, uvArray, this.gl.DYNAMIC_DRAW);\n      this.gl.enableVertexAttribArray(shaderSet.attributeTexCoordLocation);\n      this.gl.vertexAttribPointer(shaderSet.attributeTexCoordLocation, 2, this.gl.FLOAT, false, 0, 0);\n      if (clippingContextBufferForDraw != null) {\n        this.gl.activeTexture(this.gl.TEXTURE1);\n        const tex = clippingContextBufferForDraw.getClippingManager().getColorBuffer();\n        this.gl.bindTexture(this.gl.TEXTURE_2D, tex);\n        this.gl.uniform1i(shaderSet.samplerTexture1Location, 1);\n        this.gl.uniformMatrix4fv(shaderSet.uniformClipMatrixLocation, false, clippingContextBufferForDraw._matrixForDraw.getArray());\n        const channelNo = clippingContextBufferForDraw._layoutChannelNo;\n        const colorChannel = clippingContextBufferForDraw.getClippingManager().getChannelFlagAsColor(channelNo);\n        this.gl.uniform4f(shaderSet.uniformChannelFlagLocation, colorChannel.R, colorChannel.G, colorChannel.B, colorChannel.A);\n      }\n      this.gl.activeTexture(this.gl.TEXTURE0);\n      this.gl.bindTexture(this.gl.TEXTURE_2D, textureId);\n      this.gl.uniform1i(shaderSet.samplerTexture0Location, 0);\n      this.gl.uniformMatrix4fv(shaderSet.uniformMatrixLocation, false, matrix4x4.getArray());\n      this.gl.uniform4f(shaderSet.uniformBaseColorLocation, baseColor.R, baseColor.G, baseColor.B, baseColor.A);\n    }\n    if (bufferData.index == null) {\n      bufferData.index = this.gl.createBuffer();\n    }\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, bufferData.index);\n    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, indexArray, this.gl.DYNAMIC_DRAW);\n    this.gl.blendFuncSeparate(SRC_COLOR, DST_COLOR, SRC_ALPHA, DST_ALPHA);\n  }\n  releaseShaderProgram() {\n    for (let i = 0; i < this._shaderSets.length; i++) {\n      this.gl.deleteProgram(this._shaderSets[i].shaderProgram);\n      this._shaderSets[i].shaderProgram = 0;\n    }\n    this._shaderSets = [];\n  }\n  generateShaders() {\n    for (let i = 0; i < shaderCount; i++) {\n      this._shaderSets.push({});\n    }\n    this._shaderSets[0].shaderProgram = this.loadShaderProgram(vertexShaderSrcSetupMask, fragmentShaderSrcsetupMask);\n    this._shaderSets[1].shaderProgram = this.loadShaderProgram(vertexShaderSrc, fragmentShaderSrcPremultipliedAlpha);\n    this._shaderSets[2].shaderProgram = this.loadShaderProgram(vertexShaderSrcMasked, fragmentShaderSrcMaskPremultipliedAlpha);\n    this._shaderSets[3].shaderProgram = this.loadShaderProgram(vertexShaderSrcMasked, fragmentShaderSrcMaskInvertedPremultipliedAlpha);\n    this._shaderSets[4].shaderProgram = this._shaderSets[1].shaderProgram;\n    this._shaderSets[5].shaderProgram = this._shaderSets[2].shaderProgram;\n    this._shaderSets[6].shaderProgram = this._shaderSets[3].shaderProgram;\n    this._shaderSets[7].shaderProgram = this._shaderSets[1].shaderProgram;\n    this._shaderSets[8].shaderProgram = this._shaderSets[2].shaderProgram;\n    this._shaderSets[9].shaderProgram = this._shaderSets[3].shaderProgram;\n    this._shaderSets[0].attributePositionLocation = this.gl.getAttribLocation(this._shaderSets[0].shaderProgram, \"a_position\");\n    this._shaderSets[0].attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets[0].shaderProgram, \"a_texCoord\");\n    this._shaderSets[0].samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets[0].shaderProgram, \"s_texture0\");\n    this._shaderSets[0].uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets[0].shaderProgram, \"u_clipMatrix\");\n    this._shaderSets[0].uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets[0].shaderProgram, \"u_channelFlag\");\n    this._shaderSets[0].uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets[0].shaderProgram, \"u_baseColor\");\n    this._shaderSets[1].attributePositionLocation = this.gl.getAttribLocation(this._shaderSets[1].shaderProgram, \"a_position\");\n    this._shaderSets[1].attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets[1].shaderProgram, \"a_texCoord\");\n    this._shaderSets[1].samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets[1].shaderProgram, \"s_texture0\");\n    this._shaderSets[1].uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets[1].shaderProgram, \"u_matrix\");\n    this._shaderSets[1].uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets[1].shaderProgram, \"u_baseColor\");\n    this._shaderSets[2].attributePositionLocation = this.gl.getAttribLocation(this._shaderSets[2].shaderProgram, \"a_position\");\n    this._shaderSets[2].attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets[2].shaderProgram, \"a_texCoord\");\n    this._shaderSets[2].samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets[2].shaderProgram, \"s_texture0\");\n    this._shaderSets[2].samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets[2].shaderProgram, \"s_texture1\");\n    this._shaderSets[2].uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets[2].shaderProgram, \"u_matrix\");\n    this._shaderSets[2].uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets[2].shaderProgram, \"u_clipMatrix\");\n    this._shaderSets[2].uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets[2].shaderProgram, \"u_channelFlag\");\n    this._shaderSets[2].uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets[2].shaderProgram, \"u_baseColor\");\n    this._shaderSets[3].attributePositionLocation = this.gl.getAttribLocation(this._shaderSets[3].shaderProgram, \"a_position\");\n    this._shaderSets[3].attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets[3].shaderProgram, \"a_texCoord\");\n    this._shaderSets[3].samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets[3].shaderProgram, \"s_texture0\");\n    this._shaderSets[3].samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets[3].shaderProgram, \"s_texture1\");\n    this._shaderSets[3].uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets[3].shaderProgram, \"u_matrix\");\n    this._shaderSets[3].uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets[3].shaderProgram, \"u_clipMatrix\");\n    this._shaderSets[3].uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets[3].shaderProgram, \"u_channelFlag\");\n    this._shaderSets[3].uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets[3].shaderProgram, \"u_baseColor\");\n    this._shaderSets[4].attributePositionLocation = this.gl.getAttribLocation(this._shaderSets[4].shaderProgram, \"a_position\");\n    this._shaderSets[4].attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets[4].shaderProgram, \"a_texCoord\");\n    this._shaderSets[4].samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets[4].shaderProgram, \"s_texture0\");\n    this._shaderSets[4].uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets[4].shaderProgram, \"u_matrix\");\n    this._shaderSets[4].uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets[4].shaderProgram, \"u_baseColor\");\n    this._shaderSets[5].attributePositionLocation = this.gl.getAttribLocation(this._shaderSets[5].shaderProgram, \"a_position\");\n    this._shaderSets[5].attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets[5].shaderProgram, \"a_texCoord\");\n    this._shaderSets[5].samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets[5].shaderProgram, \"s_texture0\");\n    this._shaderSets[5].samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets[5].shaderProgram, \"s_texture1\");\n    this._shaderSets[5].uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets[5].shaderProgram, \"u_matrix\");\n    this._shaderSets[5].uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets[5].shaderProgram, \"u_clipMatrix\");\n    this._shaderSets[5].uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets[5].shaderProgram, \"u_channelFlag\");\n    this._shaderSets[5].uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets[5].shaderProgram, \"u_baseColor\");\n    this._shaderSets[6].attributePositionLocation = this.gl.getAttribLocation(this._shaderSets[6].shaderProgram, \"a_position\");\n    this._shaderSets[6].attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets[6].shaderProgram, \"a_texCoord\");\n    this._shaderSets[6].samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets[6].shaderProgram, \"s_texture0\");\n    this._shaderSets[6].samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets[6].shaderProgram, \"s_texture1\");\n    this._shaderSets[6].uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets[6].shaderProgram, \"u_matrix\");\n    this._shaderSets[6].uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets[6].shaderProgram, \"u_clipMatrix\");\n    this._shaderSets[6].uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets[6].shaderProgram, \"u_channelFlag\");\n    this._shaderSets[6].uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets[6].shaderProgram, \"u_baseColor\");\n    this._shaderSets[7].attributePositionLocation = this.gl.getAttribLocation(this._shaderSets[7].shaderProgram, \"a_position\");\n    this._shaderSets[7].attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets[7].shaderProgram, \"a_texCoord\");\n    this._shaderSets[7].samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets[7].shaderProgram, \"s_texture0\");\n    this._shaderSets[7].uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets[7].shaderProgram, \"u_matrix\");\n    this._shaderSets[7].uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets[7].shaderProgram, \"u_baseColor\");\n    this._shaderSets[8].attributePositionLocation = this.gl.getAttribLocation(this._shaderSets[8].shaderProgram, \"a_position\");\n    this._shaderSets[8].attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets[8].shaderProgram, \"a_texCoord\");\n    this._shaderSets[8].samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets[8].shaderProgram, \"s_texture0\");\n    this._shaderSets[8].samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets[8].shaderProgram, \"s_texture1\");\n    this._shaderSets[8].uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets[8].shaderProgram, \"u_matrix\");\n    this._shaderSets[8].uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets[8].shaderProgram, \"u_clipMatrix\");\n    this._shaderSets[8].uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets[8].shaderProgram, \"u_channelFlag\");\n    this._shaderSets[8].uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets[8].shaderProgram, \"u_baseColor\");\n    this._shaderSets[9].attributePositionLocation = this.gl.getAttribLocation(this._shaderSets[9].shaderProgram, \"a_position\");\n    this._shaderSets[9].attributeTexCoordLocation = this.gl.getAttribLocation(this._shaderSets[9].shaderProgram, \"a_texCoord\");\n    this._shaderSets[9].samplerTexture0Location = this.gl.getUniformLocation(this._shaderSets[9].shaderProgram, \"s_texture0\");\n    this._shaderSets[9].samplerTexture1Location = this.gl.getUniformLocation(this._shaderSets[9].shaderProgram, \"s_texture1\");\n    this._shaderSets[9].uniformMatrixLocation = this.gl.getUniformLocation(this._shaderSets[9].shaderProgram, \"u_matrix\");\n    this._shaderSets[9].uniformClipMatrixLocation = this.gl.getUniformLocation(this._shaderSets[9].shaderProgram, \"u_clipMatrix\");\n    this._shaderSets[9].uniformChannelFlagLocation = this.gl.getUniformLocation(this._shaderSets[9].shaderProgram, \"u_channelFlag\");\n    this._shaderSets[9].uniformBaseColorLocation = this.gl.getUniformLocation(this._shaderSets[9].shaderProgram, \"u_baseColor\");\n  }\n  loadShaderProgram(vertexShaderSource, fragmentShaderSource) {\n    let shaderProgram = this.gl.createProgram();\n    let vertShader = this.compileShaderSource(this.gl.VERTEX_SHADER, vertexShaderSource);\n    if (!vertShader) {\n      CubismLogError(\"Vertex shader compile error!\");\n      return 0;\n    }\n    let fragShader = this.compileShaderSource(this.gl.FRAGMENT_SHADER, fragmentShaderSource);\n    if (!fragShader) {\n      CubismLogError(\"Vertex shader compile error!\");\n      return 0;\n    }\n    this.gl.attachShader(shaderProgram, vertShader);\n    this.gl.attachShader(shaderProgram, fragShader);\n    this.gl.linkProgram(shaderProgram);\n    const linkStatus = this.gl.getProgramParameter(shaderProgram, this.gl.LINK_STATUS);\n    if (!linkStatus) {\n      CubismLogError(\"Failed to link program: {0}\", shaderProgram);\n      this.gl.deleteShader(vertShader);\n      this.gl.deleteShader(fragShader);\n      if (shaderProgram) {\n        this.gl.deleteProgram(shaderProgram);\n      }\n      return 0;\n    }\n    this.gl.deleteShader(vertShader);\n    this.gl.deleteShader(fragShader);\n    return shaderProgram;\n  }\n  compileShaderSource(shaderType, shaderSource) {\n    const source = shaderSource;\n    const shader = this.gl.createShader(shaderType);\n    this.gl.shaderSource(shader, source);\n    this.gl.compileShader(shader);\n    if (!shader) {\n      const log = this.gl.getShaderInfoLog(shader);\n      CubismLogError(\"Shader compile log: {0} \", log);\n    }\n    const status = this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS);\n    if (!status) {\n      this.gl.deleteShader(shader);\n      return null;\n    }\n    return shader;\n  }\n  setGl(gl) {\n    this.gl = gl;\n  }\n}\nvar ShaderNames = /* @__PURE__ */ ((ShaderNames2) => {\n  ShaderNames2[ShaderNames2[\"ShaderNames_SetupMask\"] = 0] = \"ShaderNames_SetupMask\";\n  ShaderNames2[ShaderNames2[\"ShaderNames_NormalPremultipliedAlpha\"] = 1] = \"ShaderNames_NormalPremultipliedAlpha\";\n  ShaderNames2[ShaderNames2[\"ShaderNames_NormalMaskedPremultipliedAlpha\"] = 2] = \"ShaderNames_NormalMaskedPremultipliedAlpha\";\n  ShaderNames2[ShaderNames2[\"ShaderNames_NomralMaskedInvertedPremultipliedAlpha\"] = 3] = \"ShaderNames_NomralMaskedInvertedPremultipliedAlpha\";\n  ShaderNames2[ShaderNames2[\"ShaderNames_AddPremultipliedAlpha\"] = 4] = \"ShaderNames_AddPremultipliedAlpha\";\n  ShaderNames2[ShaderNames2[\"ShaderNames_AddMaskedPremultipliedAlpha\"] = 5] = \"ShaderNames_AddMaskedPremultipliedAlpha\";\n  ShaderNames2[ShaderNames2[\"ShaderNames_AddMaskedPremultipliedAlphaInverted\"] = 6] = \"ShaderNames_AddMaskedPremultipliedAlphaInverted\";\n  ShaderNames2[ShaderNames2[\"ShaderNames_MultPremultipliedAlpha\"] = 7] = \"ShaderNames_MultPremultipliedAlpha\";\n  ShaderNames2[ShaderNames2[\"ShaderNames_MultMaskedPremultipliedAlpha\"] = 8] = \"ShaderNames_MultMaskedPremultipliedAlpha\";\n  ShaderNames2[ShaderNames2[\"ShaderNames_MultMaskedPremultipliedAlphaInverted\"] = 9] = \"ShaderNames_MultMaskedPremultipliedAlphaInverted\";\n  return ShaderNames2;\n})(ShaderNames || {});\nconst vertexShaderSrcSetupMask = \"attribute vec4     a_position;attribute vec2     a_texCoord;varying vec2       v_texCoord;varying vec4       v_myPos;uniform mat4       u_clipMatrix;void main(){   gl_Position = u_clipMatrix * a_position;   v_myPos = u_clipMatrix * a_position;   v_texCoord = a_texCoord;   v_texCoord.y = 1.0 - v_texCoord.y;}\";\nconst fragmentShaderSrcsetupMask = \"precision mediump float;varying vec2       v_texCoord;varying vec4       v_myPos;uniform vec4       u_baseColor;uniform vec4       u_channelFlag;uniform sampler2D  s_texture0;void main(){   float isInside =        step(u_baseColor.x, v_myPos.x/v_myPos.w)       * step(u_baseColor.y, v_myPos.y/v_myPos.w)       * step(v_myPos.x/v_myPos.w, u_baseColor.z)       * step(v_myPos.y/v_myPos.w, u_baseColor.w);   gl_FragColor = u_channelFlag * texture2D(s_texture0, v_texCoord).a * isInside;}\";\nconst vertexShaderSrc = \"attribute vec4     a_position;attribute vec2     a_texCoord;varying vec2       v_texCoord;uniform mat4       u_matrix;void main(){   gl_Position = u_matrix * a_position;   v_texCoord = a_texCoord;   v_texCoord.y = 1.0 - v_texCoord.y;}\";\nconst vertexShaderSrcMasked = \"attribute vec4     a_position;attribute vec2     a_texCoord;varying vec2       v_texCoord;varying vec4       v_clipPos;uniform mat4       u_matrix;uniform mat4       u_clipMatrix;void main(){   gl_Position = u_matrix * a_position;   v_clipPos = u_clipMatrix * a_position;   v_texCoord = a_texCoord;   v_texCoord.y = 1.0 - v_texCoord.y;}\";\nconst fragmentShaderSrcPremultipliedAlpha = \"precision mediump float;varying vec2       v_texCoord;uniform vec4       u_baseColor;uniform sampler2D  s_texture0;void main(){   gl_FragColor = texture2D(s_texture0 , v_texCoord) * u_baseColor;}\";\nconst fragmentShaderSrcMaskPremultipliedAlpha = \"precision mediump float;varying vec2       v_texCoord;varying vec4       v_clipPos;uniform vec4       u_baseColor;uniform vec4       u_channelFlag;uniform sampler2D  s_texture0;uniform sampler2D  s_texture1;void main(){   vec4 col_formask = texture2D(s_texture0 , v_texCoord) * u_baseColor;   vec4 clipMask = (1.0 - texture2D(s_texture1, v_clipPos.xy / v_clipPos.w)) * u_channelFlag;   float maskVal = clipMask.r + clipMask.g + clipMask.b + clipMask.a;   col_formask = col_formask * maskVal;   gl_FragColor = col_formask;}\";\nconst fragmentShaderSrcMaskInvertedPremultipliedAlpha = \"precision mediump float;varying vec2 v_texCoord;varying vec4 v_clipPos;uniform sampler2D s_texture0;uniform sampler2D s_texture1;uniform vec4 u_channelFlag;uniform vec4 u_baseColor;void main(){vec4 col_formask = texture2D(s_texture0, v_texCoord) * u_baseColor;vec4 clipMask = (1.0 - texture2D(s_texture1, v_clipPos.xy / v_clipPos.w)) * u_channelFlag;float maskVal = clipMask.r + clipMask.g + clipMask.b + clipMask.a;col_formask = col_formask * (1.0 - maskVal);gl_FragColor = col_formask;}\";\nclass CubismRenderer_WebGL extends CubismRenderer {\n  constructor() {\n    super();\n    this._clippingContextBufferForMask = null;\n    this._clippingContextBufferForDraw = null;\n    this._clippingManager = new CubismClippingManager_WebGL();\n    this.firstDraw = true;\n    this._textures = {};\n    this._sortedDrawableIndexList = [];\n    this._bufferData = {\n      vertex: null,\n      uv: null,\n      index: null\n    };\n  }\n  initialize(model) {\n    if (model.isUsingMasking()) {\n      this._clippingManager = new CubismClippingManager_WebGL();\n      this._clippingManager.initialize(model, model.getDrawableCount(), model.getDrawableMasks(), model.getDrawableMaskCounts());\n    }\n    for (let i = model.getDrawableCount() - 1; i >= 0; i--) {\n      this._sortedDrawableIndexList[i] = 0;\n    }\n    super.initialize(model);\n  }\n  bindTexture(modelTextureNo, glTexture) {\n    this._textures[modelTextureNo] = glTexture;\n  }\n  getBindedTextures() {\n    return this._textures;\n  }\n  setClippingMaskBufferSize(size) {\n    this._clippingManager.release();\n    this._clippingManager = new CubismClippingManager_WebGL();\n    this._clippingManager.setClippingMaskBufferSize(size);\n    this._clippingManager.initialize(this.getModel(), this.getModel().getDrawableCount(), this.getModel().getDrawableMasks(), this.getModel().getDrawableMaskCounts());\n  }\n  getClippingMaskBufferSize() {\n    return this._clippingManager.getClippingMaskBufferSize();\n  }\n  release() {\n    var _a, _b, _c;\n    const self = this;\n    this._clippingManager.release();\n    self._clippingManager = void 0;\n    (_a = this.gl) == null ? void 0 : _a.deleteBuffer(this._bufferData.vertex);\n    this._bufferData.vertex = null;\n    (_b = this.gl) == null ? void 0 : _b.deleteBuffer(this._bufferData.uv);\n    this._bufferData.uv = null;\n    (_c = this.gl) == null ? void 0 : _c.deleteBuffer(this._bufferData.index);\n    this._bufferData.index = null;\n    self._bufferData = void 0;\n    self._textures = void 0;\n  }\n  doDrawModel() {\n    this.preDraw();\n    if (this._clippingManager != null) {\n      this._clippingManager.setupClippingContext(this.getModel(), this);\n    }\n    const drawableCount = this.getModel().getDrawableCount();\n    const renderOrder = this.getModel().getDrawableRenderOrders();\n    for (let i = 0; i < drawableCount; ++i) {\n      const order = renderOrder[i];\n      this._sortedDrawableIndexList[order] = i;\n    }\n    for (let i = 0; i < drawableCount; ++i) {\n      const drawableIndex = this._sortedDrawableIndexList[i];\n      if (!this.getModel().getDrawableDynamicFlagIsVisible(drawableIndex)) {\n        continue;\n      }\n      this.setClippingContextBufferForDraw(this._clippingManager != null ? this._clippingManager.getClippingContextListForDraw()[drawableIndex] : null);\n      this.setIsCulling(this.getModel().getDrawableCulling(drawableIndex));\n      this.drawMesh(this.getModel().getDrawableTextureIndices(drawableIndex), this.getModel().getDrawableVertexIndexCount(drawableIndex), this.getModel().getDrawableVertexCount(drawableIndex), this.getModel().getDrawableVertexIndices(drawableIndex), this.getModel().getDrawableVertices(drawableIndex), this.getModel().getDrawableVertexUvs(drawableIndex), this.getModel().getDrawableOpacity(drawableIndex), this.getModel().getDrawableBlendMode(drawableIndex), this.getModel().getDrawableInvertedMaskBit(drawableIndex));\n    }\n  }\n  drawMesh(textureNo, indexCount, vertexCount, indexArray, vertexArray, uvArray, opacity, colorBlendMode, invertedMask) {\n    if (this.isCulling()) {\n      this.gl.enable(this.gl.CULL_FACE);\n    } else {\n      this.gl.disable(this.gl.CULL_FACE);\n    }\n    this.gl.frontFace(this.gl.CCW);\n    const modelColorRGBA = this.getModelColor();\n    if (this.getClippingContextBufferForMask() == null) {\n      modelColorRGBA.A *= opacity;\n      if (this.isPremultipliedAlpha()) {\n        modelColorRGBA.R *= modelColorRGBA.A;\n        modelColorRGBA.G *= modelColorRGBA.A;\n        modelColorRGBA.B *= modelColorRGBA.A;\n      }\n    }\n    let drawtexture = null;\n    if (this._textures[textureNo] != null) {\n      drawtexture = this._textures[textureNo];\n    }\n    CubismShader_WebGL.getInstance().setupShaderProgram(this, drawtexture, vertexCount, vertexArray, indexArray, uvArray, this._bufferData, opacity, colorBlendMode, modelColorRGBA, this.isPremultipliedAlpha(), this.getMvpMatrix(), invertedMask);\n    this.gl.drawElements(this.gl.TRIANGLES, indexCount, this.gl.UNSIGNED_SHORT, 0);\n    this.gl.useProgram(null);\n    this.setClippingContextBufferForDraw(null);\n    this.setClippingContextBufferForMask(null);\n  }\n  static doStaticRelease() {\n    CubismShader_WebGL.deleteInstance();\n  }\n  setRenderState(fbo, viewport) {\n    s_fbo = fbo;\n    s_viewport = viewport;\n  }\n  preDraw() {\n    if (this.firstDraw) {\n      this.firstDraw = false;\n      this._anisortopy = this.gl.getExtension(\"EXT_texture_filter_anisotropic\") || this.gl.getExtension(\"WEBKIT_EXT_texture_filter_anisotropic\") || this.gl.getExtension(\"MOZ_EXT_texture_filter_anisotropic\");\n    }\n    this.gl.disable(this.gl.SCISSOR_TEST);\n    this.gl.disable(this.gl.STENCIL_TEST);\n    this.gl.disable(this.gl.DEPTH_TEST);\n    this.gl.frontFace(this.gl.CW);\n    this.gl.enable(this.gl.BLEND);\n    this.gl.colorMask(true, true, true, true);\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n  }\n  setClippingContextBufferForMask(clip) {\n    this._clippingContextBufferForMask = clip;\n  }\n  getClippingContextBufferForMask() {\n    return this._clippingContextBufferForMask;\n  }\n  setClippingContextBufferForDraw(clip) {\n    this._clippingContextBufferForDraw = clip;\n  }\n  getClippingContextBufferForDraw() {\n    return this._clippingContextBufferForDraw;\n  }\n  startUp(gl) {\n    this.gl = gl;\n    this._clippingManager.setGL(gl);\n    CubismShader_WebGL.getInstance().setGl(gl);\n  }\n}\nCubismRenderer.staticRelease = () => {\n  CubismRenderer_WebGL.doStaticRelease();\n};\nclass CubismModelSettingsJson {\n  constructor(json) {\n    this.groups = json.Groups;\n    this.hitAreas = json.HitAreas;\n    this.layout = json.Layout;\n    this.moc = json.FileReferences.Moc;\n    this.expressions = json.FileReferences.Expressions;\n    this.motions = json.FileReferences.Motions;\n    this.textures = json.FileReferences.Textures;\n    this.physics = json.FileReferences.Physics;\n    this.pose = json.FileReferences.Pose;\n  }\n  getEyeBlinkParameters() {\n    var _a, _b;\n    return (_b = (_a = this.groups) == null ? void 0 : _a.find((group) => group.Name === \"EyeBlink\")) == null ? void 0 : _b.Ids;\n  }\n  getLipSyncParameters() {\n    var _a, _b;\n    return (_b = (_a = this.groups) == null ? void 0 : _a.find((group) => group.Name === \"LipSync\")) == null ? void 0 : _b.Ids;\n  }\n}\nconst HitAreaPrefix = \"HitArea\";\nconst HitAreaHead = \"Head\";\nconst HitAreaBody = \"Body\";\nconst PartsIdCore = \"Parts01Core\";\nconst PartsArmPrefix = \"Parts01Arm_\";\nconst PartsArmLPrefix = \"Parts01ArmL_\";\nconst PartsArmRPrefix = \"Parts01ArmR_\";\nconst ParamAngleX = \"ParamAngleX\";\nconst ParamAngleY = \"ParamAngleY\";\nconst ParamAngleZ = \"ParamAngleZ\";\nconst ParamEyeLOpen = \"ParamEyeLOpen\";\nconst ParamEyeLSmile = \"ParamEyeLSmile\";\nconst ParamEyeROpen = \"ParamEyeROpen\";\nconst ParamEyeRSmile = \"ParamEyeRSmile\";\nconst ParamEyeBallX = \"ParamEyeBallX\";\nconst ParamEyeBallY = \"ParamEyeBallY\";\nconst ParamEyeBallForm = \"ParamEyeBallForm\";\nconst ParamBrowLY = \"ParamBrowLY\";\nconst ParamBrowRY = \"ParamBrowRY\";\nconst ParamBrowLX = \"ParamBrowLX\";\nconst ParamBrowRX = \"ParamBrowRX\";\nconst ParamBrowLAngle = \"ParamBrowLAngle\";\nconst ParamBrowRAngle = \"ParamBrowRAngle\";\nconst ParamBrowLForm = \"ParamBrowLForm\";\nconst ParamBrowRForm = \"ParamBrowRForm\";\nconst ParamMouthForm = \"ParamMouthForm\";\nconst ParamMouthOpenY = \"ParamMouthOpenY\";\nconst ParamCheek = \"ParamCheek\";\nconst ParamBodyAngleX = \"ParamBodyAngleX\";\nconst ParamBodyAngleY = \"ParamBodyAngleY\";\nconst ParamBodyAngleZ = \"ParamBodyAngleZ\";\nconst ParamBreath = \"ParamBreath\";\nconst ParamArmLA = \"ParamArmLA\";\nconst ParamArmRA = \"ParamArmRA\";\nconst ParamArmLB = \"ParamArmLB\";\nconst ParamArmRB = \"ParamArmRB\";\nconst ParamHandL = \"ParamHandL\";\nconst ParamHandR = \"ParamHandR\";\nconst ParamHairFront = \"ParamHairFront\";\nconst ParamHairSide = \"ParamHairSide\";\nconst ParamHairBack = \"ParamHairBack\";\nconst ParamHairFluffy = \"ParamHairFluffy\";\nconst ParamShoulderY = \"ParamShoulderY\";\nconst ParamBustX = \"ParamBustX\";\nconst ParamBustY = \"ParamBustY\";\nconst ParamBaseX = \"ParamBaseX\";\nconst ParamBaseY = \"ParamBaseY\";\nconst ParamNONE = \"NONE:\";\nconst LOGICAL_WIDTH = 2;\nconst LOGICAL_HEIGHT = 2;\nvar config;\n((config2) => {\n  config2.LOG_LEVEL_VERBOSE = 0;\n  config2.LOG_LEVEL_WARNING = 1;\n  config2.LOG_LEVEL_ERROR = 2;\n  config2.LOG_LEVEL_NONE = 999;\n  config2.logLevel = config2.LOG_LEVEL_WARNING;\n  config2.sound = true;\n  config2.motionSync = true;\n  config2.motionFadingDuration = 500;\n  config2.idleMotionFadingDuration = 2e3;\n  config2.expressionFadingDuration = 500;\n  config2.preserveExpressionOnMotion = true;\n  config2.cubism4 = CubismConfig;\n})(config || (config = {}));\nconst VERSION = \"0.4.0\";\nconst logger = {\n  log(tag, ...messages) {\n    if (config.logLevel <= config.LOG_LEVEL_VERBOSE) {\n      console.log(`[${tag}]`, ...messages);\n    }\n  },\n  warn(tag, ...messages) {\n    if (config.logLevel <= config.LOG_LEVEL_WARNING) {\n      console.warn(`[${tag}]`, ...messages);\n    }\n  },\n  error(tag, ...messages) {\n    if (config.logLevel <= config.LOG_LEVEL_ERROR) {\n      console.error(`[${tag}]`, ...messages);\n    }\n  }\n};\nfunction clamp(num, lower, upper) {\n  return num < lower ? lower : num > upper ? upper : num;\n}\nfunction rand(min, max) {\n  return Math.random() * (max - min) + min;\n}\nfunction copyProperty(type, from, to, fromKey, toKey) {\n  const value = from[fromKey];\n  if (value !== null && typeof value === type) {\n    to[toKey] = value;\n  }\n}\nfunction copyArray(type, from, to, fromKey, toKey) {\n  const array = from[fromKey];\n  if (Array.isArray(array)) {\n    to[toKey] = array.filter((item) => item !== null && typeof item === type);\n  }\n}\nfunction applyMixins(derivedCtor, baseCtors) {\n  baseCtors.forEach((baseCtor) => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {\n      if (name !== \"constructor\") {\n        Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name));\n      }\n    });\n  });\n}\nfunction folderName(url2) {\n  let lastSlashIndex = url2.lastIndexOf(\"/\");\n  if (lastSlashIndex != -1) {\n    url2 = url2.slice(0, lastSlashIndex);\n  }\n  lastSlashIndex = url2.lastIndexOf(\"/\");\n  if (lastSlashIndex !== -1) {\n    url2 = url2.slice(lastSlashIndex + 1);\n  }\n  return url2;\n}\nfunction remove(array, item) {\n  const index = array.indexOf(item);\n  if (index !== -1) {\n    array.splice(index, 1);\n  }\n}\nclass ExpressionManager extends _pixi_utils__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  constructor(settings, options) {\n    super();\n    this.expressions = [];\n    this.reserveExpressionIndex = -1;\n    this.destroyed = false;\n    this.settings = settings;\n    this.tag = `ExpressionManager(${settings.name})`;\n  }\n  init() {\n    this.defaultExpression = this.createExpression({}, void 0);\n    this.currentExpression = this.defaultExpression;\n    this.stopAllExpressions();\n  }\n  loadExpression(index) {\n    return __async(this, null, function* () {\n      if (!this.definitions[index]) {\n        logger.warn(this.tag, `Undefined expression at [${index}]`);\n        return void 0;\n      }\n      if (this.expressions[index] === null) {\n        logger.warn(this.tag, `Cannot set expression at [${index}] because it's already failed in loading.`);\n        return void 0;\n      }\n      if (this.expressions[index]) {\n        return this.expressions[index];\n      }\n      const expression = yield this._loadExpression(index);\n      this.expressions[index] = expression;\n      return expression;\n    });\n  }\n  _loadExpression(index) {\n    throw new Error(\"Not implemented.\");\n  }\n  setRandomExpression() {\n    return __async(this, null, function* () {\n      if (this.definitions.length) {\n        const availableIndices = [];\n        for (let i = 0; i < this.definitions.length; i++) {\n          if (this.expressions[i] !== null && this.expressions[i] !== this.currentExpression && i !== this.reserveExpressionIndex) {\n            availableIndices.push(i);\n          }\n        }\n        if (availableIndices.length) {\n          const index = Math.floor(Math.random() * availableIndices.length);\n          return this.setExpression(index);\n        }\n      }\n      return false;\n    });\n  }\n  resetExpression() {\n    this._setExpression(this.defaultExpression);\n  }\n  restoreExpression() {\n    this._setExpression(this.currentExpression);\n  }\n  setExpression(index) {\n    return __async(this, null, function* () {\n      if (typeof index !== \"number\") {\n        index = this.getExpressionIndex(index);\n      }\n      if (!(index > -1 && index < this.definitions.length)) {\n        return false;\n      }\n      if (index === this.expressions.indexOf(this.currentExpression)) {\n        return false;\n      }\n      this.reserveExpressionIndex = index;\n      const expression = yield this.loadExpression(index);\n      if (!expression || this.reserveExpressionIndex !== index) {\n        return false;\n      }\n      this.reserveExpressionIndex = -1;\n      this.currentExpression = expression;\n      this._setExpression(expression);\n      return true;\n    });\n  }\n  update(model, now) {\n    if (!this.isFinished()) {\n      return this.updateParameters(model, now);\n    }\n    return false;\n  }\n  destroy() {\n    this.destroyed = true;\n    this.emit(\"destroy\");\n    const self = this;\n    self.definitions = void 0;\n    self.expressions = void 0;\n  }\n}\nconst EPSILON = 0.01;\nconst MAX_SPEED = 40 / 7.5;\nconst ACCELERATION_TIME = 1 / (0.15 * 1e3);\nclass FocusController {\n  constructor() {\n    this.targetX = 0;\n    this.targetY = 0;\n    this.x = 0;\n    this.y = 0;\n    this.vx = 0;\n    this.vy = 0;\n  }\n  focus(x, y, instant = false) {\n    this.targetX = clamp(x, -1, 1);\n    this.targetY = clamp(y, -1, 1);\n    if (instant) {\n      this.x = this.targetX;\n      this.y = this.targetY;\n    }\n  }\n  update(dt) {\n    const dx = this.targetX - this.x;\n    const dy = this.targetY - this.y;\n    if (Math.abs(dx) < EPSILON && Math.abs(dy) < EPSILON)\n      return;\n    const d = Math.sqrt(__pow(dx, 2) + __pow(dy, 2));\n    const maxSpeed = MAX_SPEED / (1e3 / dt);\n    let ax = maxSpeed * (dx / d) - this.vx;\n    let ay = maxSpeed * (dy / d) - this.vy;\n    const a = Math.sqrt(__pow(ax, 2) + __pow(ay, 2));\n    const maxA = maxSpeed * ACCELERATION_TIME * dt;\n    if (a > maxA) {\n      ax *= maxA / a;\n      ay *= maxA / a;\n    }\n    this.vx += ax;\n    this.vy += ay;\n    const v = Math.sqrt(__pow(this.vx, 2) + __pow(this.vy, 2));\n    const maxV = 0.5 * (Math.sqrt(__pow(maxA, 2) + 8 * maxA * d) - maxA);\n    if (v > maxV) {\n      this.vx *= maxV / v;\n      this.vy *= maxV / v;\n    }\n    this.x += this.vx;\n    this.y += this.vy;\n  }\n}\nclass ModelSettings {\n  constructor(json) {\n    this.json = json;\n    let url2 = json.url;\n    if (typeof url2 !== \"string\") {\n      throw new TypeError(\"The `url` field in settings JSON must be defined as a string.\");\n    }\n    this.url = url2;\n    this.name = folderName(this.url);\n  }\n  resolveURL(path) {\n    return _pixi_utils__WEBPACK_IMPORTED_MODULE_0__.url.resolve(this.url, path);\n  }\n  replaceFiles(replacer) {\n    this.moc = replacer(this.moc, \"moc\");\n    if (this.pose !== void 0) {\n      this.pose = replacer(this.pose, \"pose\");\n    }\n    if (this.physics !== void 0) {\n      this.physics = replacer(this.physics, \"physics\");\n    }\n    for (let i = 0; i < this.textures.length; i++) {\n      this.textures[i] = replacer(this.textures[i], `textures[${i}]`);\n    }\n  }\n  getDefinedFiles() {\n    const files = [];\n    this.replaceFiles((file) => {\n      files.push(file);\n      return file;\n    });\n    return files;\n  }\n  validateFiles(files) {\n    const assertFileExists = (expectedFile, shouldThrow) => {\n      const actualPath = this.resolveURL(expectedFile);\n      if (!files.includes(actualPath)) {\n        if (shouldThrow) {\n          throw new Error(`File \"${expectedFile}\" is defined in settings, but doesn't exist in given files`);\n        }\n        return false;\n      }\n      return true;\n    };\n    const essentialFiles = [this.moc, ...this.textures];\n    essentialFiles.forEach((texture) => assertFileExists(texture, true));\n    const definedFiles = this.getDefinedFiles();\n    return definedFiles.filter((file) => assertFileExists(file, false));\n  }\n}\nvar MotionPriority = /* @__PURE__ */ ((MotionPriority2) => {\n  MotionPriority2[MotionPriority2[\"NONE\"] = 0] = \"NONE\";\n  MotionPriority2[MotionPriority2[\"IDLE\"] = 1] = \"IDLE\";\n  MotionPriority2[MotionPriority2[\"NORMAL\"] = 2] = \"NORMAL\";\n  MotionPriority2[MotionPriority2[\"FORCE\"] = 3] = \"FORCE\";\n  return MotionPriority2;\n})(MotionPriority || {});\nclass MotionState {\n  constructor() {\n    this.debug = false;\n    this.currentPriority = 0;\n    this.reservePriority = 0;\n  }\n  reserve(group, index, priority) {\n    if (priority <= 0) {\n      logger.log(this.tag, `Cannot start a motion with MotionPriority.NONE.`);\n      return false;\n    }\n    if (group === this.currentGroup && index === this.currentIndex) {\n      logger.log(this.tag, `Motion is already playing.`, this.dump(group, index));\n      return false;\n    }\n    if (group === this.reservedGroup && index === this.reservedIndex || group === this.reservedIdleGroup && index === this.reservedIdleIndex) {\n      logger.log(this.tag, `Motion is already reserved.`, this.dump(group, index));\n      return false;\n    }\n    if (priority === 1) {\n      if (this.currentPriority !== 0) {\n        logger.log(this.tag, `Cannot start idle motion because another motion is playing.`, this.dump(group, index));\n        return false;\n      }\n      if (this.reservedIdleGroup !== void 0) {\n        logger.log(this.tag, `Cannot start idle motion because another idle motion has reserved.`, this.dump(group, index));\n        return false;\n      }\n      this.setReservedIdle(group, index);\n    } else {\n      if (priority < 3) {\n        if (priority <= this.currentPriority) {\n          logger.log(this.tag, \"Cannot start motion because another motion is playing as an equivalent or higher priority.\", this.dump(group, index));\n          return false;\n        }\n        if (priority <= this.reservePriority) {\n          logger.log(this.tag, \"Cannot start motion because another motion has reserved as an equivalent or higher priority.\", this.dump(group, index));\n          return false;\n        }\n      }\n      this.setReserved(group, index, priority);\n    }\n    return true;\n  }\n  start(motion, group, index, priority) {\n    if (priority === 1) {\n      this.setReservedIdle(void 0, void 0);\n      if (this.currentPriority !== 0) {\n        logger.log(this.tag, \"Cannot start idle motion because another motion is playing.\", this.dump(group, index));\n        return false;\n      }\n    } else {\n      if (group !== this.reservedGroup || index !== this.reservedIndex) {\n        logger.log(this.tag, \"Cannot start motion because another motion has taken the place.\", this.dump(group, index));\n        return false;\n      }\n      this.setReserved(void 0, void 0, 0);\n    }\n    if (!motion) {\n      return false;\n    }\n    this.setCurrent(group, index, priority);\n    return true;\n  }\n  complete() {\n    this.setCurrent(void 0, void 0, 0);\n  }\n  setCurrent(group, index, priority) {\n    this.currentPriority = priority;\n    this.currentGroup = group;\n    this.currentIndex = index;\n  }\n  setReserved(group, index, priority) {\n    this.reservePriority = priority;\n    this.reservedGroup = group;\n    this.reservedIndex = index;\n  }\n  setReservedIdle(group, index) {\n    this.reservedIdleGroup = group;\n    this.reservedIdleIndex = index;\n  }\n  isActive(group, index) {\n    return group === this.currentGroup && index === this.currentIndex || group === this.reservedGroup && index === this.reservedIndex || group === this.reservedIdleGroup && index === this.reservedIdleIndex;\n  }\n  reset() {\n    this.setCurrent(void 0, void 0, 0);\n    this.setReserved(void 0, void 0, 0);\n    this.setReservedIdle(void 0, void 0);\n  }\n  shouldRequestIdleMotion() {\n    return this.currentGroup === void 0 && this.reservedIdleGroup === void 0;\n  }\n  shouldOverrideExpression() {\n    return !config.preserveExpressionOnMotion && this.currentPriority > 1;\n  }\n  dump(requestedGroup, requestedIndex) {\n    if (this.debug) {\n      const keys = [\n        \"currentPriority\",\n        \"reservePriority\",\n        \"currentGroup\",\n        \"currentIndex\",\n        \"reservedGroup\",\n        \"reservedIndex\",\n        \"reservedIdleGroup\",\n        \"reservedIdleIndex\"\n      ];\n      return `\n<Requested> group = \"${requestedGroup}\", index = ${requestedIndex}\n` + keys.map((key) => \"[\" + key + \"] \" + this[key]).join(\"\\n\");\n    }\n    return \"\";\n  }\n}\nconst TAG$2 = \"SoundManager\";\nconst VOLUME = 0.5;\nclass SoundManager {\n  static get volume() {\n    return this._volume;\n  }\n  static set volume(value) {\n    this._volume = (value > 1 ? 1 : value < 0 ? 0 : value) || 0;\n    this.audios.forEach((audio) => audio.volume = this._volume);\n  }\n  static add(file, onFinish, onError) {\n    const audio = new Audio(file);\n    audio.volume = this._volume;\n    audio.preload = \"auto\";\n    audio.addEventListener(\"ended\", () => {\n      this.dispose(audio);\n      onFinish == null ? void 0 : onFinish();\n    });\n    audio.addEventListener(\"error\", (e) => {\n      this.dispose(audio);\n      logger.warn(TAG$2, `Error occurred on \"${file}\"`, e.error);\n      onError == null ? void 0 : onError(e.error);\n    });\n    this.audios.push(audio);\n    return audio;\n  }\n  static play(audio) {\n    return new Promise((resolve, reject) => {\n      var _a;\n      (_a = audio.play()) == null ? void 0 : _a.catch((e) => {\n        audio.dispatchEvent(new ErrorEvent(\"error\", { error: e }));\n        reject(e);\n      });\n      if (audio.readyState === audio.HAVE_ENOUGH_DATA) {\n        resolve();\n      } else {\n        audio.addEventListener(\"canplaythrough\", resolve);\n      }\n    });\n  }\n  static dispose(audio) {\n    audio.pause();\n    audio.removeAttribute(\"src\");\n    remove(this.audios, audio);\n  }\n  static destroy() {\n    for (let i = this.audios.length - 1; i >= 0; i--) {\n      this.dispose(this.audios[i]);\n    }\n  }\n}\nSoundManager.audios = [];\nSoundManager._volume = VOLUME;\nvar MotionPreloadStrategy = /* @__PURE__ */ ((MotionPreloadStrategy2) => {\n  MotionPreloadStrategy2[\"ALL\"] = \"ALL\";\n  MotionPreloadStrategy2[\"IDLE\"] = \"IDLE\";\n  MotionPreloadStrategy2[\"NONE\"] = \"NONE\";\n  return MotionPreloadStrategy2;\n})(MotionPreloadStrategy || {});\nclass MotionManager extends _pixi_utils__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  constructor(settings, options) {\n    super();\n    this.motionGroups = {};\n    this.state = new MotionState();\n    this.playing = false;\n    this.destroyed = false;\n    this.settings = settings;\n    this.tag = `MotionManager(${settings.name})`;\n    this.state.tag = this.tag;\n  }\n  init(options) {\n    if (options == null ? void 0 : options.idleMotionGroup) {\n      this.groups.idle = options.idleMotionGroup;\n    }\n    this.setupMotions(options);\n    this.stopAllMotions();\n  }\n  setupMotions(options) {\n    for (const group of Object.keys(this.definitions)) {\n      this.motionGroups[group] = [];\n    }\n    let groups;\n    switch (options == null ? void 0 : options.motionPreload) {\n      case \"NONE\":\n        return;\n      case \"ALL\":\n        groups = Object.keys(this.definitions);\n        break;\n      case \"IDLE\":\n      default:\n        groups = [this.groups.idle];\n        break;\n    }\n    for (const group of groups) {\n      if (this.definitions[group]) {\n        for (let i = 0; i < this.definitions[group].length; i++) {\n          this.loadMotion(group, i).then();\n        }\n      }\n    }\n  }\n  loadMotion(group, index) {\n    return __async(this, null, function* () {\n      var _a;\n      if (!((_a = this.definitions[group]) == null ? void 0 : _a[index])) {\n        logger.warn(this.tag, `Undefined motion at \"${group}\"[${index}]`);\n        return void 0;\n      }\n      if (this.motionGroups[group][index] === null) {\n        logger.warn(this.tag, `Cannot start motion at \"${group}\"[${index}] because it's already failed in loading.`);\n        return void 0;\n      }\n      if (this.motionGroups[group][index]) {\n        return this.motionGroups[group][index];\n      }\n      const motion = yield this._loadMotion(group, index);\n      if (this.destroyed) {\n        return;\n      }\n      this.motionGroups[group][index] = motion != null ? motion : null;\n      return motion;\n    });\n  }\n  _loadMotion(group, index) {\n    throw new Error(\"Not implemented.\");\n  }\n  startMotion(_0, _1) {\n    return __async(this, arguments, function* (group, index, priority = MotionPriority.NORMAL) {\n      var _a;\n      if (!this.state.reserve(group, index, priority)) {\n        return false;\n      }\n      const definition = (_a = this.definitions[group]) == null ? void 0 : _a[index];\n      if (!definition) {\n        return false;\n      }\n      if (this.currentAudio) {\n        SoundManager.dispose(this.currentAudio);\n      }\n      let audio;\n      if (config.sound) {\n        const soundURL = this.getSoundFile(definition);\n        if (soundURL) {\n          try {\n            audio = SoundManager.add(this.settings.resolveURL(soundURL), () => this.currentAudio = void 0, () => this.currentAudio = void 0);\n            this.currentAudio = audio;\n          } catch (e) {\n            logger.warn(this.tag, \"Failed to create audio\", soundURL, e);\n          }\n        }\n      }\n      const motion = yield this.loadMotion(group, index);\n      if (audio) {\n        const readyToPlay = SoundManager.play(audio).catch((e) => logger.warn(this.tag, \"Failed to play audio\", audio.src, e));\n        if (config.motionSync) {\n          yield readyToPlay;\n        }\n      }\n      if (!this.state.start(motion, group, index, priority)) {\n        if (audio) {\n          SoundManager.dispose(audio);\n          this.currentAudio = void 0;\n        }\n        return false;\n      }\n      logger.log(this.tag, \"Start motion:\", this.getMotionName(definition));\n      this.emit(\"motionStart\", group, index, audio);\n      if (this.state.shouldOverrideExpression()) {\n        this.expressionManager && this.expressionManager.resetExpression();\n      }\n      this.playing = true;\n      this._startMotion(motion);\n      return true;\n    });\n  }\n  startRandomMotion(group, priority) {\n    return __async(this, null, function* () {\n      const groupDefs = this.definitions[group];\n      if (groupDefs == null ? void 0 : groupDefs.length) {\n        const availableIndices = [];\n        for (let i = 0; i < groupDefs.length; i++) {\n          if (this.motionGroups[group][i] !== null && !this.state.isActive(group, i)) {\n            availableIndices.push(i);\n          }\n        }\n        if (availableIndices.length) {\n          const index = Math.floor(Math.random() * availableIndices.length);\n          return this.startMotion(group, availableIndices[index], priority);\n        }\n      }\n      return false;\n    });\n  }\n  stopAllMotions() {\n    this._stopAllMotions();\n    this.state.reset();\n    if (this.currentAudio) {\n      SoundManager.dispose(this.currentAudio);\n      this.currentAudio = void 0;\n    }\n  }\n  update(model, now) {\n    var _a;\n    if (this.isFinished()) {\n      if (this.playing) {\n        this.playing = false;\n        this.emit(\"motionFinish\");\n      }\n      if (this.state.shouldOverrideExpression()) {\n        (_a = this.expressionManager) == null ? void 0 : _a.restoreExpression();\n      }\n      this.state.complete();\n      if (this.state.shouldRequestIdleMotion()) {\n        this.startRandomMotion(this.groups.idle, MotionPriority.IDLE);\n      }\n    }\n    return this.updateParameters(model, now);\n  }\n  destroy() {\n    var _a;\n    this.destroyed = true;\n    this.emit(\"destroy\");\n    this.stopAllMotions();\n    (_a = this.expressionManager) == null ? void 0 : _a.destroy();\n    const self = this;\n    self.definitions = void 0;\n    self.motionGroups = void 0;\n  }\n}\nconst tempBounds = { x: 0, y: 0, width: 0, height: 0 };\nclass InternalModel extends _pixi_utils__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  constructor() {\n    super(...arguments);\n    this.focusController = new FocusController();\n    this.originalWidth = 0;\n    this.originalHeight = 0;\n    this.width = 0;\n    this.height = 0;\n    this.localTransform = new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Matrix();\n    this.drawingMatrix = new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Matrix();\n    this.hitAreas = {};\n    this.textureFlipY = false;\n    this.viewport = [0, 0, 0, 0];\n    this.destroyed = false;\n  }\n  init() {\n    this.setupLayout();\n    this.setupHitAreas();\n  }\n  setupLayout() {\n    const self = this;\n    const size = this.getSize();\n    self.originalWidth = size[0];\n    self.originalHeight = size[1];\n    const layout = Object.assign({\n      width: LOGICAL_WIDTH,\n      height: LOGICAL_HEIGHT\n    }, this.getLayout());\n    this.localTransform.scale(layout.width / LOGICAL_WIDTH, layout.height / LOGICAL_HEIGHT);\n    self.width = this.originalWidth * this.localTransform.a;\n    self.height = this.originalHeight * this.localTransform.d;\n    const offsetX = layout.x !== void 0 && layout.x - layout.width / 2 || layout.centerX !== void 0 && layout.centerX || layout.left !== void 0 && layout.left - layout.width / 2 || layout.right !== void 0 && layout.right + layout.width / 2 || 0;\n    const offsetY = layout.y !== void 0 && layout.y - layout.height / 2 || layout.centerY !== void 0 && layout.centerY || layout.top !== void 0 && layout.top - layout.height / 2 || layout.bottom !== void 0 && layout.bottom + layout.height / 2 || 0;\n    this.localTransform.translate(this.width * offsetX, -this.height * offsetY);\n  }\n  setupHitAreas() {\n    const definitions = this.getHitAreaDefs().filter((hitArea) => hitArea.index >= 0);\n    for (const def of definitions) {\n      this.hitAreas[def.name] = def;\n    }\n  }\n  hitTest(x, y) {\n    return Object.keys(this.hitAreas).filter((hitAreaName) => this.isHit(hitAreaName, x, y));\n  }\n  isHit(hitAreaName, x, y) {\n    if (!this.hitAreas[hitAreaName]) {\n      return false;\n    }\n    const drawIndex = this.hitAreas[hitAreaName].index;\n    const bounds = this.getDrawableBounds(drawIndex, tempBounds);\n    return bounds.x <= x && x <= bounds.x + bounds.width && bounds.y <= y && y <= bounds.y + bounds.height;\n  }\n  getDrawableBounds(index, bounds) {\n    const vertices = this.getDrawableVertices(index);\n    let left = vertices[0];\n    let right = vertices[0];\n    let top = vertices[1];\n    let bottom = vertices[1];\n    for (let i = 0; i < vertices.length; i += 2) {\n      const vx = vertices[i];\n      const vy = vertices[i + 1];\n      left = Math.min(vx, left);\n      right = Math.max(vx, right);\n      top = Math.min(vy, top);\n      bottom = Math.max(vy, bottom);\n    }\n    bounds != null ? bounds : bounds = {};\n    bounds.x = left;\n    bounds.y = top;\n    bounds.width = right - left;\n    bounds.height = bottom - top;\n    return bounds;\n  }\n  updateTransform(transform) {\n    this.drawingMatrix.copyFrom(transform).append(this.localTransform);\n  }\n  update(dt, now) {\n    this.focusController.update(dt);\n  }\n  destroy() {\n    this.destroyed = true;\n    this.emit(\"destroy\");\n    this.motionManager.destroy();\n    this.motionManager = void 0;\n  }\n}\nconst TAG$1 = \"XHRLoader\";\nclass NetworkError extends Error {\n  constructor(message, url2, status, aborted = false) {\n    super(message);\n    this.url = url2;\n    this.status = status;\n    this.aborted = aborted;\n  }\n}\nconst _XHRLoader = class {\n  static createXHR(target, url2, type, onload, onerror) {\n    const xhr = new XMLHttpRequest();\n    _XHRLoader.allXhrSet.add(xhr);\n    if (target) {\n      let xhrSet = _XHRLoader.xhrMap.get(target);\n      if (!xhrSet) {\n        xhrSet = /* @__PURE__ */ new Set([xhr]);\n        _XHRLoader.xhrMap.set(target, xhrSet);\n      } else {\n        xhrSet.add(xhr);\n      }\n      if (!target.listeners(\"destroy\").includes(_XHRLoader.cancelXHRs)) {\n        target.once(\"destroy\", _XHRLoader.cancelXHRs);\n      }\n    }\n    xhr.open(\"GET\", url2);\n    xhr.responseType = type;\n    xhr.onload = () => {\n      if ((xhr.status === 200 || xhr.status === 0) && xhr.response) {\n        onload(xhr.response);\n      } else {\n        xhr.onerror();\n      }\n    };\n    xhr.onerror = () => {\n      logger.warn(TAG$1, `Failed to load resource as ${xhr.responseType} (Status ${xhr.status}): ${url2}`);\n      onerror(new NetworkError(\"Network error.\", url2, xhr.status));\n    };\n    xhr.onabort = () => onerror(new NetworkError(\"Aborted.\", url2, xhr.status, true));\n    xhr.onloadend = () => {\n      var _a;\n      _XHRLoader.allXhrSet.delete(xhr);\n      if (target) {\n        (_a = _XHRLoader.xhrMap.get(target)) == null ? void 0 : _a.delete(xhr);\n      }\n    };\n    return xhr;\n  }\n  static cancelXHRs() {\n    var _a;\n    (_a = _XHRLoader.xhrMap.get(this)) == null ? void 0 : _a.forEach((xhr) => {\n      xhr.abort();\n      _XHRLoader.allXhrSet.delete(xhr);\n    });\n    _XHRLoader.xhrMap.delete(this);\n  }\n  static release() {\n    _XHRLoader.allXhrSet.forEach((xhr) => xhr.abort());\n    _XHRLoader.allXhrSet.clear();\n    _XHRLoader.xhrMap = /* @__PURE__ */ new WeakMap();\n  }\n};\nlet XHRLoader = _XHRLoader;\nXHRLoader.xhrMap = /* @__PURE__ */ new WeakMap();\nXHRLoader.allXhrSet = /* @__PURE__ */ new Set();\nXHRLoader.loader = (context, next) => {\n  return new Promise((resolve, reject) => {\n    const xhr = _XHRLoader.createXHR(context.target, context.settings ? context.settings.resolveURL(context.url) : context.url, context.type, (data) => {\n      context.result = data;\n      resolve();\n    }, reject);\n    xhr.send();\n  });\n};\nfunction runMiddlewares(middleware, context) {\n  let index = -1;\n  return dispatch(0);\n  function dispatch(i, err) {\n    if (err)\n      return Promise.reject(err);\n    if (i <= index)\n      return Promise.reject(new Error(\"next() called multiple times\"));\n    index = i;\n    const fn = middleware[i];\n    if (!fn)\n      return Promise.resolve();\n    try {\n      return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));\n    } catch (err2) {\n      return Promise.reject(err2);\n    }\n  }\n}\nclass Live2DLoader {\n  static load(context) {\n    return runMiddlewares(this.middlewares, context).then(() => context.result);\n  }\n}\nLive2DLoader.middlewares = [XHRLoader.loader];\nfunction createTexture(url2, options = {}) {\n  var _a;\n  const textureOptions = { resourceOptions: { crossorigin: options.crossOrigin } };\n  if (_pixi_core__WEBPACK_IMPORTED_MODULE_2__.Texture.fromURL) {\n    return _pixi_core__WEBPACK_IMPORTED_MODULE_2__.Texture.fromURL(url2, textureOptions).catch((e) => {\n      if (e instanceof Error) {\n        throw e;\n      }\n      const err = new Error(\"Texture loading error\");\n      err.event = e;\n      throw err;\n    });\n  }\n  textureOptions.resourceOptions.autoLoad = false;\n  const texture = _pixi_core__WEBPACK_IMPORTED_MODULE_2__.Texture.from(url2, textureOptions);\n  if (texture.baseTexture.valid) {\n    return Promise.resolve(texture);\n  }\n  const resource = texture.baseTexture.resource;\n  (_a = resource._live2d_load) != null ? _a : resource._live2d_load = new Promise((resolve, reject) => {\n    const errorHandler = (event) => {\n      resource.source.removeEventListener(\"error\", errorHandler);\n      const err = new Error(\"Texture loading error\");\n      err.event = event;\n      reject(err);\n    };\n    resource.source.addEventListener(\"error\", errorHandler);\n    resource.load().then(() => resolve(texture)).catch(errorHandler);\n  });\n  return resource._live2d_load;\n}\nconst TAG = \"Live2DFactory\";\nconst urlToJSON = (context, next) => __async(void 0, null, function* () {\n  if (typeof context.source === \"string\") {\n    const data = yield Live2DLoader.load({\n      url: context.source,\n      type: \"json\",\n      target: context.live2dModel\n    });\n    data.url = context.source;\n    context.source = data;\n    context.live2dModel.emit(\"settingsJSONLoaded\", data);\n  }\n  return next();\n});\nconst jsonToSettings = (context, next) => __async(void 0, null, function* () {\n  if (context.source instanceof ModelSettings) {\n    context.settings = context.source;\n    return next();\n  } else if (typeof context.source === \"object\") {\n    const runtime = Live2DFactory.findRuntime(context.source);\n    if (runtime) {\n      const settings = runtime.createModelSettings(context.source);\n      context.settings = settings;\n      context.live2dModel.emit(\"settingsLoaded\", settings);\n      return next();\n    }\n  }\n  throw new TypeError(\"Unknown settings format.\");\n});\nconst waitUntilReady = (context, next) => {\n  if (context.settings) {\n    const runtime = Live2DFactory.findRuntime(context.settings);\n    if (runtime) {\n      return runtime.ready().then(next);\n    }\n  }\n  return next();\n};\nconst setupOptionals = (context, next) => __async(void 0, null, function* () {\n  yield next();\n  const internalModel = context.internalModel;\n  if (internalModel) {\n    const settings = context.settings;\n    const runtime = Live2DFactory.findRuntime(settings);\n    if (runtime) {\n      const tasks = [];\n      if (settings.pose) {\n        tasks.push(Live2DLoader.load({\n          settings,\n          url: settings.pose,\n          type: \"json\",\n          target: internalModel\n        }).then((data) => {\n          internalModel.pose = runtime.createPose(internalModel.coreModel, data);\n          context.live2dModel.emit(\"poseLoaded\", internalModel.pose);\n        }).catch((e) => {\n          context.live2dModel.emit(\"poseLoadError\", e);\n          logger.warn(TAG, \"Failed to load pose.\", e);\n        }));\n      }\n      if (settings.physics) {\n        tasks.push(Live2DLoader.load({\n          settings,\n          url: settings.physics,\n          type: \"json\",\n          target: internalModel\n        }).then((data) => {\n          internalModel.physics = runtime.createPhysics(internalModel.coreModel, data);\n          context.live2dModel.emit(\"physicsLoaded\", internalModel.physics);\n        }).catch((e) => {\n          context.live2dModel.emit(\"physicsLoadError\", e);\n          logger.warn(TAG, \"Failed to load physics.\", e);\n        }));\n      }\n      if (tasks.length) {\n        yield Promise.all(tasks);\n      }\n    }\n  }\n});\nconst setupEssentials = (context, next) => __async(void 0, null, function* () {\n  if (context.settings) {\n    const live2DModel = context.live2dModel;\n    const textureLoadings = context.settings.textures.map((tex) => {\n      const url2 = context.settings.resolveURL(tex);\n      return createTexture(url2, { crossOrigin: context.options.crossOrigin });\n    });\n    yield next();\n    if (context.internalModel) {\n      live2DModel.internalModel = context.internalModel;\n      live2DModel.emit(\"modelLoaded\", context.internalModel);\n    } else {\n      throw new TypeError(\"Missing internal model.\");\n    }\n    live2DModel.textures = yield Promise.all(textureLoadings);\n    live2DModel.emit(\"textureLoaded\", live2DModel.textures);\n  } else {\n    throw new TypeError(\"Missing settings.\");\n  }\n});\nconst createInternalModel = (context, next) => __async(void 0, null, function* () {\n  const settings = context.settings;\n  if (settings instanceof ModelSettings) {\n    const runtime = Live2DFactory.findRuntime(settings);\n    if (!runtime) {\n      throw new TypeError(\"Unknown model settings.\");\n    }\n    const modelData = yield Live2DLoader.load({\n      settings,\n      url: settings.moc,\n      type: \"arraybuffer\",\n      target: context.live2dModel\n    });\n    if (!runtime.isValidMoc(modelData)) {\n      throw new Error(\"Invalid moc data\");\n    }\n    const coreModel = runtime.createCoreModel(modelData);\n    context.internalModel = runtime.createInternalModel(coreModel, settings, context.options);\n    return next();\n  }\n  throw new TypeError(\"Missing settings.\");\n});\nconst _Live2DFactory = class {\n  static registerRuntime(runtime) {\n    _Live2DFactory.runtimes.push(runtime);\n    _Live2DFactory.runtimes.sort((a, b) => b.version - a.version);\n  }\n  static findRuntime(source) {\n    for (const runtime of _Live2DFactory.runtimes) {\n      if (runtime.test(source)) {\n        return runtime;\n      }\n    }\n  }\n  static setupLive2DModel(live2dModel, source, options) {\n    return __async(this, null, function* () {\n      const textureLoaded = new Promise((resolve) => live2dModel.once(\"textureLoaded\", resolve));\n      const modelLoaded = new Promise((resolve) => live2dModel.once(\"modelLoaded\", resolve));\n      const readyEventEmitted = Promise.all([textureLoaded, modelLoaded]).then(() => live2dModel.emit(\"ready\"));\n      yield runMiddlewares(_Live2DFactory.live2DModelMiddlewares, {\n        live2dModel,\n        source,\n        options: options || {}\n      });\n      yield readyEventEmitted;\n      live2dModel.emit(\"load\");\n    });\n  }\n  static loadMotion(motionManager, group, index) {\n    var _a, _b;\n    const handleError = (e) => motionManager.emit(\"motionLoadError\", group, index, e);\n    try {\n      const definition = (_a = motionManager.definitions[group]) == null ? void 0 : _a[index];\n      if (!definition) {\n        return Promise.resolve(void 0);\n      }\n      if (!motionManager.listeners(\"destroy\").includes(_Live2DFactory.releaseTasks)) {\n        motionManager.once(\"destroy\", _Live2DFactory.releaseTasks);\n      }\n      let tasks = _Live2DFactory.motionTasksMap.get(motionManager);\n      if (!tasks) {\n        tasks = {};\n        _Live2DFactory.motionTasksMap.set(motionManager, tasks);\n      }\n      let taskGroup = tasks[group];\n      if (!taskGroup) {\n        taskGroup = [];\n        tasks[group] = taskGroup;\n      }\n      const path = motionManager.getMotionFile(definition);\n      (_b = taskGroup[index]) != null ? _b : taskGroup[index] = Live2DLoader.load({\n        url: path,\n        settings: motionManager.settings,\n        type: motionManager.motionDataType,\n        target: motionManager\n      }).then((data) => {\n        var _a2;\n        const taskGroup2 = (_a2 = _Live2DFactory.motionTasksMap.get(motionManager)) == null ? void 0 : _a2[group];\n        if (taskGroup2) {\n          delete taskGroup2[index];\n        }\n        const motion = motionManager.createMotion(data, group, definition);\n        motionManager.emit(\"motionLoaded\", group, index, motion);\n        return motion;\n      }).catch((e) => {\n        logger.warn(motionManager.tag, `Failed to load motion: ${path}\n`, e);\n        handleError(e);\n      });\n      return taskGroup[index];\n    } catch (e) {\n      logger.warn(motionManager.tag, `Failed to load motion at \"${group}\"[${index}]\n`, e);\n      handleError(e);\n    }\n    return Promise.resolve(void 0);\n  }\n  static loadExpression(expressionManager, index) {\n    var _a;\n    const handleError = (e) => expressionManager.emit(\"expressionLoadError\", index, e);\n    try {\n      const definition = expressionManager.definitions[index];\n      if (!definition) {\n        return Promise.resolve(void 0);\n      }\n      if (!expressionManager.listeners(\"destroy\").includes(_Live2DFactory.releaseTasks)) {\n        expressionManager.once(\"destroy\", _Live2DFactory.releaseTasks);\n      }\n      let tasks = _Live2DFactory.expressionTasksMap.get(expressionManager);\n      if (!tasks) {\n        tasks = [];\n        _Live2DFactory.expressionTasksMap.set(expressionManager, tasks);\n      }\n      const path = expressionManager.getExpressionFile(definition);\n      (_a = tasks[index]) != null ? _a : tasks[index] = Live2DLoader.load({\n        url: path,\n        settings: expressionManager.settings,\n        type: \"json\",\n        target: expressionManager\n      }).then((data) => {\n        const tasks2 = _Live2DFactory.expressionTasksMap.get(expressionManager);\n        if (tasks2) {\n          delete tasks2[index];\n        }\n        const expression = expressionManager.createExpression(data, definition);\n        expressionManager.emit(\"expressionLoaded\", index, expression);\n        return expression;\n      }).catch((e) => {\n        logger.warn(expressionManager.tag, `Failed to load expression: ${path}\n`, e);\n        handleError(e);\n      });\n      return tasks[index];\n    } catch (e) {\n      logger.warn(expressionManager.tag, `Failed to load expression at [${index}]\n`, e);\n      handleError(e);\n    }\n    return Promise.resolve(void 0);\n  }\n  static releaseTasks() {\n    if (this instanceof MotionManager) {\n      _Live2DFactory.motionTasksMap.delete(this);\n    } else {\n      _Live2DFactory.expressionTasksMap.delete(this);\n    }\n  }\n};\nlet Live2DFactory = _Live2DFactory;\nLive2DFactory.runtimes = [];\nLive2DFactory.urlToJSON = urlToJSON;\nLive2DFactory.jsonToSettings = jsonToSettings;\nLive2DFactory.waitUntilReady = waitUntilReady;\nLive2DFactory.setupOptionals = setupOptionals;\nLive2DFactory.setupEssentials = setupEssentials;\nLive2DFactory.createInternalModel = createInternalModel;\nLive2DFactory.live2DModelMiddlewares = [\n  urlToJSON,\n  jsonToSettings,\n  waitUntilReady,\n  setupOptionals,\n  setupEssentials,\n  createInternalModel\n];\nLive2DFactory.motionTasksMap = /* @__PURE__ */ new WeakMap();\nLive2DFactory.expressionTasksMap = /* @__PURE__ */ new WeakMap();\nMotionManager.prototype[\"_loadMotion\"] = function(group, index) {\n  return Live2DFactory.loadMotion(this, group, index);\n};\nExpressionManager.prototype[\"_loadExpression\"] = function(index) {\n  return Live2DFactory.loadExpression(this, index);\n};\nclass InteractionMixin {\n  constructor() {\n    this._autoInteract = false;\n  }\n  get autoInteract() {\n    return this._autoInteract;\n  }\n  set autoInteract(autoInteract) {\n    if (autoInteract !== this._autoInteract) {\n      if (autoInteract) {\n        this.on(\"pointertap\", onTap, this);\n      } else {\n        this.off(\"pointertap\", onTap, this);\n      }\n      this._autoInteract = autoInteract;\n    }\n  }\n  registerInteraction(manager) {\n    if (manager !== this.interactionManager) {\n      this.unregisterInteraction();\n      if (this._autoInteract && manager) {\n        this.interactionManager = manager;\n        manager.on(\"pointermove\", onPointerMove, this);\n      }\n    }\n  }\n  unregisterInteraction() {\n    var _a;\n    if (this.interactionManager) {\n      (_a = this.interactionManager) == null ? void 0 : _a.off(\"pointermove\", onPointerMove, this);\n      this.interactionManager = void 0;\n    }\n  }\n}\nfunction onTap(event) {\n  this.tap(event.data.global.x, event.data.global.y);\n}\nfunction onPointerMove(event) {\n  this.focus(event.data.global.x, event.data.global.y);\n}\nclass Live2DTransform extends _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Transform {\n}\nconst tempPoint = new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Point();\nconst tempMatrix$1 = new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Matrix();\nlet tickerRef;\nclass Live2DModel extends _pixi_display__WEBPACK_IMPORTED_MODULE_3__.Container {\n  constructor(options) {\n    super();\n    this.tag = \"Live2DModel(uninitialized)\";\n    this.textures = [];\n    this.transform = new Live2DTransform();\n    this.anchor = new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.ObservablePoint(this.onAnchorChange, this, 0, 0);\n    this.glContextID = -1;\n    this.elapsedTime = performance.now();\n    this.deltaTime = 0;\n    this._autoUpdate = false;\n    this.once(\"modelLoaded\", () => this.init(options));\n  }\n  static from(source, options) {\n    const model = new this(options);\n    return Live2DFactory.setupLive2DModel(model, source, options).then(() => model);\n  }\n  static fromSync(source, options) {\n    const model = new this(options);\n    Live2DFactory.setupLive2DModel(model, source, options).then(options == null ? void 0 : options.onLoad).catch(options == null ? void 0 : options.onError);\n    return model;\n  }\n  static registerTicker(tickerClass) {\n    tickerRef = tickerClass;\n  }\n  get autoUpdate() {\n    return this._autoUpdate;\n  }\n  set autoUpdate(autoUpdate) {\n    var _a;\n    tickerRef || (tickerRef = (_a = window.PIXI) == null ? void 0 : _a.Ticker);\n    if (autoUpdate) {\n      if (!this._destroyed) {\n        if (tickerRef) {\n          tickerRef.shared.add(this.onTickerUpdate, this);\n          this._autoUpdate = true;\n        } else {\n          logger.warn(this.tag, \"No Ticker registered, please call Live2DModel.registerTicker(Ticker).\");\n        }\n      }\n    } else {\n      tickerRef == null ? void 0 : tickerRef.shared.remove(this.onTickerUpdate, this);\n      this._autoUpdate = false;\n    }\n  }\n  init(options) {\n    this.tag = `Live2DModel(${this.internalModel.settings.name})`;\n    const _options = Object.assign({\n      autoUpdate: true,\n      autoInteract: true\n    }, options);\n    if (_options.autoInteract) {\n      this.interactive = true;\n    }\n    this.autoInteract = _options.autoInteract;\n    this.autoUpdate = _options.autoUpdate;\n  }\n  onAnchorChange() {\n    this.pivot.set(this.anchor.x * this.internalModel.width, this.anchor.y * this.internalModel.height);\n  }\n  motion(group, index, priority) {\n    return index === void 0 ? this.internalModel.motionManager.startRandomMotion(group, priority) : this.internalModel.motionManager.startMotion(group, index, priority);\n  }\n  expression(id) {\n    if (this.internalModel.motionManager.expressionManager) {\n      return id === void 0 ? this.internalModel.motionManager.expressionManager.setRandomExpression() : this.internalModel.motionManager.expressionManager.setExpression(id);\n    }\n    return Promise.resolve(false);\n  }\n  focus(x, y, instant = false) {\n    tempPoint.x = x;\n    tempPoint.y = y;\n    this.toModelPosition(tempPoint, tempPoint, true);\n    let tx = tempPoint.x / this.internalModel.originalWidth * 2 - 1;\n    let ty = tempPoint.y / this.internalModel.originalHeight * 2 - 1;\n    let radian = Math.atan2(ty, tx);\n    this.internalModel.focusController.focus(Math.cos(radian), -Math.sin(radian), instant);\n  }\n  tap(x, y) {\n    const hitAreaNames = this.hitTest(x, y);\n    if (hitAreaNames.length) {\n      logger.log(this.tag, `Hit`, hitAreaNames);\n      this.emit(\"hit\", hitAreaNames);\n    }\n  }\n  hitTest(x, y) {\n    tempPoint.x = x;\n    tempPoint.y = y;\n    this.toModelPosition(tempPoint, tempPoint);\n    return this.internalModel.hitTest(tempPoint.x, tempPoint.y);\n  }\n  toModelPosition(position, result = position.clone(), skipUpdate) {\n    if (!skipUpdate) {\n      this._recursivePostUpdateTransform();\n      if (!this.parent) {\n        this.parent = this._tempDisplayObjectParent;\n        this.displayObjectUpdateTransform();\n        this.parent = null;\n      } else {\n        this.displayObjectUpdateTransform();\n      }\n    }\n    this.transform.worldTransform.applyInverse(position, result);\n    this.internalModel.localTransform.applyInverse(result, result);\n    return result;\n  }\n  containsPoint(point) {\n    return this.getBounds(true).contains(point.x, point.y);\n  }\n  _calculateBounds() {\n    this._bounds.addFrame(this.transform, 0, 0, this.internalModel.width, this.internalModel.height);\n  }\n  onTickerUpdate() {\n    this.update(tickerRef.shared.deltaMS);\n  }\n  update(dt) {\n    this.deltaTime += dt;\n    this.elapsedTime += dt;\n  }\n  _render(renderer) {\n    this.registerInteraction(renderer.plugins.interaction);\n    renderer.batch.reset();\n    renderer.geometry.reset();\n    renderer.shader.reset();\n    renderer.state.reset();\n    let shouldUpdateTexture = false;\n    if (this.glContextID !== renderer.CONTEXT_UID) {\n      this.glContextID = renderer.CONTEXT_UID;\n      this.internalModel.updateWebGLContext(renderer.gl, this.glContextID);\n      shouldUpdateTexture = true;\n    }\n    for (let i = 0; i < this.textures.length; i++) {\n      const texture = this.textures[i];\n      if (!texture.valid) {\n        continue;\n      }\n      if (shouldUpdateTexture || !texture.baseTexture._glTextures[this.glContextID]) {\n        renderer.gl.pixelStorei(WebGLRenderingContext.UNPACK_FLIP_Y_WEBGL, this.internalModel.textureFlipY);\n        renderer.texture.bind(texture.baseTexture, 0);\n      }\n      this.internalModel.bindTexture(i, texture.baseTexture._glTextures[this.glContextID].texture);\n      texture.baseTexture.touched = renderer.textureGC.count;\n    }\n    const viewport = renderer.framebuffer.viewport;\n    this.internalModel.viewport = [viewport.x, viewport.y, viewport.width, viewport.height];\n    if (this.deltaTime) {\n      this.internalModel.update(this.deltaTime, this.elapsedTime);\n      this.deltaTime = 0;\n    }\n    const internalTransform = tempMatrix$1.copyFrom(renderer.globalUniforms.uniforms.projectionMatrix).append(this.worldTransform);\n    this.internalModel.updateTransform(internalTransform);\n    this.internalModel.draw(renderer.gl);\n    renderer.state.reset();\n    renderer.texture.reset();\n  }\n  destroy(options) {\n    this.emit(\"destroy\");\n    this.autoUpdate = false;\n    this.unregisterInteraction();\n    if (options == null ? void 0 : options.texture) {\n      this.textures.forEach((texture) => texture.destroy(options.baseTexture));\n    }\n    this.internalModel.destroy();\n    super.destroy(options);\n  }\n}\napplyMixins(Live2DModel, [InteractionMixin]);\nconst _FileLoader = class {\n  static resolveURL(settingsURL, filePath) {\n    var _a;\n    const resolved = (_a = _FileLoader.filesMap[settingsURL]) == null ? void 0 : _a[filePath];\n    if (resolved === void 0) {\n      throw new Error(\"Cannot find this file from uploaded files: \" + filePath);\n    }\n    return resolved;\n  }\n  static upload(files, settings) {\n    return __async(this, null, function* () {\n      const fileMap = {};\n      for (const definedFile of settings.getDefinedFiles()) {\n        const actualPath = decodeURI(_pixi_utils__WEBPACK_IMPORTED_MODULE_0__.url.resolve(settings.url, definedFile));\n        const actualFile = files.find((file) => file.webkitRelativePath === actualPath);\n        if (actualFile) {\n          fileMap[definedFile] = URL.createObjectURL(actualFile);\n        }\n      }\n      _FileLoader.filesMap[settings._objectURL] = fileMap;\n    });\n  }\n  static createSettings(files) {\n    return __async(this, null, function* () {\n      const settingsFile = files.find((file) => file.name.endsWith(\"model.json\") || file.name.endsWith(\"model3.json\"));\n      if (!settingsFile) {\n        throw new TypeError(\"Settings file not found\");\n      }\n      const settingsText = yield _FileLoader.readText(settingsFile);\n      const settingsJSON = JSON.parse(settingsText);\n      settingsJSON.url = settingsFile.webkitRelativePath;\n      const runtime = Live2DFactory.findRuntime(settingsJSON);\n      if (!runtime) {\n        throw new Error(\"Unknown settings JSON\");\n      }\n      const settings = runtime.createModelSettings(settingsJSON);\n      settings._objectURL = URL.createObjectURL(settingsFile);\n      return settings;\n    });\n  }\n  static readText(file) {\n    return __async(this, null, function* () {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => resolve(reader.result);\n        reader.onerror = reject;\n        reader.readAsText(file, \"utf8\");\n      });\n    });\n  }\n};\nlet FileLoader = _FileLoader;\nFileLoader.filesMap = {};\nFileLoader.factory = (context, next) => __async(void 0, null, function* () {\n  if (Array.isArray(context.source) && context.source[0] instanceof File) {\n    const files = context.source;\n    let settings = files.settings;\n    if (!settings) {\n      settings = yield _FileLoader.createSettings(files);\n    } else if (!settings._objectURL) {\n      throw new Error('\"_objectURL\" must be specified in ModelSettings');\n    }\n    settings.validateFiles(files.map((file) => encodeURI(file.webkitRelativePath)));\n    yield _FileLoader.upload(files, settings);\n    settings.resolveURL = function(url2) {\n      return _FileLoader.resolveURL(this._objectURL, url2);\n    };\n    context.source = settings;\n    context.live2dModel.once(\"modelLoaded\", (internalModel) => {\n      internalModel.once(\"destroy\", function() {\n        const objectURL = this.settings._objectURL;\n        URL.revokeObjectURL(objectURL);\n        if (_FileLoader.filesMap[objectURL]) {\n          for (const resourceObjectURL of Object.values(_FileLoader.filesMap[objectURL])) {\n            URL.revokeObjectURL(resourceObjectURL);\n          }\n        }\n        delete _FileLoader.filesMap[objectURL];\n      });\n    });\n  }\n  return next();\n});\nLive2DFactory.live2DModelMiddlewares.unshift(FileLoader.factory);\nconst _ZipLoader = class {\n  static unzip(reader, settings) {\n    return __async(this, null, function* () {\n      const filePaths = yield _ZipLoader.getFilePaths(reader);\n      const requiredFilePaths = [];\n      for (const definedFile of settings.getDefinedFiles()) {\n        const actualPath = decodeURI(_pixi_utils__WEBPACK_IMPORTED_MODULE_0__.url.resolve(settings.url, definedFile));\n        if (filePaths.includes(actualPath)) {\n          requiredFilePaths.push(actualPath);\n        }\n      }\n      const files = yield _ZipLoader.getFiles(reader, requiredFilePaths);\n      for (let i = 0; i < files.length; i++) {\n        const path = requiredFilePaths[i];\n        const file = files[i];\n        Object.defineProperty(file, \"webkitRelativePath\", {\n          value: path\n        });\n      }\n      return files;\n    });\n  }\n  static createSettings(reader) {\n    return __async(this, null, function* () {\n      const filePaths = yield _ZipLoader.getFilePaths(reader);\n      const settingsFilePath = filePaths.find((path) => path.endsWith(\"model.json\") || path.endsWith(\"model3.json\"));\n      if (!settingsFilePath) {\n        throw new Error(\"Settings file not found\");\n      }\n      const settingsText = yield _ZipLoader.readText(reader, settingsFilePath);\n      if (!settingsText) {\n        throw new Error(\"Empty settings file: \" + settingsFilePath);\n      }\n      const settingsJSON = JSON.parse(settingsText);\n      settingsJSON.url = settingsFilePath;\n      const runtime = Live2DFactory.findRuntime(settingsJSON);\n      if (!runtime) {\n        throw new Error(\"Unknown settings JSON\");\n      }\n      return runtime.createModelSettings(settingsJSON);\n    });\n  }\n  static zipReader(data, url2) {\n    return __async(this, null, function* () {\n      throw new Error(\"Not implemented\");\n    });\n  }\n  static getFilePaths(reader) {\n    return __async(this, null, function* () {\n      throw new Error(\"Not implemented\");\n    });\n  }\n  static getFiles(reader, paths) {\n    return __async(this, null, function* () {\n      throw new Error(\"Not implemented\");\n    });\n  }\n  static readText(reader, path) {\n    return __async(this, null, function* () {\n      throw new Error(\"Not implemented\");\n    });\n  }\n  static releaseReader(reader) {\n  }\n};\nlet ZipLoader = _ZipLoader;\nZipLoader.ZIP_PROTOCOL = \"zip://\";\nZipLoader.uid = 0;\nZipLoader.factory = (context, next) => __async(void 0, null, function* () {\n  const source = context.source;\n  let sourceURL;\n  let zipBlob;\n  let settings;\n  if (typeof source === \"string\" && (source.endsWith(\".zip\") || source.startsWith(_ZipLoader.ZIP_PROTOCOL))) {\n    if (source.startsWith(_ZipLoader.ZIP_PROTOCOL)) {\n      sourceURL = source.slice(_ZipLoader.ZIP_PROTOCOL.length);\n    } else {\n      sourceURL = source;\n    }\n    zipBlob = yield Live2DLoader.load({\n      url: sourceURL,\n      type: \"blob\",\n      target: context.live2dModel\n    });\n  } else if (Array.isArray(source) && source.length === 1 && source[0] instanceof File && source[0].name.endsWith(\".zip\")) {\n    zipBlob = source[0];\n    sourceURL = URL.createObjectURL(zipBlob);\n    settings = source.settings;\n  }\n  if (zipBlob) {\n    if (!zipBlob.size) {\n      throw new Error(\"Empty zip file\");\n    }\n    const reader = yield _ZipLoader.zipReader(zipBlob, sourceURL);\n    if (!settings) {\n      settings = yield _ZipLoader.createSettings(reader);\n    }\n    settings._objectURL = _ZipLoader.ZIP_PROTOCOL + _ZipLoader.uid + \"/\" + settings.url;\n    const files = yield _ZipLoader.unzip(reader, settings);\n    files.settings = settings;\n    context.source = files;\n    if (sourceURL.startsWith(\"blob:\")) {\n      context.live2dModel.once(\"modelLoaded\", (internalModel) => {\n        internalModel.once(\"destroy\", function() {\n          URL.revokeObjectURL(sourceURL);\n        });\n      });\n    }\n    _ZipLoader.releaseReader(reader);\n  }\n  return next();\n});\nLive2DFactory.live2DModelMiddlewares.unshift(ZipLoader.factory);\nif (!window.Live2DCubismCore) {\n  throw new Error(\"Could not find Cubism 4 runtime. This plugin requires live2dcubismcore.js to be loaded.\");\n}\nclass Cubism4ExpressionManager extends ExpressionManager {\n  constructor(settings, options) {\n    var _a;\n    super(settings, options);\n    this.queueManager = new CubismMotionQueueManager();\n    this.definitions = (_a = settings.expressions) != null ? _a : [];\n    this.init();\n  }\n  isFinished() {\n    return this.queueManager.isFinished();\n  }\n  getExpressionIndex(name) {\n    return this.definitions.findIndex((def) => def.Name === name);\n  }\n  getExpressionFile(definition) {\n    return definition.File;\n  }\n  createExpression(data, definition) {\n    return CubismExpressionMotion.create(data);\n  }\n  _setExpression(motion) {\n    return this.queueManager.startMotion(motion, false, performance.now());\n  }\n  stopAllExpressions() {\n    this.queueManager.stopAllMotions();\n  }\n  updateParameters(model, now) {\n    return this.queueManager.doUpdateMotion(model, now);\n  }\n}\nclass Cubism4ModelSettings extends ModelSettings {\n  constructor(json) {\n    super(json);\n    if (!Cubism4ModelSettings.isValidJSON(json)) {\n      throw new TypeError(\"Invalid JSON.\");\n    }\n    Object.assign(this, new CubismModelSettingsJson(json));\n  }\n  static isValidJSON(json) {\n    var _a;\n    return !!(json == null ? void 0 : json.FileReferences) && typeof json.FileReferences.Moc === \"string\" && ((_a = json.FileReferences.Textures) == null ? void 0 : _a.length) > 0 && json.FileReferences.Textures.every((item) => typeof item === \"string\");\n  }\n  replaceFiles(replace) {\n    super.replaceFiles(replace);\n    if (this.motions) {\n      for (const [group, motions] of Object.entries(this.motions)) {\n        for (let i = 0; i < motions.length; i++) {\n          motions[i].File = replace(motions[i].File, `motions.${group}[${i}].File`);\n          if (motions[i].Sound !== void 0) {\n            motions[i].Sound = replace(motions[i].Sound, `motions.${group}[${i}].Sound`);\n          }\n        }\n      }\n    }\n    if (this.expressions) {\n      for (let i = 0; i < this.expressions.length; i++) {\n        this.expressions[i].File = replace(this.expressions[i].File, `expressions[${i}].File`);\n      }\n    }\n  }\n}\napplyMixins(Cubism4ModelSettings, [CubismModelSettingsJson]);\nclass Cubism4MotionManager extends MotionManager {\n  constructor(settings, options) {\n    var _a;\n    super(settings, options);\n    this.groups = { idle: \"Idle\" };\n    this.motionDataType = \"json\";\n    this.queueManager = new CubismMotionQueueManager();\n    this.definitions = (_a = settings.motions) != null ? _a : {};\n    this.eyeBlinkIds = settings.getEyeBlinkParameters() || [];\n    this.lipSyncIds = settings.getLipSyncParameters() || [];\n    this.init(options);\n  }\n  init(options) {\n    super.init(options);\n    if (this.settings.expressions) {\n      this.expressionManager = new Cubism4ExpressionManager(this.settings, options);\n    }\n    this.queueManager.setEventCallback((caller, eventValue, customData) => {\n      this.emit(\"motion:\" + eventValue);\n    });\n  }\n  isFinished() {\n    return this.queueManager.isFinished();\n  }\n  _startMotion(motion, onFinish) {\n    motion.setFinishedMotionHandler(onFinish);\n    this.queueManager.stopAllMotions();\n    return this.queueManager.startMotion(motion, false, performance.now());\n  }\n  _stopAllMotions() {\n    this.queueManager.stopAllMotions();\n  }\n  createMotion(data, group, definition) {\n    const motion = CubismMotion.create(data);\n    const json = new CubismMotionJson(data);\n    const defaultFadingDuration = (group === this.groups.idle ? config.idleMotionFadingDuration : config.motionFadingDuration) / 1e3;\n    if (json.getMotionFadeInTime() === void 0) {\n      motion.setFadeInTime(definition.FadeInTime > 0 ? definition.FadeInTime : defaultFadingDuration);\n    }\n    if (json.getMotionFadeOutTime() === void 0) {\n      motion.setFadeOutTime(definition.FadeOutTime > 0 ? definition.FadeOutTime : defaultFadingDuration);\n    }\n    motion.setEffectIds(this.eyeBlinkIds, this.lipSyncIds);\n    return motion;\n  }\n  getMotionFile(definition) {\n    return definition.File;\n  }\n  getMotionName(definition) {\n    return definition.File;\n  }\n  getSoundFile(definition) {\n    return definition.Sound;\n  }\n  updateParameters(model, now) {\n    return this.queueManager.doUpdateMotion(model, now);\n  }\n  destroy() {\n    super.destroy();\n    this.queueManager.release();\n    this.queueManager = void 0;\n  }\n}\nconst tempMatrix = new CubismMatrix44();\nclass Cubism4InternalModel extends InternalModel {\n  constructor(coreModel, settings, options) {\n    super();\n    this.lipSync = true;\n    this.breath = CubismBreath.create();\n    this.renderer = new CubismRenderer_WebGL();\n    this.idParamAngleX = ParamAngleX;\n    this.idParamAngleY = ParamAngleY;\n    this.idParamAngleZ = ParamAngleZ;\n    this.idParamEyeBallX = ParamEyeBallX;\n    this.idParamEyeBallY = ParamEyeBallY;\n    this.idParamBodyAngleX = ParamBodyAngleX;\n    this.idParamBreath = ParamBreath;\n    this.pixelsPerUnit = 1;\n    this.centeringTransform = new _pixi_math__WEBPACK_IMPORTED_MODULE_1__.Matrix();\n    this.coreModel = coreModel;\n    this.settings = settings;\n    this.motionManager = new Cubism4MotionManager(settings, options);\n    this.init();\n  }\n  init() {\n    var _a;\n    super.init();\n    if (((_a = this.settings.getEyeBlinkParameters()) == null ? void 0 : _a.length) > 0) {\n      this.eyeBlink = CubismEyeBlink.create(this.settings);\n    }\n    this.breath.setParameters([\n      new BreathParameterData(this.idParamAngleX, 0, 15, 6.5345, 0.5),\n      new BreathParameterData(this.idParamAngleY, 0, 8, 3.5345, 0.5),\n      new BreathParameterData(this.idParamAngleZ, 0, 10, 5.5345, 0.5),\n      new BreathParameterData(this.idParamBodyAngleX, 0, 4, 15.5345, 0.5),\n      new BreathParameterData(this.idParamBreath, 0, 0.5, 3.2345, 0.5)\n    ]);\n    this.renderer.initialize(this.coreModel);\n    this.renderer.setIsPremultipliedAlpha(true);\n  }\n  getSize() {\n    return [this.coreModel.getModel().canvasinfo.CanvasWidth, this.coreModel.getModel().canvasinfo.CanvasHeight];\n  }\n  getLayout() {\n    const layout = {};\n    if (this.settings.layout) {\n      for (const key of Object.keys(this.settings.layout)) {\n        const commonKey = key.charAt(0).toLowerCase() + key.slice(1);\n        layout[commonKey] = this.settings.layout[key];\n      }\n    }\n    return layout;\n  }\n  setupLayout() {\n    super.setupLayout();\n    this.pixelsPerUnit = this.coreModel.getModel().canvasinfo.PixelsPerUnit;\n    this.centeringTransform.scale(this.pixelsPerUnit, this.pixelsPerUnit).translate(this.originalWidth / 2, this.originalHeight / 2);\n  }\n  updateWebGLContext(gl, glContextID) {\n    this.renderer.firstDraw = true;\n    this.renderer._bufferData = {\n      vertex: null,\n      uv: null,\n      index: null\n    };\n    this.renderer.startUp(gl);\n    this.renderer._clippingManager._currentFrameNo = glContextID;\n    this.renderer._clippingManager._maskTexture = void 0;\n    CubismShader_WebGL.getInstance()._shaderSets = [];\n  }\n  bindTexture(index, texture) {\n    this.renderer.bindTexture(index, texture);\n  }\n  getHitAreaDefs() {\n    var _a, _b;\n    return (_b = (_a = this.settings.hitAreas) == null ? void 0 : _a.map((hitArea) => ({\n      id: hitArea.Id,\n      name: hitArea.Name,\n      index: this.coreModel.getDrawableIndex(hitArea.Id)\n    }))) != null ? _b : [];\n  }\n  getDrawableIDs() {\n    return this.coreModel.getDrawableIds();\n  }\n  getDrawableIndex(id) {\n    return this.coreModel.getDrawableIndex(id);\n  }\n  getDrawableVertices(drawIndex) {\n    if (typeof drawIndex === \"string\") {\n      drawIndex = this.coreModel.getDrawableIndex(drawIndex);\n      if (drawIndex === -1)\n        throw new TypeError(\"Unable to find drawable ID: \" + drawIndex);\n    }\n    const arr = this.coreModel.getDrawableVertices(drawIndex).slice();\n    for (let i = 0; i < arr.length; i += 2) {\n      arr[i] = arr[i] * this.pixelsPerUnit + this.originalWidth / 2;\n      arr[i + 1] = -arr[i + 1] * this.pixelsPerUnit + this.originalHeight / 2;\n    }\n    return arr;\n  }\n  updateTransform(transform) {\n    this.drawingMatrix.copyFrom(this.centeringTransform).prepend(this.localTransform).prepend(transform);\n  }\n  update(dt, now) {\n    var _a, _b, _c, _d;\n    super.update(dt, now);\n    dt /= 1e3;\n    now /= 1e3;\n    const model = this.coreModel;\n    this.emit(\"beforeMotionUpdate\");\n    const motionUpdated = this.motionManager.update(this.coreModel, now);\n    this.emit(\"afterMotionUpdate\");\n    model.saveParameters();\n    (_a = this.motionManager.expressionManager) == null ? void 0 : _a.update(model, now);\n    if (!motionUpdated) {\n      (_b = this.eyeBlink) == null ? void 0 : _b.updateParameters(model, dt);\n    }\n    this.updateFocus();\n    this.updateNaturalMovements(dt * 1e3, now * 1e3);\n    (_c = this.physics) == null ? void 0 : _c.evaluate(model, dt);\n    (_d = this.pose) == null ? void 0 : _d.updateParameters(model, dt);\n    this.emit(\"beforeModelUpdate\");\n    model.update();\n    model.loadParameters();\n  }\n  updateFocus() {\n    this.coreModel.addParameterValueById(this.idParamEyeBallX, this.focusController.x);\n    this.coreModel.addParameterValueById(this.idParamEyeBallY, this.focusController.y);\n    this.coreModel.addParameterValueById(this.idParamAngleX, this.focusController.x * 30);\n    this.coreModel.addParameterValueById(this.idParamAngleY, this.focusController.y * 30);\n    this.coreModel.addParameterValueById(this.idParamAngleZ, this.focusController.x * this.focusController.y * -30);\n    this.coreModel.addParameterValueById(this.idParamBodyAngleX, this.focusController.x * 10);\n  }\n  updateNaturalMovements(dt, now) {\n    var _a;\n    (_a = this.breath) == null ? void 0 : _a.updateParameters(this.coreModel, dt / 1e3);\n  }\n  draw(gl) {\n    const matrix = this.drawingMatrix;\n    const array = tempMatrix.getArray();\n    array[0] = matrix.a;\n    array[1] = matrix.b;\n    array[4] = -matrix.c;\n    array[5] = -matrix.d;\n    array[12] = matrix.tx;\n    array[13] = matrix.ty;\n    this.renderer.setMvpMatrix(tempMatrix);\n    this.renderer.setRenderState(gl.getParameter(gl.FRAMEBUFFER_BINDING), this.viewport);\n    this.renderer.drawModel();\n  }\n  destroy() {\n    super.destroy();\n    this.renderer.release();\n    this.coreModel.release();\n    this.renderer = void 0;\n    this.coreModel = void 0;\n  }\n}\nlet startupPromise;\nlet startupRetries = 20;\nfunction cubism4Ready() {\n  if (CubismFramework.isStarted()) {\n    return Promise.resolve();\n  }\n  startupPromise != null ? startupPromise : startupPromise = new Promise((resolve, reject) => {\n    function startUpWithRetry() {\n      try {\n        startUpCubism4();\n        resolve();\n      } catch (e) {\n        startupRetries--;\n        if (startupRetries < 0) {\n          const err = new Error(\"Failed to start up Cubism 4 framework.\");\n          err.cause = e;\n          reject(err);\n          return;\n        }\n        logger.log(\"Cubism4\", \"Startup failed, retrying 10ms later...\");\n        setTimeout(startUpWithRetry, 10);\n      }\n    }\n    startUpWithRetry();\n  });\n  return startupPromise;\n}\nfunction startUpCubism4(options) {\n  options = Object.assign({\n    logFunction: console.log,\n    loggingLevel: LogLevel.LogLevel_Verbose\n  }, options);\n  CubismFramework.startUp(options);\n  CubismFramework.initialize();\n}\nLive2DFactory.registerRuntime({\n  version: 4,\n  ready: cubism4Ready,\n  test(source) {\n    return source instanceof Cubism4ModelSettings || Cubism4ModelSettings.isValidJSON(source);\n  },\n  isValidMoc(modelData) {\n    if (modelData.byteLength < 4) {\n      return false;\n    }\n    const view = new Int8Array(modelData, 0, 4);\n    return String.fromCharCode(...view) === \"MOC3\";\n  },\n  createModelSettings(json) {\n    return new Cubism4ModelSettings(json);\n  },\n  createCoreModel(data) {\n    const moc = CubismMoc.create(data);\n    try {\n      const model = moc.createModel();\n      model.__moc = moc;\n      return model;\n    } catch (e) {\n      try {\n        moc.release();\n      } catch (ignored) {\n      }\n      throw e;\n    }\n  },\n  createInternalModel(coreModel, settings, options) {\n    const model = new Cubism4InternalModel(coreModel, settings, options);\n    const coreModelWithMoc = coreModel;\n    if (coreModelWithMoc.__moc) {\n      model.__moc = coreModelWithMoc.__moc;\n      delete coreModelWithMoc.__moc;\n      model.once(\"destroy\", releaseMoc);\n    }\n    return model;\n  },\n  createPhysics(coreModel, data) {\n    return CubismPhysics.create(data);\n  },\n  createPose(coreModel, data) {\n    return CubismPose.create(data);\n  }\n});\nfunction releaseMoc() {\n  var _a;\n  (_a = this.__moc) == null ? void 0 : _a.release();\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGl4aS1saXZlMmQtZGlzcGxheS9kaXN0L2N1YmlzbTQuZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNnRDtBQUN1QjtBQUNsQztBQUNLO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUNBQW1DO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0JBQWdCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isc0JBQXNCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1QkFBdUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtDQUFrQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtDQUFrQztBQUN0RDtBQUNBLCtCQUErQiw2QkFBNkI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQ0FBcUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0NBQXNDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQ0FBaUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlDQUFpQztBQUM5RDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLHNCQUFzQixPQUFPO0FBQzdCLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsdUJBQXVCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEVBQUUsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQkFBZ0I7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsTUFBTTtBQUMxQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixHQUFHO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMEJBQTBCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLCtCQUErQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlDQUFpQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJCQUEyQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLCtCQUErQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLCtCQUErQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx1QkFBdUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELEVBQUU7QUFDdEQ7QUFDQTtBQUNBLG1EQUFtRCxFQUFFO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0R0FBNEc7QUFDNUg7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0hBQWdIO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDREQUE0RDtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJEQUEyRDtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNERBQTREO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyREFBMkQ7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrSEFBa0g7QUFDN0g7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlDQUFpQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlDQUFpQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlDQUFpQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlDQUFpQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSwyQ0FBMkMscUNBQXFDO0FBQ2hGLDZDQUE2QywyQ0FBMkM7QUFDeEYsMkNBQTJDLHFDQUFxQztBQUNoRjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMENBQTBDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsK0RBQStEO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msc0NBQXNDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlDQUFpQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywrQkFBK0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDZDQUE2QztBQUM1RSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLCtCQUErQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxnQ0FBZ0M7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0NBQWtDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDZDQUE2QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtDQUFrQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHlDQUF5QztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkNBQTZDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscURBQXFEO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixxREFBcUQ7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkNBQTZDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtCQUErQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixvREFBb0QsRUFBRTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxFQUFFO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxHQUFHO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsbUJBQW1CO0FBQ3BCLGdFQUFnRSw4QkFBOEIsOEJBQThCLDJCQUEyQixnQ0FBZ0MsZUFBZSwyQ0FBMkMsdUNBQXVDLDJCQUEyQixtQ0FBbUM7QUFDdFYsNERBQTRELDhCQUE4QiwyQkFBMkIsK0JBQStCLGlDQUFpQyw4QkFBOEIsZUFBZSx1TkFBdU4sK0VBQStFO0FBQ3hnQix1REFBdUQsOEJBQThCLDhCQUE4Qiw0QkFBNEIsZUFBZSx1Q0FBdUMsMkJBQTJCLG1DQUFtQztBQUNuUSw2REFBNkQsOEJBQThCLDhCQUE4Qiw2QkFBNkIsNEJBQTRCLGdDQUFnQyxlQUFlLHVDQUF1Qyx5Q0FBeUMsMkJBQTJCLG1DQUFtQztBQUMvVyxxRUFBcUUsOEJBQThCLCtCQUErQiw4QkFBOEIsZUFBZSxpRUFBaUU7QUFDaFAseUVBQXlFLDhCQUE4Qiw2QkFBNkIsK0JBQStCLGlDQUFpQyw4QkFBOEIsOEJBQThCLGVBQWUsdUVBQXVFLDZGQUE2RixxRUFBcUUsdUNBQXVDLDRCQUE0QjtBQUMzakIsaUZBQWlGLHdCQUF3Qix1QkFBdUIsNkJBQTZCLDZCQUE2QiwyQkFBMkIseUJBQXlCLFlBQVksbUVBQW1FLDBGQUEwRixrRUFBa0UsNENBQTRDLDRCQUE0QjtBQUNqaUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsSUFBSTtBQUMxQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsdUJBQXVCLElBQUk7QUFDM0I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHdCQUF3QixJQUFJO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFEQUFZO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELE1BQU07QUFDaEU7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELE1BQU07QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZCQUE2QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDRDQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QyxnRUFBZ0UsRUFBRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxhQUFhO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNCQUFzQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWUsYUFBYTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsK0NBQStDLEtBQUs7QUFDcEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsVUFBVTtBQUNoRTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw2QkFBNkI7QUFDOUIsNEJBQTRCLHFEQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9DQUFvQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsTUFBTSxJQUFJLE1BQU07QUFDdEU7QUFDQTtBQUNBO0FBQ0EseURBQXlELE1BQU0sSUFBSSxNQUFNO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiw0QkFBNEIscURBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsOENBQU07QUFDcEMsNkJBQTZCLDhDQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxrQkFBa0IsVUFBVSxXQUFXLEtBQUssS0FBSztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLDJCQUEyQixtQkFBbUI7QUFDOUMsTUFBTSwrQ0FBTztBQUNiLFdBQVcsK0NBQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQkFBa0IsK0NBQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwQ0FBMEM7QUFDN0UsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxpRUFBaUU7QUFDakU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTixrRUFBa0UsTUFBTSxJQUFJLE1BQU07QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOLDBFQUEwRSxNQUFNO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlEQUFTO0FBQ3ZDO0FBQ0Esc0JBQXNCLDZDQUFLO0FBQzNCLHlCQUF5Qiw4Q0FBTTtBQUMvQjtBQUNBLDBCQUEwQixvREFBUztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVEQUFlO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUNBQWlDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw0Q0FBRztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsNENBQUc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QyxnRUFBZ0UsTUFBTSxHQUFHLEVBQUU7QUFDM0U7QUFDQSxvRUFBb0UsTUFBTSxHQUFHLEVBQUU7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw2QkFBNkI7QUFDbkQsb0ZBQW9GLEVBQUU7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsOENBQU07QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDaWlGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWl2YS1zdHVkaW8vLi9ub2RlX21vZHVsZXMvcGl4aS1saXZlMmQtZGlzcGxheS9kaXN0L2N1YmlzbTQuZXMuanM/YzRkNCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19wb3cgPSBNYXRoLnBvdztcbnZhciBfX2FzeW5jID0gKF9fdGhpcywgX19hcmd1bWVudHMsIGdlbmVyYXRvcikgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHZhciBmdWxmaWxsZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlamVjdGVkID0gKHZhbHVlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGVwKGdlbmVyYXRvci50aHJvdyh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgc3RlcCA9ICh4KSA9PiB4LmRvbmUgPyByZXNvbHZlKHgudmFsdWUpIDogUHJvbWlzZS5yZXNvbHZlKHgudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KF9fdGhpcywgX19hcmd1bWVudHMpKS5uZXh0KCkpO1xuICB9KTtcbn07XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIsIHVybCB9IGZyb20gXCJAcGl4aS91dGlsc1wiO1xuaW1wb3J0IHsgTWF0cml4LCBUcmFuc2Zvcm0sIFBvaW50LCBPYnNlcnZhYmxlUG9pbnQgfSBmcm9tIFwiQHBpeGkvbWF0aFwiO1xuaW1wb3J0IHsgVGV4dHVyZSB9IGZyb20gXCJAcGl4aS9jb3JlXCI7XG5pbXBvcnQgeyBDb250YWluZXIgfSBmcm9tIFwiQHBpeGkvZGlzcGxheVwiO1xuY2xhc3MgQ3ViaXNtQnJlYXRoIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fYnJlYXRoUGFyYW1ldGVycyA9IFtdO1xuICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gMDtcbiAgfVxuICBzdGF0aWMgY3JlYXRlKCkge1xuICAgIHJldHVybiBuZXcgQ3ViaXNtQnJlYXRoKCk7XG4gIH1cbiAgc2V0UGFyYW1ldGVycyhicmVhdGhQYXJhbWV0ZXJzKSB7XG4gICAgdGhpcy5fYnJlYXRoUGFyYW1ldGVycyA9IGJyZWF0aFBhcmFtZXRlcnM7XG4gIH1cbiAgZ2V0UGFyYW1ldGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5fYnJlYXRoUGFyYW1ldGVycztcbiAgfVxuICB1cGRhdGVQYXJhbWV0ZXJzKG1vZGVsLCBkZWx0YVRpbWVTZWNvbmRzKSB7XG4gICAgdGhpcy5fY3VycmVudFRpbWUgKz0gZGVsdGFUaW1lU2Vjb25kcztcbiAgICBjb25zdCB0ID0gdGhpcy5fY3VycmVudFRpbWUgKiAyICogMy4xNDE1OTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2JyZWF0aFBhcmFtZXRlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9icmVhdGhQYXJhbWV0ZXJzW2ldO1xuICAgICAgbW9kZWwuYWRkUGFyYW1ldGVyVmFsdWVCeUlkKGRhdGEucGFyYW1ldGVySWQsIGRhdGEub2Zmc2V0ICsgZGF0YS5wZWFrICogTWF0aC5zaW4odCAvIGRhdGEuY3ljbGUpLCBkYXRhLndlaWdodCk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBCcmVhdGhQYXJhbWV0ZXJEYXRhIHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVySWQsIG9mZnNldCwgcGVhaywgY3ljbGUsIHdlaWdodCkge1xuICAgIHRoaXMucGFyYW1ldGVySWQgPSBwYXJhbWV0ZXJJZCA9PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbWV0ZXJJZDtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldCA9PSB2b2lkIDAgPyAwIDogb2Zmc2V0O1xuICAgIHRoaXMucGVhayA9IHBlYWsgPT0gdm9pZCAwID8gMCA6IHBlYWs7XG4gICAgdGhpcy5jeWNsZSA9IGN5Y2xlID09IHZvaWQgMCA/IDAgOiBjeWNsZTtcbiAgICB0aGlzLndlaWdodCA9IHdlaWdodCA9PSB2b2lkIDAgPyAwIDogd2VpZ2h0O1xuICB9XG59XG5jb25zdCBfQ3ViaXNtRXllQmxpbmsgPSBjbGFzcyB7XG4gIHN0YXRpYyBjcmVhdGUobW9kZWxTZXR0aW5nKSB7XG4gICAgcmV0dXJuIG5ldyBfQ3ViaXNtRXllQmxpbmsobW9kZWxTZXR0aW5nKTtcbiAgfVxuICBzZXRCbGlua2luZ0ludGVydmFsKGJsaW5raW5nSW50ZXJ2YWwpIHtcbiAgICB0aGlzLl9ibGlua2luZ0ludGVydmFsU2Vjb25kcyA9IGJsaW5raW5nSW50ZXJ2YWw7XG4gIH1cbiAgc2V0QmxpbmtpbmdTZXR0aW5nKGNsb3NpbmcsIGNsb3NlZCwgb3BlbmluZykge1xuICAgIHRoaXMuX2Nsb3NpbmdTZWNvbmRzID0gY2xvc2luZztcbiAgICB0aGlzLl9jbG9zZWRTZWNvbmRzID0gY2xvc2VkO1xuICAgIHRoaXMuX29wZW5pbmdTZWNvbmRzID0gb3BlbmluZztcbiAgfVxuICBzZXRQYXJhbWV0ZXJJZHMocGFyYW1ldGVySWRzKSB7XG4gICAgdGhpcy5fcGFyYW1ldGVySWRzID0gcGFyYW1ldGVySWRzO1xuICB9XG4gIGdldFBhcmFtZXRlcklkcygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyYW1ldGVySWRzO1xuICB9XG4gIHVwZGF0ZVBhcmFtZXRlcnMobW9kZWwsIGRlbHRhVGltZVNlY29uZHMpIHtcbiAgICB0aGlzLl91c2VyVGltZVNlY29uZHMgKz0gZGVsdGFUaW1lU2Vjb25kcztcbiAgICBsZXQgcGFyYW1ldGVyVmFsdWU7XG4gICAgbGV0IHQgPSAwO1xuICAgIHN3aXRjaCAodGhpcy5fYmxpbmtpbmdTdGF0ZSkge1xuICAgICAgY2FzZSBFeWVTdGF0ZS5FeWVTdGF0ZV9DbG9zaW5nOlxuICAgICAgICB0ID0gKHRoaXMuX3VzZXJUaW1lU2Vjb25kcyAtIHRoaXMuX3N0YXRlU3RhcnRUaW1lU2Vjb25kcykgLyB0aGlzLl9jbG9zaW5nU2Vjb25kcztcbiAgICAgICAgaWYgKHQgPj0gMSkge1xuICAgICAgICAgIHQgPSAxO1xuICAgICAgICAgIHRoaXMuX2JsaW5raW5nU3RhdGUgPSBFeWVTdGF0ZS5FeWVTdGF0ZV9DbG9zZWQ7XG4gICAgICAgICAgdGhpcy5fc3RhdGVTdGFydFRpbWVTZWNvbmRzID0gdGhpcy5fdXNlclRpbWVTZWNvbmRzO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtZXRlclZhbHVlID0gMSAtIHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFeWVTdGF0ZS5FeWVTdGF0ZV9DbG9zZWQ6XG4gICAgICAgIHQgPSAodGhpcy5fdXNlclRpbWVTZWNvbmRzIC0gdGhpcy5fc3RhdGVTdGFydFRpbWVTZWNvbmRzKSAvIHRoaXMuX2Nsb3NlZFNlY29uZHM7XG4gICAgICAgIGlmICh0ID49IDEpIHtcbiAgICAgICAgICB0aGlzLl9ibGlua2luZ1N0YXRlID0gRXllU3RhdGUuRXllU3RhdGVfT3BlbmluZztcbiAgICAgICAgICB0aGlzLl9zdGF0ZVN0YXJ0VGltZVNlY29uZHMgPSB0aGlzLl91c2VyVGltZVNlY29uZHM7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1ldGVyVmFsdWUgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXllU3RhdGUuRXllU3RhdGVfT3BlbmluZzpcbiAgICAgICAgdCA9ICh0aGlzLl91c2VyVGltZVNlY29uZHMgLSB0aGlzLl9zdGF0ZVN0YXJ0VGltZVNlY29uZHMpIC8gdGhpcy5fb3BlbmluZ1NlY29uZHM7XG4gICAgICAgIGlmICh0ID49IDEpIHtcbiAgICAgICAgICB0ID0gMTtcbiAgICAgICAgICB0aGlzLl9ibGlua2luZ1N0YXRlID0gRXllU3RhdGUuRXllU3RhdGVfSW50ZXJ2YWw7XG4gICAgICAgICAgdGhpcy5fbmV4dEJsaW5raW5nVGltZSA9IHRoaXMuZGV0ZXJtaW5OZXh0QmxpbmtpbmdUaW1pbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbWV0ZXJWYWx1ZSA9IHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFeWVTdGF0ZS5FeWVTdGF0ZV9JbnRlcnZhbDpcbiAgICAgICAgaWYgKHRoaXMuX25leHRCbGlua2luZ1RpbWUgPCB0aGlzLl91c2VyVGltZVNlY29uZHMpIHtcbiAgICAgICAgICB0aGlzLl9ibGlua2luZ1N0YXRlID0gRXllU3RhdGUuRXllU3RhdGVfQ2xvc2luZztcbiAgICAgICAgICB0aGlzLl9zdGF0ZVN0YXJ0VGltZVNlY29uZHMgPSB0aGlzLl91c2VyVGltZVNlY29uZHM7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1ldGVyVmFsdWUgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRXllU3RhdGUuRXllU3RhdGVfRmlyc3Q6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLl9ibGlua2luZ1N0YXRlID0gRXllU3RhdGUuRXllU3RhdGVfSW50ZXJ2YWw7XG4gICAgICAgIHRoaXMuX25leHRCbGlua2luZ1RpbWUgPSB0aGlzLmRldGVybWluTmV4dEJsaW5raW5nVGltaW5nKCk7XG4gICAgICAgIHBhcmFtZXRlclZhbHVlID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICghX0N1YmlzbUV5ZUJsaW5rLkNsb3NlSWZaZXJvKSB7XG4gICAgICBwYXJhbWV0ZXJWYWx1ZSA9IC1wYXJhbWV0ZXJWYWx1ZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9wYXJhbWV0ZXJJZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIG1vZGVsLnNldFBhcmFtZXRlclZhbHVlQnlJZCh0aGlzLl9wYXJhbWV0ZXJJZHNbaV0sIHBhcmFtZXRlclZhbHVlKTtcbiAgICB9XG4gIH1cbiAgY29uc3RydWN0b3IobW9kZWxTZXR0aW5nKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB0aGlzLl9ibGlua2luZ1N0YXRlID0gRXllU3RhdGUuRXllU3RhdGVfRmlyc3Q7XG4gICAgdGhpcy5fbmV4dEJsaW5raW5nVGltZSA9IDA7XG4gICAgdGhpcy5fc3RhdGVTdGFydFRpbWVTZWNvbmRzID0gMDtcbiAgICB0aGlzLl9ibGlua2luZ0ludGVydmFsU2Vjb25kcyA9IDQ7XG4gICAgdGhpcy5fY2xvc2luZ1NlY29uZHMgPSAwLjE7XG4gICAgdGhpcy5fY2xvc2VkU2Vjb25kcyA9IDAuMDU7XG4gICAgdGhpcy5fb3BlbmluZ1NlY29uZHMgPSAwLjE1O1xuICAgIHRoaXMuX3VzZXJUaW1lU2Vjb25kcyA9IDA7XG4gICAgdGhpcy5fcGFyYW1ldGVySWRzID0gW107XG4gICAgaWYgKG1vZGVsU2V0dGluZyA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3BhcmFtZXRlcklkcyA9IChfYiA9IChfYSA9IG1vZGVsU2V0dGluZy5nZXRFeWVCbGlua1BhcmFtZXRlcnMoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNsaWNlKCkpICE9IG51bGwgPyBfYiA6IHRoaXMuX3BhcmFtZXRlcklkcztcbiAgfVxuICBkZXRlcm1pbk5leHRCbGlua2luZ1RpbWluZygpIHtcbiAgICBjb25zdCByID0gTWF0aC5yYW5kb20oKTtcbiAgICByZXR1cm4gdGhpcy5fdXNlclRpbWVTZWNvbmRzICsgciAqICgyICogdGhpcy5fYmxpbmtpbmdJbnRlcnZhbFNlY29uZHMgLSAxKTtcbiAgfVxufTtcbmxldCBDdWJpc21FeWVCbGluayA9IF9DdWJpc21FeWVCbGluaztcbkN1YmlzbUV5ZUJsaW5rLkNsb3NlSWZaZXJvID0gdHJ1ZTtcbnZhciBFeWVTdGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEV5ZVN0YXRlMikgPT4ge1xuICBFeWVTdGF0ZTJbRXllU3RhdGUyW1wiRXllU3RhdGVfRmlyc3RcIl0gPSAwXSA9IFwiRXllU3RhdGVfRmlyc3RcIjtcbiAgRXllU3RhdGUyW0V5ZVN0YXRlMltcIkV5ZVN0YXRlX0ludGVydmFsXCJdID0gMV0gPSBcIkV5ZVN0YXRlX0ludGVydmFsXCI7XG4gIEV5ZVN0YXRlMltFeWVTdGF0ZTJbXCJFeWVTdGF0ZV9DbG9zaW5nXCJdID0gMl0gPSBcIkV5ZVN0YXRlX0Nsb3NpbmdcIjtcbiAgRXllU3RhdGUyW0V5ZVN0YXRlMltcIkV5ZVN0YXRlX0Nsb3NlZFwiXSA9IDNdID0gXCJFeWVTdGF0ZV9DbG9zZWRcIjtcbiAgRXllU3RhdGUyW0V5ZVN0YXRlMltcIkV5ZVN0YXRlX09wZW5pbmdcIl0gPSA0XSA9IFwiRXllU3RhdGVfT3BlbmluZ1wiO1xuICByZXR1cm4gRXllU3RhdGUyO1xufSkoRXllU3RhdGUgfHwge30pO1xuY29uc3QgRXBzaWxvbiA9IDFlLTM7XG5jb25zdCBEZWZhdWx0RmFkZUluU2Vjb25kcyA9IDAuNTtcbmNsYXNzIEN1YmlzbVBvc2Uge1xuICBzdGF0aWMgY3JlYXRlKHBvc2UzanNvbikge1xuICAgIGNvbnN0IHJldCA9IG5ldyBDdWJpc21Qb3NlKCk7XG4gICAgaWYgKHR5cGVvZiBwb3NlM2pzb24uRmFkZUluVGltZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0Ll9mYWRlVGltZVNlY29uZHMgPSBwb3NlM2pzb24uRmFkZUluVGltZTtcbiAgICAgIGlmIChyZXQuX2ZhZGVUaW1lU2Vjb25kcyA8PSAwKSB7XG4gICAgICAgIHJldC5fZmFkZVRpbWVTZWNvbmRzID0gRGVmYXVsdEZhZGVJblNlY29uZHM7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBvc2VMaXN0SW5mbyA9IHBvc2UzanNvbi5Hcm91cHM7XG4gICAgY29uc3QgcG9zZUNvdW50ID0gcG9zZUxpc3RJbmZvLmxlbmd0aDtcbiAgICBmb3IgKGxldCBwb3NlSW5kZXggPSAwOyBwb3NlSW5kZXggPCBwb3NlQ291bnQ7ICsrcG9zZUluZGV4KSB7XG4gICAgICBjb25zdCBpZExpc3RJbmZvID0gcG9zZUxpc3RJbmZvW3Bvc2VJbmRleF07XG4gICAgICBjb25zdCBpZENvdW50ID0gaWRMaXN0SW5mby5sZW5ndGg7XG4gICAgICBsZXQgZ3JvdXBDb3VudCA9IDA7XG4gICAgICBmb3IgKGxldCBncm91cEluZGV4ID0gMDsgZ3JvdXBJbmRleCA8IGlkQ291bnQ7ICsrZ3JvdXBJbmRleCkge1xuICAgICAgICBjb25zdCBwYXJ0SW5mbyA9IGlkTGlzdEluZm9bZ3JvdXBJbmRleF07XG4gICAgICAgIGNvbnN0IHBhcnREYXRhID0gbmV3IFBhcnREYXRhKCk7XG4gICAgICAgIHBhcnREYXRhLnBhcnRJZCA9IHBhcnRJbmZvLklkO1xuICAgICAgICBjb25zdCBsaW5rTGlzdEluZm8gPSBwYXJ0SW5mby5MaW5rO1xuICAgICAgICBpZiAobGlua0xpc3RJbmZvKSB7XG4gICAgICAgICAgY29uc3QgbGlua0NvdW50ID0gbGlua0xpc3RJbmZvLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKGxldCBsaW5rSW5kZXggPSAwOyBsaW5rSW5kZXggPCBsaW5rQ291bnQ7ICsrbGlua0luZGV4KSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rUGFydCA9IG5ldyBQYXJ0RGF0YSgpO1xuICAgICAgICAgICAgbGlua1BhcnQucGFydElkID0gbGlua0xpc3RJbmZvW2xpbmtJbmRleF07XG4gICAgICAgICAgICBwYXJ0RGF0YS5saW5rLnB1c2gobGlua1BhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXQuX3BhcnRHcm91cHMucHVzaChwYXJ0RGF0YSk7XG4gICAgICAgICsrZ3JvdXBDb3VudDtcbiAgICAgIH1cbiAgICAgIHJldC5fcGFydEdyb3VwQ291bnRzLnB1c2goZ3JvdXBDb3VudCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgdXBkYXRlUGFyYW1ldGVycyhtb2RlbCwgZGVsdGFUaW1lU2Vjb25kcykge1xuICAgIGlmIChtb2RlbCAhPSB0aGlzLl9sYXN0TW9kZWwpIHtcbiAgICAgIHRoaXMucmVzZXQobW9kZWwpO1xuICAgIH1cbiAgICB0aGlzLl9sYXN0TW9kZWwgPSBtb2RlbDtcbiAgICBpZiAoZGVsdGFUaW1lU2Vjb25kcyA8IDApIHtcbiAgICAgIGRlbHRhVGltZVNlY29uZHMgPSAwO1xuICAgIH1cbiAgICBsZXQgYmVnaW5JbmRleCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9wYXJ0R3JvdXBDb3VudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcnRHcm91cENvdW50ID0gdGhpcy5fcGFydEdyb3VwQ291bnRzW2ldO1xuICAgICAgdGhpcy5kb0ZhZGUobW9kZWwsIGRlbHRhVGltZVNlY29uZHMsIGJlZ2luSW5kZXgsIHBhcnRHcm91cENvdW50KTtcbiAgICAgIGJlZ2luSW5kZXggKz0gcGFydEdyb3VwQ291bnQ7XG4gICAgfVxuICAgIHRoaXMuY29weVBhcnRPcGFjaXRpZXMobW9kZWwpO1xuICB9XG4gIHJlc2V0KG1vZGVsKSB7XG4gICAgbGV0IGJlZ2luSW5kZXggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcGFydEdyb3VwQ291bnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBncm91cENvdW50ID0gdGhpcy5fcGFydEdyb3VwQ291bnRzW2ldO1xuICAgICAgZm9yIChsZXQgaiA9IGJlZ2luSW5kZXg7IGogPCBiZWdpbkluZGV4ICsgZ3JvdXBDb3VudDsgKytqKSB7XG4gICAgICAgIHRoaXMuX3BhcnRHcm91cHNbal0uaW5pdGlhbGl6ZShtb2RlbCk7XG4gICAgICAgIGNvbnN0IHBhcnRzSW5kZXggPSB0aGlzLl9wYXJ0R3JvdXBzW2pdLnBhcnRJbmRleDtcbiAgICAgICAgY29uc3QgcGFyYW1JbmRleCA9IHRoaXMuX3BhcnRHcm91cHNbal0ucGFyYW1ldGVySW5kZXg7XG4gICAgICAgIGlmIChwYXJ0c0luZGV4IDwgMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG1vZGVsLnNldFBhcnRPcGFjaXR5QnlJbmRleChwYXJ0c0luZGV4LCBqID09IGJlZ2luSW5kZXggPyAxIDogMCk7XG4gICAgICAgIG1vZGVsLnNldFBhcmFtZXRlclZhbHVlQnlJbmRleChwYXJhbUluZGV4LCBqID09IGJlZ2luSW5kZXggPyAxIDogMCk7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdGhpcy5fcGFydEdyb3Vwc1tqXS5saW5rLmxlbmd0aDsgKytrKSB7XG4gICAgICAgICAgdGhpcy5fcGFydEdyb3Vwc1tqXS5saW5rW2tdLmluaXRpYWxpemUobW9kZWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBiZWdpbkluZGV4ICs9IGdyb3VwQ291bnQ7XG4gICAgfVxuICB9XG4gIGNvcHlQYXJ0T3BhY2l0aWVzKG1vZGVsKSB7XG4gICAgZm9yIChsZXQgZ3JvdXBJbmRleCA9IDA7IGdyb3VwSW5kZXggPCB0aGlzLl9wYXJ0R3JvdXBzLmxlbmd0aDsgKytncm91cEluZGV4KSB7XG4gICAgICBjb25zdCBwYXJ0RGF0YSA9IHRoaXMuX3BhcnRHcm91cHNbZ3JvdXBJbmRleF07XG4gICAgICBpZiAocGFydERhdGEubGluay5sZW5ndGggPT0gMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcnRJbmRleCA9IHRoaXMuX3BhcnRHcm91cHNbZ3JvdXBJbmRleF0ucGFydEluZGV4O1xuICAgICAgY29uc3Qgb3BhY2l0eSA9IG1vZGVsLmdldFBhcnRPcGFjaXR5QnlJbmRleChwYXJ0SW5kZXgpO1xuICAgICAgZm9yIChsZXQgbGlua0luZGV4ID0gMDsgbGlua0luZGV4IDwgcGFydERhdGEubGluay5sZW5ndGg7ICsrbGlua0luZGV4KSB7XG4gICAgICAgIGNvbnN0IGxpbmtQYXJ0ID0gcGFydERhdGEubGlua1tsaW5rSW5kZXhdO1xuICAgICAgICBjb25zdCBsaW5rUGFydEluZGV4ID0gbGlua1BhcnQucGFydEluZGV4O1xuICAgICAgICBpZiAobGlua1BhcnRJbmRleCA8IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBtb2RlbC5zZXRQYXJ0T3BhY2l0eUJ5SW5kZXgobGlua1BhcnRJbmRleCwgb3BhY2l0eSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRvRmFkZShtb2RlbCwgZGVsdGFUaW1lU2Vjb25kcywgYmVnaW5JbmRleCwgcGFydEdyb3VwQ291bnQpIHtcbiAgICBsZXQgdmlzaWJsZVBhcnRJbmRleCA9IC0xO1xuICAgIGxldCBuZXdPcGFjaXR5ID0gMTtcbiAgICBjb25zdCBwaGkgPSAwLjU7XG4gICAgY29uc3QgYmFja09wYWNpdHlUaHJlc2hvbGQgPSAwLjE1O1xuICAgIGZvciAobGV0IGkgPSBiZWdpbkluZGV4OyBpIDwgYmVnaW5JbmRleCArIHBhcnRHcm91cENvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IHBhcnRJbmRleCA9IHRoaXMuX3BhcnRHcm91cHNbaV0ucGFydEluZGV4O1xuICAgICAgY29uc3QgcGFyYW1JbmRleCA9IHRoaXMuX3BhcnRHcm91cHNbaV0ucGFyYW1ldGVySW5kZXg7XG4gICAgICBpZiAobW9kZWwuZ2V0UGFyYW1ldGVyVmFsdWVCeUluZGV4KHBhcmFtSW5kZXgpID4gRXBzaWxvbikge1xuICAgICAgICBpZiAodmlzaWJsZVBhcnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmlzaWJsZVBhcnRJbmRleCA9IGk7XG4gICAgICAgIG5ld09wYWNpdHkgPSBtb2RlbC5nZXRQYXJ0T3BhY2l0eUJ5SW5kZXgocGFydEluZGV4KTtcbiAgICAgICAgbmV3T3BhY2l0eSArPSBkZWx0YVRpbWVTZWNvbmRzIC8gdGhpcy5fZmFkZVRpbWVTZWNvbmRzO1xuICAgICAgICBpZiAobmV3T3BhY2l0eSA+IDEpIHtcbiAgICAgICAgICBuZXdPcGFjaXR5ID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmlzaWJsZVBhcnRJbmRleCA8IDApIHtcbiAgICAgIHZpc2libGVQYXJ0SW5kZXggPSAwO1xuICAgICAgbmV3T3BhY2l0eSA9IDE7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBiZWdpbkluZGV4OyBpIDwgYmVnaW5JbmRleCArIHBhcnRHcm91cENvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IHBhcnRzSW5kZXggPSB0aGlzLl9wYXJ0R3JvdXBzW2ldLnBhcnRJbmRleDtcbiAgICAgIGlmICh2aXNpYmxlUGFydEluZGV4ID09IGkpIHtcbiAgICAgICAgbW9kZWwuc2V0UGFydE9wYWNpdHlCeUluZGV4KHBhcnRzSW5kZXgsIG5ld09wYWNpdHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IG9wYWNpdHkgPSBtb2RlbC5nZXRQYXJ0T3BhY2l0eUJ5SW5kZXgocGFydHNJbmRleCk7XG4gICAgICAgIGxldCBhMTtcbiAgICAgICAgaWYgKG5ld09wYWNpdHkgPCBwaGkpIHtcbiAgICAgICAgICBhMSA9IG5ld09wYWNpdHkgKiAocGhpIC0gMSkgLyBwaGkgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGExID0gKDEgLSBuZXdPcGFjaXR5KSAqIHBoaSAvICgxIC0gcGhpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYWNrT3BhY2l0eSA9ICgxIC0gYTEpICogKDEgLSBuZXdPcGFjaXR5KTtcbiAgICAgICAgaWYgKGJhY2tPcGFjaXR5ID4gYmFja09wYWNpdHlUaHJlc2hvbGQpIHtcbiAgICAgICAgICBhMSA9IDEgLSBiYWNrT3BhY2l0eVRocmVzaG9sZCAvICgxIC0gbmV3T3BhY2l0eSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wYWNpdHkgPiBhMSkge1xuICAgICAgICAgIG9wYWNpdHkgPSBhMTtcbiAgICAgICAgfVxuICAgICAgICBtb2RlbC5zZXRQYXJ0T3BhY2l0eUJ5SW5kZXgocGFydHNJbmRleCwgb3BhY2l0eSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2ZhZGVUaW1lU2Vjb25kcyA9IERlZmF1bHRGYWRlSW5TZWNvbmRzO1xuICAgIHRoaXMuX2xhc3RNb2RlbCA9IHZvaWQgMDtcbiAgICB0aGlzLl9wYXJ0R3JvdXBzID0gW107XG4gICAgdGhpcy5fcGFydEdyb3VwQ291bnRzID0gW107XG4gIH1cbn1cbmNsYXNzIFBhcnREYXRhIHtcbiAgY29uc3RydWN0b3Iodikge1xuICAgIHRoaXMucGFyYW1ldGVySW5kZXggPSAwO1xuICAgIHRoaXMucGFydEluZGV4ID0gMDtcbiAgICB0aGlzLnBhcnRJZCA9IFwiXCI7XG4gICAgdGhpcy5saW5rID0gW107XG4gICAgaWYgKHYgIT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLmFzc2lnbm1lbnQodik7XG4gICAgfVxuICB9XG4gIGFzc2lnbm1lbnQodikge1xuICAgIHRoaXMucGFydElkID0gdi5wYXJ0SWQ7XG4gICAgdGhpcy5saW5rID0gdi5saW5rLm1hcCgobGluaykgPT4gbGluay5jbG9uZSgpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpbml0aWFsaXplKG1vZGVsKSB7XG4gICAgdGhpcy5wYXJhbWV0ZXJJbmRleCA9IG1vZGVsLmdldFBhcmFtZXRlckluZGV4KHRoaXMucGFydElkKTtcbiAgICB0aGlzLnBhcnRJbmRleCA9IG1vZGVsLmdldFBhcnRJbmRleCh0aGlzLnBhcnRJZCk7XG4gICAgbW9kZWwuc2V0UGFyYW1ldGVyVmFsdWVCeUluZGV4KHRoaXMucGFyYW1ldGVySW5kZXgsIDEpO1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lUGFydERhdGEgPSBuZXcgUGFydERhdGEoKTtcbiAgICBjbG9uZVBhcnREYXRhLnBhcnRJZCA9IHRoaXMucGFydElkO1xuICAgIGNsb25lUGFydERhdGEucGFyYW1ldGVySW5kZXggPSB0aGlzLnBhcmFtZXRlckluZGV4O1xuICAgIGNsb25lUGFydERhdGEucGFydEluZGV4ID0gdGhpcy5wYXJ0SW5kZXg7XG4gICAgY2xvbmVQYXJ0RGF0YS5saW5rID0gdGhpcy5saW5rLm1hcCgobGluaykgPT4gbGluay5jbG9uZSgpKTtcbiAgICByZXR1cm4gY2xvbmVQYXJ0RGF0YTtcbiAgfVxufVxuY2xhc3MgQ3ViaXNtVmVjdG9yMiB7XG4gIGNvbnN0cnVjdG9yKHgsIHkpIHtcbiAgICB0aGlzLnggPSB4IHx8IDA7XG4gICAgdGhpcy55ID0geSB8fCAwO1xuICB9XG4gIGFkZCh2ZWN0b3IyKSB7XG4gICAgY29uc3QgcmV0ID0gbmV3IEN1YmlzbVZlY3RvcjIoMCwgMCk7XG4gICAgcmV0LnggPSB0aGlzLnggKyB2ZWN0b3IyLng7XG4gICAgcmV0LnkgPSB0aGlzLnkgKyB2ZWN0b3IyLnk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBzdWJzdHJhY3QodmVjdG9yMikge1xuICAgIGNvbnN0IHJldCA9IG5ldyBDdWJpc21WZWN0b3IyKDAsIDApO1xuICAgIHJldC54ID0gdGhpcy54IC0gdmVjdG9yMi54O1xuICAgIHJldC55ID0gdGhpcy55IC0gdmVjdG9yMi55O1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgbXVsdGlwbHkodmVjdG9yMikge1xuICAgIGNvbnN0IHJldCA9IG5ldyBDdWJpc21WZWN0b3IyKDAsIDApO1xuICAgIHJldC54ID0gdGhpcy54ICogdmVjdG9yMi54O1xuICAgIHJldC55ID0gdGhpcy55ICogdmVjdG9yMi55O1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgbXVsdGlwbHlCeVNjYWxlcihzY2FsYXIpIHtcbiAgICByZXR1cm4gdGhpcy5tdWx0aXBseShuZXcgQ3ViaXNtVmVjdG9yMihzY2FsYXIsIHNjYWxhcikpO1xuICB9XG4gIGRpdmlzaW9uKHZlY3RvcjIpIHtcbiAgICBjb25zdCByZXQgPSBuZXcgQ3ViaXNtVmVjdG9yMigwLCAwKTtcbiAgICByZXQueCA9IHRoaXMueCAvIHZlY3RvcjIueDtcbiAgICByZXQueSA9IHRoaXMueSAvIHZlY3RvcjIueTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGRpdmlzaW9uQnlTY2FsYXIoc2NhbGFyKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2aXNpb24obmV3IEN1YmlzbVZlY3RvcjIoc2NhbGFyLCBzY2FsYXIpKTtcbiAgfVxuICBnZXRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkpO1xuICB9XG4gIGdldERpc3RhbmNlV2l0aChhKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCgodGhpcy54IC0gYS54KSAqICh0aGlzLnggLSBhLngpICsgKHRoaXMueSAtIGEueSkgKiAodGhpcy55IC0gYS55KSk7XG4gIH1cbiAgZG90KGEpIHtcbiAgICByZXR1cm4gdGhpcy54ICogYS54ICsgdGhpcy55ICogYS55O1xuICB9XG4gIG5vcm1hbGl6ZSgpIHtcbiAgICBjb25zdCBsZW5ndGggPSBNYXRoLnBvdyh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnksIDAuNSk7XG4gICAgdGhpcy54ID0gdGhpcy54IC8gbGVuZ3RoO1xuICAgIHRoaXMueSA9IHRoaXMueSAvIGxlbmd0aDtcbiAgfVxuICBpc0VxdWFsKHJocykge1xuICAgIHJldHVybiB0aGlzLnggPT0gcmhzLnggJiYgdGhpcy55ID09IHJocy55O1xuICB9XG4gIGlzTm90RXF1YWwocmhzKSB7XG4gICAgcmV0dXJuICF0aGlzLmlzRXF1YWwocmhzKTtcbiAgfVxufVxuY29uc3QgX0N1YmlzbU1hdGggPSBjbGFzcyB7XG4gIHN0YXRpYyByYW5nZSh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICBpZiAodmFsdWUgPCBtaW4pIHtcbiAgICAgIHZhbHVlID0gbWluO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgIHZhbHVlID0gbWF4O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgc3RhdGljIHNpbih4KSB7XG4gICAgcmV0dXJuIE1hdGguc2luKHgpO1xuICB9XG4gIHN0YXRpYyBjb3MoeCkge1xuICAgIHJldHVybiBNYXRoLmNvcyh4KTtcbiAgfVxuICBzdGF0aWMgYWJzKHgpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoeCk7XG4gIH1cbiAgc3RhdGljIHNxcnQoeCkge1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCk7XG4gIH1cbiAgc3RhdGljIGNicnQoeCkge1xuICAgIGlmICh4ID09PSAwKSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgbGV0IGN4ID0geDtcbiAgICBjb25zdCBpc05lZ2F0aXZlTnVtYmVyID0gY3ggPCAwO1xuICAgIGlmIChpc05lZ2F0aXZlTnVtYmVyKSB7XG4gICAgICBjeCA9IC1jeDtcbiAgICB9XG4gICAgbGV0IHJldDtcbiAgICBpZiAoY3ggPT09IEluZmluaXR5KSB7XG4gICAgICByZXQgPSBJbmZpbml0eTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0ID0gTWF0aC5leHAoTWF0aC5sb2coY3gpIC8gMyk7XG4gICAgICByZXQgPSAoY3ggLyAocmV0ICogcmV0KSArIDIgKiByZXQpIC8gMztcbiAgICB9XG4gICAgcmV0dXJuIGlzTmVnYXRpdmVOdW1iZXIgPyAtcmV0IDogcmV0O1xuICB9XG4gIHN0YXRpYyBnZXRFYXNpbmdTaW5lKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA+IDEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMC41IC0gMC41ICogdGhpcy5jb3ModmFsdWUgKiBNYXRoLlBJKTtcbiAgfVxuICBzdGF0aWMgbWF4KGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIGxlZnQgPiByaWdodCA/IGxlZnQgOiByaWdodDtcbiAgfVxuICBzdGF0aWMgbWluKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIGxlZnQgPiByaWdodCA/IHJpZ2h0IDogbGVmdDtcbiAgfVxuICBzdGF0aWMgZGVncmVlc1RvUmFkaWFuKGRlZ3JlZXMpIHtcbiAgICByZXR1cm4gZGVncmVlcyAvIDE4MCAqIE1hdGguUEk7XG4gIH1cbiAgc3RhdGljIHJhZGlhblRvRGVncmVlcyhyYWRpYW4pIHtcbiAgICByZXR1cm4gcmFkaWFuICogMTgwIC8gTWF0aC5QSTtcbiAgfVxuICBzdGF0aWMgZGlyZWN0aW9uVG9SYWRpYW4oZnJvbSwgdG8pIHtcbiAgICBjb25zdCBxMSA9IE1hdGguYXRhbjIodG8ueSwgdG8ueCk7XG4gICAgY29uc3QgcTIgPSBNYXRoLmF0YW4yKGZyb20ueSwgZnJvbS54KTtcbiAgICBsZXQgcmV0ID0gcTEgLSBxMjtcbiAgICB3aGlsZSAocmV0IDwgLU1hdGguUEkpIHtcbiAgICAgIHJldCArPSBNYXRoLlBJICogMjtcbiAgICB9XG4gICAgd2hpbGUgKHJldCA+IE1hdGguUEkpIHtcbiAgICAgIHJldCAtPSBNYXRoLlBJICogMjtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBzdGF0aWMgZGlyZWN0aW9uVG9EZWdyZWVzKGZyb20sIHRvKSB7XG4gICAgY29uc3QgcmFkaWFuID0gdGhpcy5kaXJlY3Rpb25Ub1JhZGlhbihmcm9tLCB0byk7XG4gICAgbGV0IGRlZ3JlZSA9IHRoaXMucmFkaWFuVG9EZWdyZWVzKHJhZGlhbik7XG4gICAgaWYgKHRvLnggLSBmcm9tLnggPiAwKSB7XG4gICAgICBkZWdyZWUgPSAtZGVncmVlO1xuICAgIH1cbiAgICByZXR1cm4gZGVncmVlO1xuICB9XG4gIHN0YXRpYyByYWRpYW5Ub0RpcmVjdGlvbih0b3RhbEFuZ2xlKSB7XG4gICAgY29uc3QgcmV0ID0gbmV3IEN1YmlzbVZlY3RvcjIoKTtcbiAgICByZXQueCA9IHRoaXMuc2luKHRvdGFsQW5nbGUpO1xuICAgIHJldC55ID0gdGhpcy5jb3ModG90YWxBbmdsZSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBzdGF0aWMgcXVhZHJhdGljRXF1YXRpb24oYSwgYiwgYykge1xuICAgIGlmICh0aGlzLmFicyhhKSA8IF9DdWJpc21NYXRoLkVwc2lsb24pIHtcbiAgICAgIGlmICh0aGlzLmFicyhiKSA8IF9DdWJpc21NYXRoLkVwc2lsb24pIHtcbiAgICAgICAgcmV0dXJuIC1jO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC1jIC8gYjtcbiAgICB9XG4gICAgcmV0dXJuIC0oYiArIHRoaXMuc3FydChiICogYiAtIDQgKiBhICogYykpIC8gKDIgKiBhKTtcbiAgfVxuICBzdGF0aWMgY2FyZGFub0FsZ29yaXRobUZvckJlemllcihhLCBiLCBjLCBkKSB7XG4gICAgaWYgKHRoaXMuc3FydChhKSA8IF9DdWJpc21NYXRoLkVwc2lsb24pIHtcbiAgICAgIHJldHVybiB0aGlzLnJhbmdlKHRoaXMucXVhZHJhdGljRXF1YXRpb24oYiwgYywgZCksIDAsIDEpO1xuICAgIH1cbiAgICBjb25zdCBiYSA9IGIgLyBhO1xuICAgIGNvbnN0IGNhID0gYyAvIGE7XG4gICAgY29uc3QgZGEgPSBkIC8gYTtcbiAgICBjb25zdCBwID0gKDMgKiBjYSAtIGJhICogYmEpIC8gMztcbiAgICBjb25zdCBwMyA9IHAgLyAzO1xuICAgIGNvbnN0IHEgPSAoMiAqIGJhICogYmEgKiBiYSAtIDkgKiBiYSAqIGNhICsgMjcgKiBkYSkgLyAyNztcbiAgICBjb25zdCBxMiA9IHEgLyAyO1xuICAgIGNvbnN0IGRpc2NyaW1pbmFudCA9IHEyICogcTIgKyBwMyAqIHAzICogcDM7XG4gICAgY29uc3QgY2VudGVyID0gMC41O1xuICAgIGNvbnN0IHRocmVzaG9sZCA9IGNlbnRlciArIDAuMDE7XG4gICAgaWYgKGRpc2NyaW1pbmFudCA8IDApIHtcbiAgICAgIGNvbnN0IG1wMyA9IC1wIC8gMztcbiAgICAgIGNvbnN0IG1wMzMgPSBtcDMgKiBtcDMgKiBtcDM7XG4gICAgICBjb25zdCByID0gdGhpcy5zcXJ0KG1wMzMpO1xuICAgICAgY29uc3QgdCA9IC1xIC8gKDIgKiByKTtcbiAgICAgIGNvbnN0IGNvc3BoaSA9IHRoaXMucmFuZ2UodCwgLTEsIDEpO1xuICAgICAgY29uc3QgcGhpID0gTWF0aC5hY29zKGNvc3BoaSk7XG4gICAgICBjb25zdCBjcnRyID0gdGhpcy5jYnJ0KHIpO1xuICAgICAgY29uc3QgdDEgPSAyICogY3J0cjtcbiAgICAgIGNvbnN0IHJvb3QxMiA9IHQxICogdGhpcy5jb3MocGhpIC8gMykgLSBiYSAvIDM7XG4gICAgICBpZiAodGhpcy5hYnMocm9vdDEyIC0gY2VudGVyKSA8IHRocmVzaG9sZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZShyb290MTIsIDAsIDEpO1xuICAgICAgfVxuICAgICAgY29uc3Qgcm9vdDIgPSB0MSAqIHRoaXMuY29zKChwaGkgKyAyICogTWF0aC5QSSkgLyAzKSAtIGJhIC8gMztcbiAgICAgIGlmICh0aGlzLmFicyhyb290MiAtIGNlbnRlcikgPCB0aHJlc2hvbGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2Uocm9vdDIsIDAsIDEpO1xuICAgICAgfVxuICAgICAgY29uc3Qgcm9vdDMgPSB0MSAqIHRoaXMuY29zKChwaGkgKyA0ICogTWF0aC5QSSkgLyAzKSAtIGJhIC8gMztcbiAgICAgIHJldHVybiB0aGlzLnJhbmdlKHJvb3QzLCAwLCAxKTtcbiAgICB9XG4gICAgaWYgKGRpc2NyaW1pbmFudCA9PSAwKSB7XG4gICAgICBsZXQgdTEyO1xuICAgICAgaWYgKHEyIDwgMCkge1xuICAgICAgICB1MTIgPSB0aGlzLmNicnQoLXEyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHUxMiA9IC10aGlzLmNicnQocTIpO1xuICAgICAgfVxuICAgICAgY29uc3Qgcm9vdDEyID0gMiAqIHUxMiAtIGJhIC8gMztcbiAgICAgIGlmICh0aGlzLmFicyhyb290MTIgLSBjZW50ZXIpIDwgdGhyZXNob2xkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlKHJvb3QxMiwgMCwgMSk7XG4gICAgICB9XG4gICAgICBjb25zdCByb290MiA9IC11MTIgLSBiYSAvIDM7XG4gICAgICByZXR1cm4gdGhpcy5yYW5nZShyb290MiwgMCwgMSk7XG4gICAgfVxuICAgIGNvbnN0IHNkID0gdGhpcy5zcXJ0KGRpc2NyaW1pbmFudCk7XG4gICAgY29uc3QgdTEgPSB0aGlzLmNicnQoc2QgLSBxMik7XG4gICAgY29uc3QgdjEgPSB0aGlzLmNicnQoc2QgKyBxMik7XG4gICAgY29uc3Qgcm9vdDEgPSB1MSAtIHYxIC0gYmEgLyAzO1xuICAgIHJldHVybiB0aGlzLnJhbmdlKHJvb3QxLCAwLCAxKTtcbiAgfVxuICBjb25zdHJ1Y3RvcigpIHtcbiAgfVxufTtcbmxldCBDdWJpc21NYXRoID0gX0N1YmlzbU1hdGg7XG5DdWJpc21NYXRoLkVwc2lsb24gPSAxZS01O1xuY2xhc3MgQ3ViaXNtTWF0cml4NDQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl90ciA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuICAgIHRoaXMubG9hZElkZW50aXR5KCk7XG4gIH1cbiAgc3RhdGljIG11bHRpcGx5KGEsIGIsIGRzdCkge1xuICAgIGNvbnN0IGMgPSBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDBcbiAgICBdKTtcbiAgICBjb25zdCBuID0gNDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuOyArK2opIHtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBuOyArK2spIHtcbiAgICAgICAgICBjW2ogKyBpICogNF0gKz0gYVtrICsgaSAqIDRdICogYltqICsgayAqIDRdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgZHN0W2ldID0gY1tpXTtcbiAgICB9XG4gIH1cbiAgbG9hZElkZW50aXR5KCkge1xuICAgIGNvbnN0IGMgPSBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDFcbiAgICBdKTtcbiAgICB0aGlzLnNldE1hdHJpeChjKTtcbiAgfVxuICBzZXRNYXRyaXgodHIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIHRoaXMuX3RyW2ldID0gdHJbaV07XG4gICAgfVxuICB9XG4gIGdldEFycmF5KCkge1xuICAgIHJldHVybiB0aGlzLl90cjtcbiAgfVxuICBnZXRTY2FsZVgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyWzBdO1xuICB9XG4gIGdldFNjYWxlWSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJbNV07XG4gIH1cbiAgZ2V0VHJhbnNsYXRlWCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJbMTJdO1xuICB9XG4gIGdldFRyYW5zbGF0ZVkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyWzEzXTtcbiAgfVxuICB0cmFuc2Zvcm1YKHNyYykge1xuICAgIHJldHVybiB0aGlzLl90clswXSAqIHNyYyArIHRoaXMuX3RyWzEyXTtcbiAgfVxuICB0cmFuc2Zvcm1ZKHNyYykge1xuICAgIHJldHVybiB0aGlzLl90cls1XSAqIHNyYyArIHRoaXMuX3RyWzEzXTtcbiAgfVxuICBpbnZlcnRUcmFuc2Zvcm1YKHNyYykge1xuICAgIHJldHVybiAoc3JjIC0gdGhpcy5fdHJbMTJdKSAvIHRoaXMuX3RyWzBdO1xuICB9XG4gIGludmVydFRyYW5zZm9ybVkoc3JjKSB7XG4gICAgcmV0dXJuIChzcmMgLSB0aGlzLl90clsxM10pIC8gdGhpcy5fdHJbNV07XG4gIH1cbiAgdHJhbnNsYXRlUmVsYXRpdmUoeCwgeSkge1xuICAgIGNvbnN0IHRyMSA9IG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICAwLFxuICAgICAgMVxuICAgIF0pO1xuICAgIEN1YmlzbU1hdHJpeDQ0Lm11bHRpcGx5KHRyMSwgdGhpcy5fdHIsIHRoaXMuX3RyKTtcbiAgfVxuICB0cmFuc2xhdGUoeCwgeSkge1xuICAgIHRoaXMuX3RyWzEyXSA9IHg7XG4gICAgdGhpcy5fdHJbMTNdID0geTtcbiAgfVxuICB0cmFuc2xhdGVYKHgpIHtcbiAgICB0aGlzLl90clsxMl0gPSB4O1xuICB9XG4gIHRyYW5zbGF0ZVkoeSkge1xuICAgIHRoaXMuX3RyWzEzXSA9IHk7XG4gIH1cbiAgc2NhbGVSZWxhdGl2ZSh4LCB5KSB7XG4gICAgY29uc3QgdHIxID0gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICB4LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIHksXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxXG4gICAgXSk7XG4gICAgQ3ViaXNtTWF0cml4NDQubXVsdGlwbHkodHIxLCB0aGlzLl90ciwgdGhpcy5fdHIpO1xuICB9XG4gIHNjYWxlKHgsIHkpIHtcbiAgICB0aGlzLl90clswXSA9IHg7XG4gICAgdGhpcy5fdHJbNV0gPSB5O1xuICB9XG4gIG11bHRpcGx5QnlNYXRyaXgobSkge1xuICAgIEN1YmlzbU1hdHJpeDQ0Lm11bHRpcGx5KG0uZ2V0QXJyYXkoKSwgdGhpcy5fdHIsIHRoaXMuX3RyKTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZU1hdHJpeCA9IG5ldyBDdWJpc21NYXRyaXg0NCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNsb25lTWF0cml4Ll90cltpXSA9IHRoaXMuX3RyW2ldO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmVNYXRyaXg7XG4gIH1cbn1cbmNsYXNzIEN1YmlzbVJlbmRlcmVyIHtcbiAgaW5pdGlhbGl6ZShtb2RlbCkge1xuICAgIHRoaXMuX21vZGVsID0gbW9kZWw7XG4gIH1cbiAgZHJhd01vZGVsKCkge1xuICAgIGlmICh0aGlzLmdldE1vZGVsKCkgPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmRvRHJhd01vZGVsKCk7XG4gIH1cbiAgc2V0TXZwTWF0cml4KG1hdHJpeDQ0KSB7XG4gICAgdGhpcy5fbXZwTWF0cml4NHg0LnNldE1hdHJpeChtYXRyaXg0NC5nZXRBcnJheSgpKTtcbiAgfVxuICBnZXRNdnBNYXRyaXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX212cE1hdHJpeDR4NDtcbiAgfVxuICBzZXRNb2RlbENvbG9yKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKSB7XG4gICAgaWYgKHJlZCA8IDApIHtcbiAgICAgIHJlZCA9IDA7XG4gICAgfSBlbHNlIGlmIChyZWQgPiAxKSB7XG4gICAgICByZWQgPSAxO1xuICAgIH1cbiAgICBpZiAoZ3JlZW4gPCAwKSB7XG4gICAgICBncmVlbiA9IDA7XG4gICAgfSBlbHNlIGlmIChncmVlbiA+IDEpIHtcbiAgICAgIGdyZWVuID0gMTtcbiAgICB9XG4gICAgaWYgKGJsdWUgPCAwKSB7XG4gICAgICBibHVlID0gMDtcbiAgICB9IGVsc2UgaWYgKGJsdWUgPiAxKSB7XG4gICAgICBibHVlID0gMTtcbiAgICB9XG4gICAgaWYgKGFscGhhIDwgMCkge1xuICAgICAgYWxwaGEgPSAwO1xuICAgIH0gZWxzZSBpZiAoYWxwaGEgPiAxKSB7XG4gICAgICBhbHBoYSA9IDE7XG4gICAgfVxuICAgIHRoaXMuX21vZGVsQ29sb3IuUiA9IHJlZDtcbiAgICB0aGlzLl9tb2RlbENvbG9yLkcgPSBncmVlbjtcbiAgICB0aGlzLl9tb2RlbENvbG9yLkIgPSBibHVlO1xuICAgIHRoaXMuX21vZGVsQ29sb3IuQSA9IGFscGhhO1xuICB9XG4gIGdldE1vZGVsQ29sb3IoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX21vZGVsQ29sb3IpO1xuICB9XG4gIHNldElzUHJlbXVsdGlwbGllZEFscGhhKGVuYWJsZSkge1xuICAgIHRoaXMuX2lzUHJlbXVsdGlwbGllZEFscGhhID0gZW5hYmxlO1xuICB9XG4gIGlzUHJlbXVsdGlwbGllZEFscGhhKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1ByZW11bHRpcGxpZWRBbHBoYTtcbiAgfVxuICBzZXRJc0N1bGxpbmcoY3VsbGluZykge1xuICAgIHRoaXMuX2lzQ3VsbGluZyA9IGN1bGxpbmc7XG4gIH1cbiAgaXNDdWxsaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0N1bGxpbmc7XG4gIH1cbiAgc2V0QW5pc290cm9weShuKSB7XG4gICAgdGhpcy5fYW5pc29ydG9weSA9IG47XG4gIH1cbiAgZ2V0QW5pc290cm9weSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYW5pc29ydG9weTtcbiAgfVxuICBnZXRNb2RlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWw7XG4gIH1cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5faXNDdWxsaW5nID0gZmFsc2U7XG4gICAgdGhpcy5faXNQcmVtdWx0aXBsaWVkQWxwaGEgPSBmYWxzZTtcbiAgICB0aGlzLl9hbmlzb3J0b3B5ID0gMDtcbiAgICB0aGlzLl9tb2RlbENvbG9yID0gbmV3IEN1YmlzbVRleHR1cmVDb2xvcigpO1xuICAgIHRoaXMuX212cE1hdHJpeDR4NCA9IG5ldyBDdWJpc21NYXRyaXg0NCgpO1xuICAgIHRoaXMuX212cE1hdHJpeDR4NC5sb2FkSWRlbnRpdHkoKTtcbiAgfVxufVxudmFyIEN1YmlzbUJsZW5kTW9kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEN1YmlzbUJsZW5kTW9kZTIpID0+IHtcbiAgQ3ViaXNtQmxlbmRNb2RlMltDdWJpc21CbGVuZE1vZGUyW1wiQ3ViaXNtQmxlbmRNb2RlX05vcm1hbFwiXSA9IDBdID0gXCJDdWJpc21CbGVuZE1vZGVfTm9ybWFsXCI7XG4gIEN1YmlzbUJsZW5kTW9kZTJbQ3ViaXNtQmxlbmRNb2RlMltcIkN1YmlzbUJsZW5kTW9kZV9BZGRpdGl2ZVwiXSA9IDFdID0gXCJDdWJpc21CbGVuZE1vZGVfQWRkaXRpdmVcIjtcbiAgQ3ViaXNtQmxlbmRNb2RlMltDdWJpc21CbGVuZE1vZGUyW1wiQ3ViaXNtQmxlbmRNb2RlX011bHRpcGxpY2F0aXZlXCJdID0gMl0gPSBcIkN1YmlzbUJsZW5kTW9kZV9NdWx0aXBsaWNhdGl2ZVwiO1xuICByZXR1cm4gQ3ViaXNtQmxlbmRNb2RlMjtcbn0pKEN1YmlzbUJsZW5kTW9kZSB8fCB7fSk7XG5jbGFzcyBDdWJpc21UZXh0dXJlQ29sb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLlIgPSAxO1xuICAgIHRoaXMuRyA9IDE7XG4gICAgdGhpcy5CID0gMTtcbiAgICB0aGlzLkEgPSAxO1xuICB9XG59XG5sZXQgc19pc1N0YXJ0ZWQgPSBmYWxzZTtcbmxldCBzX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbmxldCBzX29wdGlvbiA9IHZvaWQgMDtcbmNvbnN0IENvbnN0YW50ID0ge1xuICB2ZXJ0ZXhPZmZzZXQ6IDAsXG4gIHZlcnRleFN0ZXA6IDJcbn07XG5jbGFzcyBDdWJpc21GcmFtZXdvcmsge1xuICBzdGF0aWMgc3RhcnRVcChvcHRpb24pIHtcbiAgICBpZiAoc19pc1N0YXJ0ZWQpIHtcbiAgICAgIEN1YmlzbUxvZ0luZm8oXCJDdWJpc21GcmFtZXdvcmsuc3RhcnRVcCgpIGlzIGFscmVhZHkgZG9uZS5cIik7XG4gICAgICByZXR1cm4gc19pc1N0YXJ0ZWQ7XG4gICAgfVxuICAgIGlmIChMaXZlMkRDdWJpc21Db3JlLl9pc1N0YXJ0ZWQpIHtcbiAgICAgIHNfaXNTdGFydGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBMaXZlMkRDdWJpc21Db3JlLl9pc1N0YXJ0ZWQgPSB0cnVlO1xuICAgIHNfb3B0aW9uID0gb3B0aW9uO1xuICAgIGlmIChzX29wdGlvbikge1xuICAgICAgTGl2ZTJEQ3ViaXNtQ29yZS5Mb2dnaW5nLmNzbVNldExvZ0Z1bmN0aW9uKHNfb3B0aW9uLmxvZ0Z1bmN0aW9uKTtcbiAgICB9XG4gICAgc19pc1N0YXJ0ZWQgPSB0cnVlO1xuICAgIGlmIChzX2lzU3RhcnRlZCkge1xuICAgICAgY29uc3QgdmVyc2lvbiA9IExpdmUyREN1YmlzbUNvcmUuVmVyc2lvbi5jc21HZXRWZXJzaW9uKCk7XG4gICAgICBjb25zdCBtYWpvciA9ICh2ZXJzaW9uICYgNDI3ODE5MDA4MCkgPj4gMjQ7XG4gICAgICBjb25zdCBtaW5vciA9ICh2ZXJzaW9uICYgMTY3MTE2ODApID4+IDE2O1xuICAgICAgY29uc3QgcGF0Y2ggPSB2ZXJzaW9uICYgNjU1MzU7XG4gICAgICBjb25zdCB2ZXJzaW9uTnVtYmVyID0gdmVyc2lvbjtcbiAgICAgIEN1YmlzbUxvZ0luZm8oYExpdmUyRCBDdWJpc20gQ29yZSB2ZXJzaW9uOiB7MH0uezF9LnsyfSAoezN9KWAsIChcIjAwXCIgKyBtYWpvcikuc2xpY2UoLTIpLCAoXCIwMFwiICsgbWlub3IpLnNsaWNlKC0yKSwgKFwiMDAwMFwiICsgcGF0Y2gpLnNsaWNlKC00KSwgdmVyc2lvbk51bWJlcik7XG4gICAgfVxuICAgIEN1YmlzbUxvZ0luZm8oXCJDdWJpc21GcmFtZXdvcmsuc3RhcnRVcCgpIGlzIGNvbXBsZXRlLlwiKTtcbiAgICByZXR1cm4gc19pc1N0YXJ0ZWQ7XG4gIH1cbiAgc3RhdGljIGNsZWFuVXAoKSB7XG4gICAgc19pc1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICBzX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICBzX29wdGlvbiA9IHZvaWQgMDtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZSgpIHtcbiAgICBpZiAoIXNfaXNTdGFydGVkKSB7XG4gICAgICBDdWJpc21Mb2dXYXJuaW5nKFwiQ3ViaXNtRnJhbWV3b3JrIGlzIG5vdCBzdGFydGVkLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHNfaXNJbml0aWFsaXplZCkge1xuICAgICAgQ3ViaXNtTG9nV2FybmluZyhcIkN1YmlzbUZyYW1ld29yay5pbml0aWFsaXplKCkgc2tpcHBlZCwgYWxyZWFkeSBpbml0aWFsaXplZC5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNfaXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgQ3ViaXNtTG9nSW5mbyhcIkN1YmlzbUZyYW1ld29yay5pbml0aWFsaXplKCkgaXMgY29tcGxldGUuXCIpO1xuICB9XG4gIHN0YXRpYyBkaXNwb3NlKCkge1xuICAgIGlmICghc19pc1N0YXJ0ZWQpIHtcbiAgICAgIEN1YmlzbUxvZ1dhcm5pbmcoXCJDdWJpc21GcmFtZXdvcmsgaXMgbm90IHN0YXJ0ZWQuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXNfaXNJbml0aWFsaXplZCkge1xuICAgICAgQ3ViaXNtTG9nV2FybmluZyhcIkN1YmlzbUZyYW1ld29yay5kaXNwb3NlKCkgc2tpcHBlZCwgbm90IGluaXRpYWxpemVkLlwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgQ3ViaXNtUmVuZGVyZXIuc3RhdGljUmVsZWFzZSgpO1xuICAgIHNfaXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIEN1YmlzbUxvZ0luZm8oXCJDdWJpc21GcmFtZXdvcmsuZGlzcG9zZSgpIGlzIGNvbXBsZXRlLlwiKTtcbiAgfVxuICBzdGF0aWMgaXNTdGFydGVkKCkge1xuICAgIHJldHVybiBzX2lzU3RhcnRlZDtcbiAgfVxuICBzdGF0aWMgaXNJbml0aWFsaXplZCgpIHtcbiAgICByZXR1cm4gc19pc0luaXRpYWxpemVkO1xuICB9XG4gIHN0YXRpYyBjb3JlTG9nRnVuY3Rpb24obWVzc2FnZSkge1xuICAgIGlmICghTGl2ZTJEQ3ViaXNtQ29yZS5Mb2dnaW5nLmNzbUdldExvZ0Z1bmN0aW9uKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgTGl2ZTJEQ3ViaXNtQ29yZS5Mb2dnaW5nLmNzbUdldExvZ0Z1bmN0aW9uKCkobWVzc2FnZSk7XG4gIH1cbiAgc3RhdGljIGdldExvZ2dpbmdMZXZlbCgpIHtcbiAgICBpZiAoc19vcHRpb24gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHNfb3B0aW9uLmxvZ2dpbmdMZXZlbDtcbiAgICB9XG4gICAgcmV0dXJuIExvZ0xldmVsLkxvZ0xldmVsX09mZjtcbiAgfVxuICBjb25zdHJ1Y3RvcigpIHtcbiAgfVxufVxudmFyIExvZ0xldmVsID0gLyogQF9fUFVSRV9fICovICgoTG9nTGV2ZWwyKSA9PiB7XG4gIExvZ0xldmVsMltMb2dMZXZlbDJbXCJMb2dMZXZlbF9WZXJib3NlXCJdID0gMF0gPSBcIkxvZ0xldmVsX1ZlcmJvc2VcIjtcbiAgTG9nTGV2ZWwyW0xvZ0xldmVsMltcIkxvZ0xldmVsX0RlYnVnXCJdID0gMV0gPSBcIkxvZ0xldmVsX0RlYnVnXCI7XG4gIExvZ0xldmVsMltMb2dMZXZlbDJbXCJMb2dMZXZlbF9JbmZvXCJdID0gMl0gPSBcIkxvZ0xldmVsX0luZm9cIjtcbiAgTG9nTGV2ZWwyW0xvZ0xldmVsMltcIkxvZ0xldmVsX1dhcm5pbmdcIl0gPSAzXSA9IFwiTG9nTGV2ZWxfV2FybmluZ1wiO1xuICBMb2dMZXZlbDJbTG9nTGV2ZWwyW1wiTG9nTGV2ZWxfRXJyb3JcIl0gPSA0XSA9IFwiTG9nTGV2ZWxfRXJyb3JcIjtcbiAgTG9nTGV2ZWwyW0xvZ0xldmVsMltcIkxvZ0xldmVsX09mZlwiXSA9IDVdID0gXCJMb2dMZXZlbF9PZmZcIjtcbiAgcmV0dXJuIExvZ0xldmVsMjtcbn0pKExvZ0xldmVsIHx8IHt9KTtcbmNvbnN0IENTTV9BU1NFUlQgPSAoKSA9PiB7XG59O1xuZnVuY3Rpb24gQ3ViaXNtTG9nVmVyYm9zZShmbXQsIC4uLmFyZ3MpIHtcbiAgQ3ViaXNtRGVidWcucHJpbnQoTG9nTGV2ZWwuTG9nTGV2ZWxfVmVyYm9zZSwgXCJbQ1NNXVtWXVwiICsgZm10ICsgXCJcXG5cIiwgYXJncyk7XG59XG5mdW5jdGlvbiBDdWJpc21Mb2dEZWJ1ZyhmbXQsIC4uLmFyZ3MpIHtcbiAgQ3ViaXNtRGVidWcucHJpbnQoTG9nTGV2ZWwuTG9nTGV2ZWxfRGVidWcsIFwiW0NTTV1bRF1cIiArIGZtdCArIFwiXFxuXCIsIGFyZ3MpO1xufVxuZnVuY3Rpb24gQ3ViaXNtTG9nSW5mbyhmbXQsIC4uLmFyZ3MpIHtcbiAgQ3ViaXNtRGVidWcucHJpbnQoTG9nTGV2ZWwuTG9nTGV2ZWxfSW5mbywgXCJbQ1NNXVtJXVwiICsgZm10ICsgXCJcXG5cIiwgYXJncyk7XG59XG5mdW5jdGlvbiBDdWJpc21Mb2dXYXJuaW5nKGZtdCwgLi4uYXJncykge1xuICBDdWJpc21EZWJ1Zy5wcmludChMb2dMZXZlbC5Mb2dMZXZlbF9XYXJuaW5nLCBcIltDU01dW1ddXCIgKyBmbXQgKyBcIlxcblwiLCBhcmdzKTtcbn1cbmZ1bmN0aW9uIEN1YmlzbUxvZ0Vycm9yKGZtdCwgLi4uYXJncykge1xuICBDdWJpc21EZWJ1Zy5wcmludChMb2dMZXZlbC5Mb2dMZXZlbF9FcnJvciwgXCJbQ1NNXVtFXVwiICsgZm10ICsgXCJcXG5cIiwgYXJncyk7XG59XG5jbGFzcyBDdWJpc21EZWJ1ZyB7XG4gIHN0YXRpYyBwcmludChsb2dMZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gICAgaWYgKGxvZ0xldmVsIDwgQ3ViaXNtRnJhbWV3b3JrLmdldExvZ2dpbmdMZXZlbCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxvZ1ByaW50ID0gQ3ViaXNtRnJhbWV3b3JrLmNvcmVMb2dGdW5jdGlvbjtcbiAgICBpZiAoIWxvZ1ByaW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGJ1ZmZlciA9IGZvcm1hdC5yZXBsYWNlKC97KFxcZCspfS9nLCAobSwgaykgPT4ge1xuICAgICAgcmV0dXJuIGFyZ3Nba107XG4gICAgfSk7XG4gICAgbG9nUHJpbnQoYnVmZmVyKTtcbiAgfVxuICBzdGF0aWMgZHVtcEJ5dGVzKGxvZ0xldmVsLCBkYXRhLCBsZW5ndGgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaSAlIDE2ID09IDAgJiYgaSA+IDApXG4gICAgICAgIHRoaXMucHJpbnQobG9nTGV2ZWwsIFwiXFxuXCIpO1xuICAgICAgZWxzZSBpZiAoaSAlIDggPT0gMCAmJiBpID4gMClcbiAgICAgICAgdGhpcy5wcmludChsb2dMZXZlbCwgXCIgIFwiKTtcbiAgICAgIHRoaXMucHJpbnQobG9nTGV2ZWwsIFwiezB9IFwiLCBbZGF0YVtpXSAmIDI1NV0pO1xuICAgIH1cbiAgICB0aGlzLnByaW50KGxvZ0xldmVsLCBcIlxcblwiKTtcbiAgfVxuICBjb25zdHJ1Y3RvcigpIHtcbiAgfVxufVxuY2xhc3MgQ3ViaXNtTW9kZWwge1xuICB1cGRhdGUoKSB7XG4gICAgdGhpcy5fbW9kZWwudXBkYXRlKCk7XG4gICAgdGhpcy5fbW9kZWwuZHJhd2FibGVzLnJlc2V0RHluYW1pY0ZsYWdzKCk7XG4gIH1cbiAgZ2V0Q2FudmFzV2lkdGgoKSB7XG4gICAgaWYgKHRoaXMuX21vZGVsID09IG51bGwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbW9kZWwuY2FudmFzaW5mby5DYW52YXNXaWR0aCAvIHRoaXMuX21vZGVsLmNhbnZhc2luZm8uUGl4ZWxzUGVyVW5pdDtcbiAgfVxuICBnZXRDYW52YXNIZWlnaHQoKSB7XG4gICAgaWYgKHRoaXMuX21vZGVsID09IG51bGwpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbW9kZWwuY2FudmFzaW5mby5DYW52YXNIZWlnaHQgLyB0aGlzLl9tb2RlbC5jYW52YXNpbmZvLlBpeGVsc1BlclVuaXQ7XG4gIH1cbiAgc2F2ZVBhcmFtZXRlcnMoKSB7XG4gICAgY29uc3QgcGFyYW1ldGVyQ291bnQgPSB0aGlzLl9tb2RlbC5wYXJhbWV0ZXJzLmNvdW50O1xuICAgIGNvbnN0IHNhdmVkUGFyYW1ldGVyQ291bnQgPSB0aGlzLl9zYXZlZFBhcmFtZXRlcnMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1ldGVyQ291bnQ7ICsraSkge1xuICAgICAgaWYgKGkgPCBzYXZlZFBhcmFtZXRlckNvdW50KSB7XG4gICAgICAgIHRoaXMuX3NhdmVkUGFyYW1ldGVyc1tpXSA9IHRoaXMuX3BhcmFtZXRlclZhbHVlc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NhdmVkUGFyYW1ldGVycy5wdXNoKHRoaXMuX3BhcmFtZXRlclZhbHVlc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldE1vZGVsKCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlbDtcbiAgfVxuICBnZXRQYXJ0SW5kZXgocGFydElkKSB7XG4gICAgbGV0IHBhcnRJbmRleDtcbiAgICBjb25zdCBwYXJ0Q291bnQgPSB0aGlzLl9tb2RlbC5wYXJ0cy5jb3VudDtcbiAgICBmb3IgKHBhcnRJbmRleCA9IDA7IHBhcnRJbmRleCA8IHBhcnRDb3VudDsgKytwYXJ0SW5kZXgpIHtcbiAgICAgIGlmIChwYXJ0SWQgPT0gdGhpcy5fcGFydElkc1twYXJ0SW5kZXhdKSB7XG4gICAgICAgIHJldHVybiBwYXJ0SW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJ0SWQgaW4gdGhpcy5fbm90RXhpc3RQYXJ0SWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ub3RFeGlzdFBhcnRJZFtwYXJ0SWRdO1xuICAgIH1cbiAgICBwYXJ0SW5kZXggPSBwYXJ0Q291bnQgKyB0aGlzLl9ub3RFeGlzdFBhcnRJZC5sZW5ndGg7XG4gICAgdGhpcy5fbm90RXhpc3RQYXJ0SWRbcGFydElkXSA9IHBhcnRJbmRleDtcbiAgICB0aGlzLl9ub3RFeGlzdFBhcnRPcGFjaXRpZXNbcGFydEluZGV4XSA9IDA7XG4gICAgcmV0dXJuIHBhcnRJbmRleDtcbiAgfVxuICBnZXRQYXJ0Q291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGVsLnBhcnRzLmNvdW50O1xuICB9XG4gIHNldFBhcnRPcGFjaXR5QnlJbmRleChwYXJ0SW5kZXgsIG9wYWNpdHkpIHtcbiAgICBpZiAocGFydEluZGV4IGluIHRoaXMuX25vdEV4aXN0UGFydE9wYWNpdGllcykge1xuICAgICAgdGhpcy5fbm90RXhpc3RQYXJ0T3BhY2l0aWVzW3BhcnRJbmRleF0gPSBvcGFjaXR5O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBDU01fQVNTRVJUKDAgPD0gcGFydEluZGV4ICYmIHBhcnRJbmRleCA8IHRoaXMuZ2V0UGFydENvdW50KCkpO1xuICAgIHRoaXMuX3BhcnRPcGFjaXRpZXNbcGFydEluZGV4XSA9IG9wYWNpdHk7XG4gIH1cbiAgc2V0UGFydE9wYWNpdHlCeUlkKHBhcnRJZCwgb3BhY2l0eSkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nZXRQYXJ0SW5kZXgocGFydElkKTtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2V0UGFydE9wYWNpdHlCeUluZGV4KGluZGV4LCBvcGFjaXR5KTtcbiAgfVxuICBnZXRQYXJ0T3BhY2l0eUJ5SW5kZXgocGFydEluZGV4KSB7XG4gICAgaWYgKHBhcnRJbmRleCBpbiB0aGlzLl9ub3RFeGlzdFBhcnRPcGFjaXRpZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ub3RFeGlzdFBhcnRPcGFjaXRpZXNbcGFydEluZGV4XTtcbiAgICB9XG4gICAgQ1NNX0FTU0VSVCgwIDw9IHBhcnRJbmRleCAmJiBwYXJ0SW5kZXggPCB0aGlzLmdldFBhcnRDb3VudCgpKTtcbiAgICByZXR1cm4gdGhpcy5fcGFydE9wYWNpdGllc1twYXJ0SW5kZXhdO1xuICB9XG4gIGdldFBhcnRPcGFjaXR5QnlJZChwYXJ0SWQpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0UGFydEluZGV4KHBhcnRJZCk7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBhcnRPcGFjaXR5QnlJbmRleChpbmRleCk7XG4gIH1cbiAgZ2V0UGFyYW1ldGVySW5kZXgocGFyYW1ldGVySWQpIHtcbiAgICBsZXQgcGFyYW1ldGVySW5kZXg7XG4gICAgY29uc3QgaWRDb3VudCA9IHRoaXMuX21vZGVsLnBhcmFtZXRlcnMuY291bnQ7XG4gICAgZm9yIChwYXJhbWV0ZXJJbmRleCA9IDA7IHBhcmFtZXRlckluZGV4IDwgaWRDb3VudDsgKytwYXJhbWV0ZXJJbmRleCkge1xuICAgICAgaWYgKHBhcmFtZXRlcklkICE9IHRoaXMuX3BhcmFtZXRlcklkc1twYXJhbWV0ZXJJbmRleF0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyYW1ldGVySW5kZXg7XG4gICAgfVxuICAgIGlmIChwYXJhbWV0ZXJJZCBpbiB0aGlzLl9ub3RFeGlzdFBhcmFtZXRlcklkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbm90RXhpc3RQYXJhbWV0ZXJJZFtwYXJhbWV0ZXJJZF07XG4gICAgfVxuICAgIHBhcmFtZXRlckluZGV4ID0gdGhpcy5fbW9kZWwucGFyYW1ldGVycy5jb3VudCArIE9iamVjdC5rZXlzKHRoaXMuX25vdEV4aXN0UGFyYW1ldGVySWQpLmxlbmd0aDtcbiAgICB0aGlzLl9ub3RFeGlzdFBhcmFtZXRlcklkW3BhcmFtZXRlcklkXSA9IHBhcmFtZXRlckluZGV4O1xuICAgIHRoaXMuX25vdEV4aXN0UGFyYW1ldGVyVmFsdWVzW3BhcmFtZXRlckluZGV4XSA9IDA7XG4gICAgcmV0dXJuIHBhcmFtZXRlckluZGV4O1xuICB9XG4gIGdldFBhcmFtZXRlckNvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlbC5wYXJhbWV0ZXJzLmNvdW50O1xuICB9XG4gIGdldFBhcmFtZXRlck1heGltdW1WYWx1ZShwYXJhbWV0ZXJJbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlbC5wYXJhbWV0ZXJzLm1heGltdW1WYWx1ZXNbcGFyYW1ldGVySW5kZXhdO1xuICB9XG4gIGdldFBhcmFtZXRlck1pbmltdW1WYWx1ZShwYXJhbWV0ZXJJbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlbC5wYXJhbWV0ZXJzLm1pbmltdW1WYWx1ZXNbcGFyYW1ldGVySW5kZXhdO1xuICB9XG4gIGdldFBhcmFtZXRlckRlZmF1bHRWYWx1ZShwYXJhbWV0ZXJJbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlbC5wYXJhbWV0ZXJzLmRlZmF1bHRWYWx1ZXNbcGFyYW1ldGVySW5kZXhdO1xuICB9XG4gIGdldFBhcmFtZXRlclZhbHVlQnlJbmRleChwYXJhbWV0ZXJJbmRleCkge1xuICAgIGlmIChwYXJhbWV0ZXJJbmRleCBpbiB0aGlzLl9ub3RFeGlzdFBhcmFtZXRlclZhbHVlcykge1xuICAgICAgcmV0dXJuIHRoaXMuX25vdEV4aXN0UGFyYW1ldGVyVmFsdWVzW3BhcmFtZXRlckluZGV4XTtcbiAgICB9XG4gICAgQ1NNX0FTU0VSVCgwIDw9IHBhcmFtZXRlckluZGV4ICYmIHBhcmFtZXRlckluZGV4IDwgdGhpcy5nZXRQYXJhbWV0ZXJDb3VudCgpKTtcbiAgICByZXR1cm4gdGhpcy5fcGFyYW1ldGVyVmFsdWVzW3BhcmFtZXRlckluZGV4XTtcbiAgfVxuICBnZXRQYXJhbWV0ZXJWYWx1ZUJ5SWQocGFyYW1ldGVySWQpIHtcbiAgICBjb25zdCBwYXJhbWV0ZXJJbmRleCA9IHRoaXMuZ2V0UGFyYW1ldGVySW5kZXgocGFyYW1ldGVySWQpO1xuICAgIHJldHVybiB0aGlzLmdldFBhcmFtZXRlclZhbHVlQnlJbmRleChwYXJhbWV0ZXJJbmRleCk7XG4gIH1cbiAgc2V0UGFyYW1ldGVyVmFsdWVCeUluZGV4KHBhcmFtZXRlckluZGV4LCB2YWx1ZSwgd2VpZ2h0ID0gMSkge1xuICAgIGlmIChwYXJhbWV0ZXJJbmRleCBpbiB0aGlzLl9ub3RFeGlzdFBhcmFtZXRlclZhbHVlcykge1xuICAgICAgdGhpcy5fbm90RXhpc3RQYXJhbWV0ZXJWYWx1ZXNbcGFyYW1ldGVySW5kZXhdID0gd2VpZ2h0ID09IDEgPyB2YWx1ZSA6IHRoaXMuX25vdEV4aXN0UGFyYW1ldGVyVmFsdWVzW3BhcmFtZXRlckluZGV4XSAqICgxIC0gd2VpZ2h0KSArIHZhbHVlICogd2VpZ2h0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBDU01fQVNTRVJUKDAgPD0gcGFyYW1ldGVySW5kZXggJiYgcGFyYW1ldGVySW5kZXggPCB0aGlzLmdldFBhcmFtZXRlckNvdW50KCkpO1xuICAgIGlmICh0aGlzLl9tb2RlbC5wYXJhbWV0ZXJzLm1heGltdW1WYWx1ZXNbcGFyYW1ldGVySW5kZXhdIDwgdmFsdWUpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5fbW9kZWwucGFyYW1ldGVycy5tYXhpbXVtVmFsdWVzW3BhcmFtZXRlckluZGV4XTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX21vZGVsLnBhcmFtZXRlcnMubWluaW11bVZhbHVlc1twYXJhbWV0ZXJJbmRleF0gPiB2YWx1ZSkge1xuICAgICAgdmFsdWUgPSB0aGlzLl9tb2RlbC5wYXJhbWV0ZXJzLm1pbmltdW1WYWx1ZXNbcGFyYW1ldGVySW5kZXhdO1xuICAgIH1cbiAgICB0aGlzLl9wYXJhbWV0ZXJWYWx1ZXNbcGFyYW1ldGVySW5kZXhdID0gd2VpZ2h0ID09IDEgPyB2YWx1ZSA6IHRoaXMuX3BhcmFtZXRlclZhbHVlc1twYXJhbWV0ZXJJbmRleF0gPSB0aGlzLl9wYXJhbWV0ZXJWYWx1ZXNbcGFyYW1ldGVySW5kZXhdICogKDEgLSB3ZWlnaHQpICsgdmFsdWUgKiB3ZWlnaHQ7XG4gIH1cbiAgc2V0UGFyYW1ldGVyVmFsdWVCeUlkKHBhcmFtZXRlcklkLCB2YWx1ZSwgd2VpZ2h0ID0gMSkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nZXRQYXJhbWV0ZXJJbmRleChwYXJhbWV0ZXJJZCk7XG4gICAgdGhpcy5zZXRQYXJhbWV0ZXJWYWx1ZUJ5SW5kZXgoaW5kZXgsIHZhbHVlLCB3ZWlnaHQpO1xuICB9XG4gIGFkZFBhcmFtZXRlclZhbHVlQnlJbmRleChwYXJhbWV0ZXJJbmRleCwgdmFsdWUsIHdlaWdodCA9IDEpIHtcbiAgICB0aGlzLnNldFBhcmFtZXRlclZhbHVlQnlJbmRleChwYXJhbWV0ZXJJbmRleCwgdGhpcy5nZXRQYXJhbWV0ZXJWYWx1ZUJ5SW5kZXgocGFyYW1ldGVySW5kZXgpICsgdmFsdWUgKiB3ZWlnaHQpO1xuICB9XG4gIGFkZFBhcmFtZXRlclZhbHVlQnlJZChwYXJhbWV0ZXJJZCwgdmFsdWUsIHdlaWdodCA9IDEpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0UGFyYW1ldGVySW5kZXgocGFyYW1ldGVySWQpO1xuICAgIHRoaXMuYWRkUGFyYW1ldGVyVmFsdWVCeUluZGV4KGluZGV4LCB2YWx1ZSwgd2VpZ2h0KTtcbiAgfVxuICBtdWx0aXBseVBhcmFtZXRlclZhbHVlQnlJZChwYXJhbWV0ZXJJZCwgdmFsdWUsIHdlaWdodCA9IDEpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0UGFyYW1ldGVySW5kZXgocGFyYW1ldGVySWQpO1xuICAgIHRoaXMubXVsdGlwbHlQYXJhbWV0ZXJWYWx1ZUJ5SW5kZXgoaW5kZXgsIHZhbHVlLCB3ZWlnaHQpO1xuICB9XG4gIG11bHRpcGx5UGFyYW1ldGVyVmFsdWVCeUluZGV4KHBhcmFtZXRlckluZGV4LCB2YWx1ZSwgd2VpZ2h0ID0gMSkge1xuICAgIHRoaXMuc2V0UGFyYW1ldGVyVmFsdWVCeUluZGV4KHBhcmFtZXRlckluZGV4LCB0aGlzLmdldFBhcmFtZXRlclZhbHVlQnlJbmRleChwYXJhbWV0ZXJJbmRleCkgKiAoMSArICh2YWx1ZSAtIDEpICogd2VpZ2h0KSk7XG4gIH1cbiAgZ2V0RHJhd2FibGVJZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RyYXdhYmxlSWRzLnNsaWNlKCk7XG4gIH1cbiAgZ2V0RHJhd2FibGVJbmRleChkcmF3YWJsZUlkKSB7XG4gICAgY29uc3QgZHJhd2FibGVDb3VudCA9IHRoaXMuX21vZGVsLmRyYXdhYmxlcy5jb3VudDtcbiAgICBmb3IgKGxldCBkcmF3YWJsZUluZGV4ID0gMDsgZHJhd2FibGVJbmRleCA8IGRyYXdhYmxlQ291bnQ7ICsrZHJhd2FibGVJbmRleCkge1xuICAgICAgaWYgKHRoaXMuX2RyYXdhYmxlSWRzW2RyYXdhYmxlSW5kZXhdID09IGRyYXdhYmxlSWQpIHtcbiAgICAgICAgcmV0dXJuIGRyYXdhYmxlSW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBnZXREcmF3YWJsZUNvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlbC5kcmF3YWJsZXMuY291bnQ7XG4gIH1cbiAgZ2V0RHJhd2FibGVJZChkcmF3YWJsZUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGVsLmRyYXdhYmxlcy5pZHNbZHJhd2FibGVJbmRleF07XG4gIH1cbiAgZ2V0RHJhd2FibGVSZW5kZXJPcmRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGVsLmRyYXdhYmxlcy5yZW5kZXJPcmRlcnM7XG4gIH1cbiAgZ2V0RHJhd2FibGVUZXh0dXJlSW5kaWNlcyhkcmF3YWJsZUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGVsLmRyYXdhYmxlcy50ZXh0dXJlSW5kaWNlc1tkcmF3YWJsZUluZGV4XTtcbiAgfVxuICBnZXREcmF3YWJsZUR5bmFtaWNGbGFnVmVydGV4UG9zaXRpb25zRGlkQ2hhbmdlKGRyYXdhYmxlSW5kZXgpIHtcbiAgICBjb25zdCBkeW5hbWljRmxhZ3MgPSB0aGlzLl9tb2RlbC5kcmF3YWJsZXMuZHluYW1pY0ZsYWdzO1xuICAgIHJldHVybiBMaXZlMkRDdWJpc21Db3JlLlV0aWxzLmhhc1ZlcnRleFBvc2l0aW9uc0RpZENoYW5nZUJpdChkeW5hbWljRmxhZ3NbZHJhd2FibGVJbmRleF0pO1xuICB9XG4gIGdldERyYXdhYmxlVmVydGV4SW5kZXhDb3VudChkcmF3YWJsZUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGVsLmRyYXdhYmxlcy5pbmRleENvdW50c1tkcmF3YWJsZUluZGV4XTtcbiAgfVxuICBnZXREcmF3YWJsZVZlcnRleENvdW50KGRyYXdhYmxlSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWwuZHJhd2FibGVzLnZlcnRleENvdW50c1tkcmF3YWJsZUluZGV4XTtcbiAgfVxuICBnZXREcmF3YWJsZVZlcnRpY2VzKGRyYXdhYmxlSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXREcmF3YWJsZVZlcnRleFBvc2l0aW9ucyhkcmF3YWJsZUluZGV4KTtcbiAgfVxuICBnZXREcmF3YWJsZVZlcnRleEluZGljZXMoZHJhd2FibGVJbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlbC5kcmF3YWJsZXMuaW5kaWNlc1tkcmF3YWJsZUluZGV4XTtcbiAgfVxuICBnZXREcmF3YWJsZVZlcnRleFBvc2l0aW9ucyhkcmF3YWJsZUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGVsLmRyYXdhYmxlcy52ZXJ0ZXhQb3NpdGlvbnNbZHJhd2FibGVJbmRleF07XG4gIH1cbiAgZ2V0RHJhd2FibGVWZXJ0ZXhVdnMoZHJhd2FibGVJbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlbC5kcmF3YWJsZXMudmVydGV4VXZzW2RyYXdhYmxlSW5kZXhdO1xuICB9XG4gIGdldERyYXdhYmxlT3BhY2l0eShkcmF3YWJsZUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGVsLmRyYXdhYmxlcy5vcGFjaXRpZXNbZHJhd2FibGVJbmRleF07XG4gIH1cbiAgZ2V0RHJhd2FibGVDdWxsaW5nKGRyYXdhYmxlSW5kZXgpIHtcbiAgICBjb25zdCBjb25zdGFudEZsYWdzID0gdGhpcy5fbW9kZWwuZHJhd2FibGVzLmNvbnN0YW50RmxhZ3M7XG4gICAgcmV0dXJuICFMaXZlMkRDdWJpc21Db3JlLlV0aWxzLmhhc0lzRG91YmxlU2lkZWRCaXQoY29uc3RhbnRGbGFnc1tkcmF3YWJsZUluZGV4XSk7XG4gIH1cbiAgZ2V0RHJhd2FibGVCbGVuZE1vZGUoZHJhd2FibGVJbmRleCkge1xuICAgIGNvbnN0IGNvbnN0YW50RmxhZ3MgPSB0aGlzLl9tb2RlbC5kcmF3YWJsZXMuY29uc3RhbnRGbGFncztcbiAgICByZXR1cm4gTGl2ZTJEQ3ViaXNtQ29yZS5VdGlscy5oYXNCbGVuZEFkZGl0aXZlQml0KGNvbnN0YW50RmxhZ3NbZHJhd2FibGVJbmRleF0pID8gQ3ViaXNtQmxlbmRNb2RlLkN1YmlzbUJsZW5kTW9kZV9BZGRpdGl2ZSA6IExpdmUyREN1YmlzbUNvcmUuVXRpbHMuaGFzQmxlbmRNdWx0aXBsaWNhdGl2ZUJpdChjb25zdGFudEZsYWdzW2RyYXdhYmxlSW5kZXhdKSA/IEN1YmlzbUJsZW5kTW9kZS5DdWJpc21CbGVuZE1vZGVfTXVsdGlwbGljYXRpdmUgOiBDdWJpc21CbGVuZE1vZGUuQ3ViaXNtQmxlbmRNb2RlX05vcm1hbDtcbiAgfVxuICBnZXREcmF3YWJsZUludmVydGVkTWFza0JpdChkcmF3YWJsZUluZGV4KSB7XG4gICAgY29uc3QgY29uc3RhbnRGbGFncyA9IHRoaXMuX21vZGVsLmRyYXdhYmxlcy5jb25zdGFudEZsYWdzO1xuICAgIHJldHVybiBMaXZlMkRDdWJpc21Db3JlLlV0aWxzLmhhc0lzSW52ZXJ0ZWRNYXNrQml0KGNvbnN0YW50RmxhZ3NbZHJhd2FibGVJbmRleF0pO1xuICB9XG4gIGdldERyYXdhYmxlTWFza3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGVsLmRyYXdhYmxlcy5tYXNrcztcbiAgfVxuICBnZXREcmF3YWJsZU1hc2tDb3VudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGVsLmRyYXdhYmxlcy5tYXNrQ291bnRzO1xuICB9XG4gIGlzVXNpbmdNYXNraW5nKCkge1xuICAgIGZvciAobGV0IGQgPSAwOyBkIDwgdGhpcy5fbW9kZWwuZHJhd2FibGVzLmNvdW50OyArK2QpIHtcbiAgICAgIGlmICh0aGlzLl9tb2RlbC5kcmF3YWJsZXMubWFza0NvdW50c1tkXSA8PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXREcmF3YWJsZUR5bmFtaWNGbGFnSXNWaXNpYmxlKGRyYXdhYmxlSW5kZXgpIHtcbiAgICBjb25zdCBkeW5hbWljRmxhZ3MgPSB0aGlzLl9tb2RlbC5kcmF3YWJsZXMuZHluYW1pY0ZsYWdzO1xuICAgIHJldHVybiBMaXZlMkRDdWJpc21Db3JlLlV0aWxzLmhhc0lzVmlzaWJsZUJpdChkeW5hbWljRmxhZ3NbZHJhd2FibGVJbmRleF0pO1xuICB9XG4gIGdldERyYXdhYmxlRHluYW1pY0ZsYWdWaXNpYmlsaXR5RGlkQ2hhbmdlKGRyYXdhYmxlSW5kZXgpIHtcbiAgICBjb25zdCBkeW5hbWljRmxhZ3MgPSB0aGlzLl9tb2RlbC5kcmF3YWJsZXMuZHluYW1pY0ZsYWdzO1xuICAgIHJldHVybiBMaXZlMkRDdWJpc21Db3JlLlV0aWxzLmhhc1Zpc2liaWxpdHlEaWRDaGFuZ2VCaXQoZHluYW1pY0ZsYWdzW2RyYXdhYmxlSW5kZXhdKTtcbiAgfVxuICBnZXREcmF3YWJsZUR5bmFtaWNGbGFnT3BhY2l0eURpZENoYW5nZShkcmF3YWJsZUluZGV4KSB7XG4gICAgY29uc3QgZHluYW1pY0ZsYWdzID0gdGhpcy5fbW9kZWwuZHJhd2FibGVzLmR5bmFtaWNGbGFncztcbiAgICByZXR1cm4gTGl2ZTJEQ3ViaXNtQ29yZS5VdGlscy5oYXNPcGFjaXR5RGlkQ2hhbmdlQml0KGR5bmFtaWNGbGFnc1tkcmF3YWJsZUluZGV4XSk7XG4gIH1cbiAgZ2V0RHJhd2FibGVEeW5hbWljRmxhZ1JlbmRlck9yZGVyRGlkQ2hhbmdlKGRyYXdhYmxlSW5kZXgpIHtcbiAgICBjb25zdCBkeW5hbWljRmxhZ3MgPSB0aGlzLl9tb2RlbC5kcmF3YWJsZXMuZHluYW1pY0ZsYWdzO1xuICAgIHJldHVybiBMaXZlMkRDdWJpc21Db3JlLlV0aWxzLmhhc1JlbmRlck9yZGVyRGlkQ2hhbmdlQml0KGR5bmFtaWNGbGFnc1tkcmF3YWJsZUluZGV4XSk7XG4gIH1cbiAgbG9hZFBhcmFtZXRlcnMoKSB7XG4gICAgbGV0IHBhcmFtZXRlckNvdW50ID0gdGhpcy5fbW9kZWwucGFyYW1ldGVycy5jb3VudDtcbiAgICBjb25zdCBzYXZlZFBhcmFtZXRlckNvdW50ID0gdGhpcy5fc2F2ZWRQYXJhbWV0ZXJzLmxlbmd0aDtcbiAgICBpZiAocGFyYW1ldGVyQ291bnQgPiBzYXZlZFBhcmFtZXRlckNvdW50KSB7XG4gICAgICBwYXJhbWV0ZXJDb3VudCA9IHNhdmVkUGFyYW1ldGVyQ291bnQ7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1ldGVyQ291bnQ7ICsraSkge1xuICAgICAgdGhpcy5fcGFyYW1ldGVyVmFsdWVzW2ldID0gdGhpcy5fc2F2ZWRQYXJhbWV0ZXJzW2ldO1xuICAgIH1cbiAgfVxuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuX3BhcmFtZXRlclZhbHVlcyA9IHRoaXMuX21vZGVsLnBhcmFtZXRlcnMudmFsdWVzO1xuICAgIHRoaXMuX3BhcnRPcGFjaXRpZXMgPSB0aGlzLl9tb2RlbC5wYXJ0cy5vcGFjaXRpZXM7XG4gICAgdGhpcy5fcGFyYW1ldGVyTWF4aW11bVZhbHVlcyA9IHRoaXMuX21vZGVsLnBhcmFtZXRlcnMubWF4aW11bVZhbHVlcztcbiAgICB0aGlzLl9wYXJhbWV0ZXJNaW5pbXVtVmFsdWVzID0gdGhpcy5fbW9kZWwucGFyYW1ldGVycy5taW5pbXVtVmFsdWVzO1xuICAgIHtcbiAgICAgIGNvbnN0IHBhcmFtZXRlcklkcyA9IHRoaXMuX21vZGVsLnBhcmFtZXRlcnMuaWRzO1xuICAgICAgY29uc3QgcGFyYW1ldGVyQ291bnQgPSB0aGlzLl9tb2RlbC5wYXJhbWV0ZXJzLmNvdW50O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbWV0ZXJDb3VudDsgKytpKSB7XG4gICAgICAgIHRoaXMuX3BhcmFtZXRlcklkcy5wdXNoKHBhcmFtZXRlcklkc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHtcbiAgICAgIGNvbnN0IHBhcnRJZHMgPSB0aGlzLl9tb2RlbC5wYXJ0cy5pZHM7XG4gICAgICBjb25zdCBwYXJ0Q291bnQgPSB0aGlzLl9tb2RlbC5wYXJ0cy5jb3VudDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydENvdW50OyArK2kpIHtcbiAgICAgICAgdGhpcy5fcGFydElkcy5wdXNoKHBhcnRJZHNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB7XG4gICAgICBjb25zdCBkcmF3YWJsZUlkcyA9IHRoaXMuX21vZGVsLmRyYXdhYmxlcy5pZHM7XG4gICAgICBjb25zdCBkcmF3YWJsZUNvdW50ID0gdGhpcy5fbW9kZWwuZHJhd2FibGVzLmNvdW50O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkcmF3YWJsZUNvdW50OyArK2kpIHtcbiAgICAgICAgdGhpcy5fZHJhd2FibGVJZHMucHVzaChkcmF3YWJsZUlkc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0cnVjdG9yKG1vZGVsKSB7XG4gICAgdGhpcy5fbW9kZWwgPSBtb2RlbDtcbiAgICB0aGlzLl9zYXZlZFBhcmFtZXRlcnMgPSBbXTtcbiAgICB0aGlzLl9wYXJhbWV0ZXJJZHMgPSBbXTtcbiAgICB0aGlzLl9kcmF3YWJsZUlkcyA9IFtdO1xuICAgIHRoaXMuX3BhcnRJZHMgPSBbXTtcbiAgICB0aGlzLl9ub3RFeGlzdFBhcnRJZCA9IHt9O1xuICAgIHRoaXMuX25vdEV4aXN0UGFyYW1ldGVySWQgPSB7fTtcbiAgICB0aGlzLl9ub3RFeGlzdFBhcmFtZXRlclZhbHVlcyA9IHt9O1xuICAgIHRoaXMuX25vdEV4aXN0UGFydE9wYWNpdGllcyA9IHt9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIHJlbGVhc2UoKSB7XG4gICAgdGhpcy5fbW9kZWwucmVsZWFzZSgpO1xuICAgIHRoaXMuX21vZGVsID0gdm9pZCAwO1xuICB9XG59XG5jbGFzcyBDdWJpc21Nb2Mge1xuICBzdGF0aWMgY3JlYXRlKG1vY0J5dGVzKSB7XG4gICAgY29uc3QgbW9jID0gTGl2ZTJEQ3ViaXNtQ29yZS5Nb2MuZnJvbUFycmF5QnVmZmVyKG1vY0J5dGVzKTtcbiAgICBpZiAobW9jKSB7XG4gICAgICByZXR1cm4gbmV3IEN1YmlzbU1vYyhtb2MpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGVycm9yXCIpO1xuICB9XG4gIGNyZWF0ZU1vZGVsKCkge1xuICAgIGxldCBjdWJpc21Nb2RlbDtcbiAgICBjb25zdCBtb2RlbCA9IExpdmUyREN1YmlzbUNvcmUuTW9kZWwuZnJvbU1vYyh0aGlzLl9tb2MpO1xuICAgIGlmIChtb2RlbCkge1xuICAgICAgY3ViaXNtTW9kZWwgPSBuZXcgQ3ViaXNtTW9kZWwobW9kZWwpO1xuICAgICAgKyt0aGlzLl9tb2RlbENvdW50O1xuICAgICAgcmV0dXJuIGN1YmlzbU1vZGVsO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGVycm9yXCIpO1xuICB9XG4gIGRlbGV0ZU1vZGVsKG1vZGVsKSB7XG4gICAgaWYgKG1vZGVsICE9IG51bGwpIHtcbiAgICAgIC0tdGhpcy5fbW9kZWxDb3VudDtcbiAgICB9XG4gIH1cbiAgY29uc3RydWN0b3IobW9jKSB7XG4gICAgdGhpcy5fbW9jID0gbW9jO1xuICAgIHRoaXMuX21vZGVsQ291bnQgPSAwO1xuICB9XG4gIHJlbGVhc2UoKSB7XG4gICAgdGhpcy5fbW9jLl9yZWxlYXNlKCk7XG4gICAgdGhpcy5fbW9jID0gdm9pZCAwO1xuICB9XG59XG5jbGFzcyBDdWJpc21Nb2RlbFVzZXJEYXRhSnNvbiB7XG4gIGNvbnN0cnVjdG9yKGpzb24sIHNpemUpIHtcbiAgICB0aGlzLl9qc29uID0ganNvbjtcbiAgfVxuICByZWxlYXNlKCkge1xuICAgIHRoaXMuX2pzb24gPSB2b2lkIDA7XG4gIH1cbiAgZ2V0VXNlckRhdGFDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fanNvbi5NZXRhLlVzZXJEYXRhQ291bnQ7XG4gIH1cbiAgZ2V0VG90YWxVc2VyRGF0YVNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2pzb24uTWV0YS5Ub3RhbFVzZXJEYXRhU2l6ZTtcbiAgfVxuICBnZXRVc2VyRGF0YVRhcmdldFR5cGUoaSkge1xuICAgIHJldHVybiB0aGlzLl9qc29uLlVzZXJEYXRhW2ldLlRhcmdldDtcbiAgfVxuICBnZXRVc2VyRGF0YUlkKGkpIHtcbiAgICByZXR1cm4gdGhpcy5fanNvbi5Vc2VyRGF0YVtpXS5JZDtcbiAgfVxuICBnZXRVc2VyRGF0YVZhbHVlKGkpIHtcbiAgICByZXR1cm4gdGhpcy5fanNvbi5Vc2VyRGF0YVtpXS5WYWx1ZTtcbiAgfVxufVxuY29uc3QgQXJ0TWVzaCA9IFwiQXJ0TWVzaFwiO1xuY2xhc3MgQ3ViaXNtTW9kZWxVc2VyRGF0YSB7XG4gIHN0YXRpYyBjcmVhdGUoanNvbiwgc2l6ZSkge1xuICAgIGNvbnN0IHJldCA9IG5ldyBDdWJpc21Nb2RlbFVzZXJEYXRhKCk7XG4gICAgcmV0LnBhcnNlVXNlckRhdGEoanNvbiwgc2l6ZSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBnZXRBcnRNZXNoVXNlckRhdGFzKCkge1xuICAgIHJldHVybiB0aGlzLl9hcnRNZXNoVXNlckRhdGFOb2RlO1xuICB9XG4gIHBhcnNlVXNlckRhdGEoZGF0YSwgc2l6ZSkge1xuICAgIGxldCBqc29uID0gbmV3IEN1YmlzbU1vZGVsVXNlckRhdGFKc29uKGRhdGEsIHNpemUpO1xuICAgIGNvbnN0IHR5cGVPZkFydE1lc2ggPSBBcnRNZXNoO1xuICAgIGNvbnN0IG5vZGVDb3VudCA9IGpzb24uZ2V0VXNlckRhdGFDb3VudCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZUNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGFkZE5vZGUgPSB7XG4gICAgICAgIHRhcmdldElkOiBqc29uLmdldFVzZXJEYXRhSWQoaSksXG4gICAgICAgIHRhcmdldFR5cGU6IGpzb24uZ2V0VXNlckRhdGFUYXJnZXRUeXBlKGkpLFxuICAgICAgICB2YWx1ZToganNvbi5nZXRVc2VyRGF0YVZhbHVlKGkpXG4gICAgICB9O1xuICAgICAgdGhpcy5fdXNlckRhdGFOb2Rlcy5wdXNoKGFkZE5vZGUpO1xuICAgICAgaWYgKGFkZE5vZGUudGFyZ2V0VHlwZSA9PSB0eXBlT2ZBcnRNZXNoKSB7XG4gICAgICAgIHRoaXMuX2FydE1lc2hVc2VyRGF0YU5vZGUucHVzaChhZGROb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAganNvbi5yZWxlYXNlKCk7XG4gIH1cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fdXNlckRhdGFOb2RlcyA9IFtdO1xuICAgIHRoaXMuX2FydE1lc2hVc2VyRGF0YU5vZGUgPSBbXTtcbiAgfVxuICByZWxlYXNlKCkge1xuICAgIHRoaXMuX3VzZXJEYXRhTm9kZXMgPSBudWxsO1xuICB9XG59XG5jbGFzcyBBQ3ViaXNtTW90aW9uIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fZmFkZUluU2Vjb25kcyA9IC0xO1xuICAgIHRoaXMuX2ZhZGVPdXRTZWNvbmRzID0gLTE7XG4gICAgdGhpcy5fd2VpZ2h0ID0gMTtcbiAgICB0aGlzLl9vZmZzZXRTZWNvbmRzID0gMDtcbiAgICB0aGlzLl9maXJlZEV2ZW50VmFsdWVzID0gW107XG4gIH1cbiAgcmVsZWFzZSgpIHtcbiAgICB0aGlzLl93ZWlnaHQgPSAwO1xuICB9XG4gIHVwZGF0ZVBhcmFtZXRlcnMobW9kZWwsIG1vdGlvblF1ZXVlRW50cnksIHVzZXJUaW1lU2Vjb25kcykge1xuICAgIGlmICghbW90aW9uUXVldWVFbnRyeS5pc0F2YWlsYWJsZSgpIHx8IG1vdGlvblF1ZXVlRW50cnkuaXNGaW5pc2hlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghbW90aW9uUXVldWVFbnRyeS5pc1N0YXJ0ZWQoKSkge1xuICAgICAgbW90aW9uUXVldWVFbnRyeS5zZXRJc1N0YXJ0ZWQodHJ1ZSk7XG4gICAgICBtb3Rpb25RdWV1ZUVudHJ5LnNldFN0YXJ0VGltZSh1c2VyVGltZVNlY29uZHMgLSB0aGlzLl9vZmZzZXRTZWNvbmRzKTtcbiAgICAgIG1vdGlvblF1ZXVlRW50cnkuc2V0RmFkZUluU3RhcnRUaW1lKHVzZXJUaW1lU2Vjb25kcyk7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuZ2V0RHVyYXRpb24oKTtcbiAgICAgIGlmIChtb3Rpb25RdWV1ZUVudHJ5LmdldEVuZFRpbWUoKSA8IDApIHtcbiAgICAgICAgbW90aW9uUXVldWVFbnRyeS5zZXRFbmRUaW1lKGR1cmF0aW9uIDw9IDAgPyAtMSA6IG1vdGlvblF1ZXVlRW50cnkuZ2V0U3RhcnRUaW1lKCkgKyBkdXJhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBmYWRlV2VpZ2h0ID0gdGhpcy5fd2VpZ2h0O1xuICAgIGNvbnN0IGZhZGVJbiA9IHRoaXMuX2ZhZGVJblNlY29uZHMgPT0gMCA/IDEgOiBDdWJpc21NYXRoLmdldEVhc2luZ1NpbmUoKHVzZXJUaW1lU2Vjb25kcyAtIG1vdGlvblF1ZXVlRW50cnkuZ2V0RmFkZUluU3RhcnRUaW1lKCkpIC8gdGhpcy5fZmFkZUluU2Vjb25kcyk7XG4gICAgY29uc3QgZmFkZU91dCA9IHRoaXMuX2ZhZGVPdXRTZWNvbmRzID09IDAgfHwgbW90aW9uUXVldWVFbnRyeS5nZXRFbmRUaW1lKCkgPCAwID8gMSA6IEN1YmlzbU1hdGguZ2V0RWFzaW5nU2luZSgobW90aW9uUXVldWVFbnRyeS5nZXRFbmRUaW1lKCkgLSB1c2VyVGltZVNlY29uZHMpIC8gdGhpcy5fZmFkZU91dFNlY29uZHMpO1xuICAgIGZhZGVXZWlnaHQgPSBmYWRlV2VpZ2h0ICogZmFkZUluICogZmFkZU91dDtcbiAgICBtb3Rpb25RdWV1ZUVudHJ5LnNldFN0YXRlKHVzZXJUaW1lU2Vjb25kcywgZmFkZVdlaWdodCk7XG4gICAgdGhpcy5kb1VwZGF0ZVBhcmFtZXRlcnMobW9kZWwsIHVzZXJUaW1lU2Vjb25kcywgZmFkZVdlaWdodCwgbW90aW9uUXVldWVFbnRyeSk7XG4gICAgaWYgKG1vdGlvblF1ZXVlRW50cnkuZ2V0RW5kVGltZSgpID4gMCAmJiBtb3Rpb25RdWV1ZUVudHJ5LmdldEVuZFRpbWUoKSA8IHVzZXJUaW1lU2Vjb25kcykge1xuICAgICAgbW90aW9uUXVldWVFbnRyeS5zZXRJc0ZpbmlzaGVkKHRydWUpO1xuICAgIH1cbiAgfVxuICBzZXRGYWRlSW5UaW1lKGZhZGVJblNlY29uZHMpIHtcbiAgICB0aGlzLl9mYWRlSW5TZWNvbmRzID0gZmFkZUluU2Vjb25kcztcbiAgfVxuICBzZXRGYWRlT3V0VGltZShmYWRlT3V0U2Vjb25kcykge1xuICAgIHRoaXMuX2ZhZGVPdXRTZWNvbmRzID0gZmFkZU91dFNlY29uZHM7XG4gIH1cbiAgZ2V0RmFkZU91dFRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZhZGVPdXRTZWNvbmRzO1xuICB9XG4gIGdldEZhZGVJblRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZhZGVJblNlY29uZHM7XG4gIH1cbiAgc2V0V2VpZ2h0KHdlaWdodCkge1xuICAgIHRoaXMuX3dlaWdodCA9IHdlaWdodDtcbiAgfVxuICBnZXRXZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlaWdodDtcbiAgfVxuICBnZXREdXJhdGlvbigpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgZ2V0TG9vcER1cmF0aW9uKCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBzZXRPZmZzZXRUaW1lKG9mZnNldFNlY29uZHMpIHtcbiAgICB0aGlzLl9vZmZzZXRTZWNvbmRzID0gb2Zmc2V0U2Vjb25kcztcbiAgfVxuICBnZXRGaXJlZEV2ZW50KGJlZm9yZUNoZWNrVGltZVNlY29uZHMsIG1vdGlvblRpbWVTZWNvbmRzKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpcmVkRXZlbnRWYWx1ZXM7XG4gIH1cbiAgc2V0RmluaXNoZWRNb3Rpb25IYW5kbGVyKG9uRmluaXNoZWRNb3Rpb25IYW5kbGVyKSB7XG4gICAgdGhpcy5fb25GaW5pc2hlZE1vdGlvbiA9IG9uRmluaXNoZWRNb3Rpb25IYW5kbGVyO1xuICB9XG4gIGdldEZpbmlzaGVkTW90aW9uSGFuZGxlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fb25GaW5pc2hlZE1vdGlvbjtcbiAgfVxufVxuY29uc3QgRGVmYXVsdEZhZGVUaW1lID0gMTtcbmNsYXNzIEN1YmlzbUV4cHJlc3Npb25Nb3Rpb24gZXh0ZW5kcyBBQ3ViaXNtTW90aW9uIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9wYXJhbWV0ZXJzID0gW107XG4gIH1cbiAgc3RhdGljIGNyZWF0ZShqc29uKSB7XG4gICAgY29uc3QgZXhwcmVzc2lvbiA9IG5ldyBDdWJpc21FeHByZXNzaW9uTW90aW9uKCk7XG4gICAgY29uc3QgZmFkZUluVGltZSA9IGpzb24uRmFkZUluVGltZTtcbiAgICBjb25zdCBmYWRlT3V0VGltZSA9IGpzb24uRmFkZU91dFRpbWU7XG4gICAgZXhwcmVzc2lvbi5zZXRGYWRlSW5UaW1lKGZhZGVJblRpbWUgIT09IHZvaWQgMCA/IGZhZGVJblRpbWUgOiBEZWZhdWx0RmFkZVRpbWUpO1xuICAgIGV4cHJlc3Npb24uc2V0RmFkZU91dFRpbWUoZmFkZU91dFRpbWUgIT09IHZvaWQgMCA/IGZhZGVPdXRUaW1lIDogRGVmYXVsdEZhZGVUaW1lKTtcbiAgICBjb25zdCBwYXJhbWV0ZXJzID0ganNvbi5QYXJhbWV0ZXJzIHx8IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1ldGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgcGFyYW0gPSBwYXJhbWV0ZXJzW2ldO1xuICAgICAgY29uc3QgcGFyYW1ldGVySWQgPSBwYXJhbS5JZDtcbiAgICAgIGNvbnN0IHZhbHVlID0gcGFyYW0uVmFsdWU7XG4gICAgICBsZXQgYmxlbmRUeXBlO1xuICAgICAgc3dpdGNoIChwYXJhbS5CbGVuZCkge1xuICAgICAgICBjYXNlIFwiTXVsdGlwbHlcIjpcbiAgICAgICAgICBibGVuZFR5cGUgPSBFeHByZXNzaW9uQmxlbmRUeXBlLkV4cHJlc3Npb25CbGVuZFR5cGVfTXVsdGlwbHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJPdmVyd3JpdGVcIjpcbiAgICAgICAgICBibGVuZFR5cGUgPSBFeHByZXNzaW9uQmxlbmRUeXBlLkV4cHJlc3Npb25CbGVuZFR5cGVfT3ZlcndyaXRlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQWRkXCI6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYmxlbmRUeXBlID0gRXhwcmVzc2lvbkJsZW5kVHlwZS5FeHByZXNzaW9uQmxlbmRUeXBlX0FkZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICAgIHBhcmFtZXRlcklkLFxuICAgICAgICBibGVuZFR5cGUsXG4gICAgICAgIHZhbHVlXG4gICAgICB9O1xuICAgICAgZXhwcmVzc2lvbi5fcGFyYW1ldGVycy5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgfVxuICBkb1VwZGF0ZVBhcmFtZXRlcnMobW9kZWwsIHVzZXJUaW1lU2Vjb25kcywgd2VpZ2h0LCBtb3Rpb25RdWV1ZUVudHJ5KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9wYXJhbWV0ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBwYXJhbWV0ZXIgPSB0aGlzLl9wYXJhbWV0ZXJzW2ldO1xuICAgICAgc3dpdGNoIChwYXJhbWV0ZXIuYmxlbmRUeXBlKSB7XG4gICAgICAgIGNhc2UgRXhwcmVzc2lvbkJsZW5kVHlwZS5FeHByZXNzaW9uQmxlbmRUeXBlX0FkZDoge1xuICAgICAgICAgIG1vZGVsLmFkZFBhcmFtZXRlclZhbHVlQnlJZChwYXJhbWV0ZXIucGFyYW1ldGVySWQsIHBhcmFtZXRlci52YWx1ZSwgd2VpZ2h0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIEV4cHJlc3Npb25CbGVuZFR5cGUuRXhwcmVzc2lvbkJsZW5kVHlwZV9NdWx0aXBseToge1xuICAgICAgICAgIG1vZGVsLm11bHRpcGx5UGFyYW1ldGVyVmFsdWVCeUlkKHBhcmFtZXRlci5wYXJhbWV0ZXJJZCwgcGFyYW1ldGVyLnZhbHVlLCB3ZWlnaHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgRXhwcmVzc2lvbkJsZW5kVHlwZS5FeHByZXNzaW9uQmxlbmRUeXBlX092ZXJ3cml0ZToge1xuICAgICAgICAgIG1vZGVsLnNldFBhcmFtZXRlclZhbHVlQnlJZChwYXJhbWV0ZXIucGFyYW1ldGVySWQsIHBhcmFtZXRlci52YWx1ZSwgd2VpZ2h0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxudmFyIEV4cHJlc3Npb25CbGVuZFR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChFeHByZXNzaW9uQmxlbmRUeXBlMikgPT4ge1xuICBFeHByZXNzaW9uQmxlbmRUeXBlMltFeHByZXNzaW9uQmxlbmRUeXBlMltcIkV4cHJlc3Npb25CbGVuZFR5cGVfQWRkXCJdID0gMF0gPSBcIkV4cHJlc3Npb25CbGVuZFR5cGVfQWRkXCI7XG4gIEV4cHJlc3Npb25CbGVuZFR5cGUyW0V4cHJlc3Npb25CbGVuZFR5cGUyW1wiRXhwcmVzc2lvbkJsZW5kVHlwZV9NdWx0aXBseVwiXSA9IDFdID0gXCJFeHByZXNzaW9uQmxlbmRUeXBlX011bHRpcGx5XCI7XG4gIEV4cHJlc3Npb25CbGVuZFR5cGUyW0V4cHJlc3Npb25CbGVuZFR5cGUyW1wiRXhwcmVzc2lvbkJsZW5kVHlwZV9PdmVyd3JpdGVcIl0gPSAyXSA9IFwiRXhwcmVzc2lvbkJsZW5kVHlwZV9PdmVyd3JpdGVcIjtcbiAgcmV0dXJuIEV4cHJlc3Npb25CbGVuZFR5cGUyO1xufSkoRXhwcmVzc2lvbkJsZW5kVHlwZSB8fCB7fSk7XG52YXIgQ3ViaXNtQ29uZmlnO1xuKChDdWJpc21Db25maWcyKSA9PiB7XG4gIEN1YmlzbUNvbmZpZzIuc3VwcG9ydE1vcmVNYXNrRGl2aXNpb25zID0gdHJ1ZTtcbiAgQ3ViaXNtQ29uZmlnMi5zZXRPcGFjaXR5RnJvbU1vdGlvbiA9IGZhbHNlO1xufSkoQ3ViaXNtQ29uZmlnIHx8IChDdWJpc21Db25maWcgPSB7fSkpO1xudmFyIEN1YmlzbU1vdGlvbkN1cnZlVGFyZ2V0ID0gLyogQF9fUFVSRV9fICovICgoQ3ViaXNtTW90aW9uQ3VydmVUYXJnZXQyKSA9PiB7XG4gIEN1YmlzbU1vdGlvbkN1cnZlVGFyZ2V0MltDdWJpc21Nb3Rpb25DdXJ2ZVRhcmdldDJbXCJDdWJpc21Nb3Rpb25DdXJ2ZVRhcmdldF9Nb2RlbFwiXSA9IDBdID0gXCJDdWJpc21Nb3Rpb25DdXJ2ZVRhcmdldF9Nb2RlbFwiO1xuICBDdWJpc21Nb3Rpb25DdXJ2ZVRhcmdldDJbQ3ViaXNtTW90aW9uQ3VydmVUYXJnZXQyW1wiQ3ViaXNtTW90aW9uQ3VydmVUYXJnZXRfUGFyYW1ldGVyXCJdID0gMV0gPSBcIkN1YmlzbU1vdGlvbkN1cnZlVGFyZ2V0X1BhcmFtZXRlclwiO1xuICBDdWJpc21Nb3Rpb25DdXJ2ZVRhcmdldDJbQ3ViaXNtTW90aW9uQ3VydmVUYXJnZXQyW1wiQ3ViaXNtTW90aW9uQ3VydmVUYXJnZXRfUGFydE9wYWNpdHlcIl0gPSAyXSA9IFwiQ3ViaXNtTW90aW9uQ3VydmVUYXJnZXRfUGFydE9wYWNpdHlcIjtcbiAgcmV0dXJuIEN1YmlzbU1vdGlvbkN1cnZlVGFyZ2V0Mjtcbn0pKEN1YmlzbU1vdGlvbkN1cnZlVGFyZ2V0IHx8IHt9KTtcbnZhciBDdWJpc21Nb3Rpb25TZWdtZW50VHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEN1YmlzbU1vdGlvblNlZ21lbnRUeXBlMikgPT4ge1xuICBDdWJpc21Nb3Rpb25TZWdtZW50VHlwZTJbQ3ViaXNtTW90aW9uU2VnbWVudFR5cGUyW1wiQ3ViaXNtTW90aW9uU2VnbWVudFR5cGVfTGluZWFyXCJdID0gMF0gPSBcIkN1YmlzbU1vdGlvblNlZ21lbnRUeXBlX0xpbmVhclwiO1xuICBDdWJpc21Nb3Rpb25TZWdtZW50VHlwZTJbQ3ViaXNtTW90aW9uU2VnbWVudFR5cGUyW1wiQ3ViaXNtTW90aW9uU2VnbWVudFR5cGVfQmV6aWVyXCJdID0gMV0gPSBcIkN1YmlzbU1vdGlvblNlZ21lbnRUeXBlX0JlemllclwiO1xuICBDdWJpc21Nb3Rpb25TZWdtZW50VHlwZTJbQ3ViaXNtTW90aW9uU2VnbWVudFR5cGUyW1wiQ3ViaXNtTW90aW9uU2VnbWVudFR5cGVfU3RlcHBlZFwiXSA9IDJdID0gXCJDdWJpc21Nb3Rpb25TZWdtZW50VHlwZV9TdGVwcGVkXCI7XG4gIEN1YmlzbU1vdGlvblNlZ21lbnRUeXBlMltDdWJpc21Nb3Rpb25TZWdtZW50VHlwZTJbXCJDdWJpc21Nb3Rpb25TZWdtZW50VHlwZV9JbnZlcnNlU3RlcHBlZFwiXSA9IDNdID0gXCJDdWJpc21Nb3Rpb25TZWdtZW50VHlwZV9JbnZlcnNlU3RlcHBlZFwiO1xuICByZXR1cm4gQ3ViaXNtTW90aW9uU2VnbWVudFR5cGUyO1xufSkoQ3ViaXNtTW90aW9uU2VnbWVudFR5cGUgfHwge30pO1xuY2xhc3MgQ3ViaXNtTW90aW9uUG9pbnQge1xuICBjb25zdHJ1Y3Rvcih0aW1lID0gMCwgdmFsdWUgPSAwKSB7XG4gICAgdGhpcy50aW1lID0gdGltZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cbn1cbmNsYXNzIEN1YmlzbU1vdGlvblNlZ21lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmJhc2VQb2ludEluZGV4ID0gMDtcbiAgICB0aGlzLnNlZ21lbnRUeXBlID0gMDtcbiAgfVxufVxuY2xhc3MgQ3ViaXNtTW90aW9uQ3VydmUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmlkID0gXCJcIjtcbiAgICB0aGlzLnR5cGUgPSAwO1xuICAgIHRoaXMuc2VnbWVudENvdW50ID0gMDtcbiAgICB0aGlzLmJhc2VTZWdtZW50SW5kZXggPSAwO1xuICAgIHRoaXMuZmFkZUluVGltZSA9IDA7XG4gICAgdGhpcy5mYWRlT3V0VGltZSA9IDA7XG4gIH1cbn1cbmNsYXNzIEN1YmlzbU1vdGlvbkV2ZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5maXJlVGltZSA9IDA7XG4gICAgdGhpcy52YWx1ZSA9IFwiXCI7XG4gIH1cbn1cbmNsYXNzIEN1YmlzbU1vdGlvbkRhdGEge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmR1cmF0aW9uID0gMDtcbiAgICB0aGlzLmxvb3AgPSBmYWxzZTtcbiAgICB0aGlzLmN1cnZlQ291bnQgPSAwO1xuICAgIHRoaXMuZXZlbnRDb3VudCA9IDA7XG4gICAgdGhpcy5mcHMgPSAwO1xuICAgIHRoaXMuY3VydmVzID0gW107XG4gICAgdGhpcy5zZWdtZW50cyA9IFtdO1xuICAgIHRoaXMucG9pbnRzID0gW107XG4gICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgfVxufVxuY2xhc3MgQ3ViaXNtTW90aW9uSnNvbiB7XG4gIGNvbnN0cnVjdG9yKGpzb24pIHtcbiAgICB0aGlzLl9qc29uID0ganNvbjtcbiAgfVxuICByZWxlYXNlKCkge1xuICAgIHRoaXMuX2pzb24gPSB2b2lkIDA7XG4gIH1cbiAgZ2V0TW90aW9uRHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2pzb24uTWV0YS5EdXJhdGlvbjtcbiAgfVxuICBpc01vdGlvbkxvb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2pzb24uTWV0YS5Mb29wIHx8IGZhbHNlO1xuICB9XG4gIGdldEV2YWx1YXRpb25PcHRpb25GbGFnKGZsYWdUeXBlKSB7XG4gICAgaWYgKEV2YWx1YXRpb25PcHRpb25GbGFnLkV2YWx1YXRpb25PcHRpb25GbGFnX0FyZUJlemllcnNSaXN0cmljdGVkID09IGZsYWdUeXBlKSB7XG4gICAgICByZXR1cm4gISF0aGlzLl9qc29uLk1ldGEuQXJlQmV6aWVyc1Jlc3RyaWN0ZWQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXRNb3Rpb25DdXJ2ZUNvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9qc29uLk1ldGEuQ3VydmVDb3VudDtcbiAgfVxuICBnZXRNb3Rpb25GcHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2pzb24uTWV0YS5GcHM7XG4gIH1cbiAgZ2V0TW90aW9uVG90YWxTZWdtZW50Q291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2pzb24uTWV0YS5Ub3RhbFNlZ21lbnRDb3VudDtcbiAgfVxuICBnZXRNb3Rpb25Ub3RhbFBvaW50Q291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2pzb24uTWV0YS5Ub3RhbFBvaW50Q291bnQ7XG4gIH1cbiAgZ2V0TW90aW9uRmFkZUluVGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fanNvbi5NZXRhLkZhZGVJblRpbWU7XG4gIH1cbiAgZ2V0TW90aW9uRmFkZU91dFRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2pzb24uTWV0YS5GYWRlT3V0VGltZTtcbiAgfVxuICBnZXRNb3Rpb25DdXJ2ZVRhcmdldChjdXJ2ZUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2pzb24uQ3VydmVzW2N1cnZlSW5kZXhdLlRhcmdldDtcbiAgfVxuICBnZXRNb3Rpb25DdXJ2ZUlkKGN1cnZlSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fanNvbi5DdXJ2ZXNbY3VydmVJbmRleF0uSWQ7XG4gIH1cbiAgZ2V0TW90aW9uQ3VydmVGYWRlSW5UaW1lKGN1cnZlSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fanNvbi5DdXJ2ZXNbY3VydmVJbmRleF0uRmFkZUluVGltZTtcbiAgfVxuICBnZXRNb3Rpb25DdXJ2ZUZhZGVPdXRUaW1lKGN1cnZlSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fanNvbi5DdXJ2ZXNbY3VydmVJbmRleF0uRmFkZU91dFRpbWU7XG4gIH1cbiAgZ2V0TW90aW9uQ3VydmVTZWdtZW50Q291bnQoY3VydmVJbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9qc29uLkN1cnZlc1tjdXJ2ZUluZGV4XS5TZWdtZW50cy5sZW5ndGg7XG4gIH1cbiAgZ2V0TW90aW9uQ3VydmVTZWdtZW50KGN1cnZlSW5kZXgsIHNlZ21lbnRJbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9qc29uLkN1cnZlc1tjdXJ2ZUluZGV4XS5TZWdtZW50c1tzZWdtZW50SW5kZXhdO1xuICB9XG4gIGdldEV2ZW50Q291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2pzb24uTWV0YS5Vc2VyRGF0YUNvdW50IHx8IDA7XG4gIH1cbiAgZ2V0VG90YWxFdmVudFZhbHVlU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fanNvbi5NZXRhLlRvdGFsVXNlckRhdGFTaXplO1xuICB9XG4gIGdldEV2ZW50VGltZSh1c2VyRGF0YUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2pzb24uVXNlckRhdGFbdXNlckRhdGFJbmRleF0uVGltZTtcbiAgfVxuICBnZXRFdmVudFZhbHVlKHVzZXJEYXRhSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fanNvbi5Vc2VyRGF0YVt1c2VyRGF0YUluZGV4XS5WYWx1ZTtcbiAgfVxufVxudmFyIEV2YWx1YXRpb25PcHRpb25GbGFnID0gLyogQF9fUFVSRV9fICovICgoRXZhbHVhdGlvbk9wdGlvbkZsYWcyKSA9PiB7XG4gIEV2YWx1YXRpb25PcHRpb25GbGFnMltFdmFsdWF0aW9uT3B0aW9uRmxhZzJbXCJFdmFsdWF0aW9uT3B0aW9uRmxhZ19BcmVCZXppZXJzUmlzdHJpY3RlZFwiXSA9IDBdID0gXCJFdmFsdWF0aW9uT3B0aW9uRmxhZ19BcmVCZXppZXJzUmlzdHJpY3RlZFwiO1xuICByZXR1cm4gRXZhbHVhdGlvbk9wdGlvbkZsYWcyO1xufSkoRXZhbHVhdGlvbk9wdGlvbkZsYWcgfHwge30pO1xuY29uc3QgRWZmZWN0TmFtZUV5ZUJsaW5rID0gXCJFeWVCbGlua1wiO1xuY29uc3QgRWZmZWN0TmFtZUxpcFN5bmMgPSBcIkxpcFN5bmNcIjtcbmNvbnN0IFRhcmdldE5hbWVNb2RlbCA9IFwiTW9kZWxcIjtcbmNvbnN0IFRhcmdldE5hbWVQYXJhbWV0ZXIgPSBcIlBhcmFtZXRlclwiO1xuY29uc3QgVGFyZ2V0TmFtZVBhcnRPcGFjaXR5ID0gXCJQYXJ0T3BhY2l0eVwiO1xuY29uc3QgVXNlT2xkQmV6aWVyc0N1cnZlTW90aW9uID0gZmFsc2U7XG5mdW5jdGlvbiBsZXJwUG9pbnRzKGEsIGIsIHQpIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IEN1YmlzbU1vdGlvblBvaW50KCk7XG4gIHJlc3VsdC50aW1lID0gYS50aW1lICsgKGIudGltZSAtIGEudGltZSkgKiB0O1xuICByZXN1bHQudmFsdWUgPSBhLnZhbHVlICsgKGIudmFsdWUgLSBhLnZhbHVlKSAqIHQ7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBsaW5lYXJFdmFsdWF0ZShwb2ludHMsIHRpbWUpIHtcbiAgbGV0IHQgPSAodGltZSAtIHBvaW50c1swXS50aW1lKSAvIChwb2ludHNbMV0udGltZSAtIHBvaW50c1swXS50aW1lKTtcbiAgaWYgKHQgPCAwKSB7XG4gICAgdCA9IDA7XG4gIH1cbiAgcmV0dXJuIHBvaW50c1swXS52YWx1ZSArIChwb2ludHNbMV0udmFsdWUgLSBwb2ludHNbMF0udmFsdWUpICogdDtcbn1cbmZ1bmN0aW9uIGJlemllckV2YWx1YXRlKHBvaW50cywgdGltZSkge1xuICBsZXQgdCA9ICh0aW1lIC0gcG9pbnRzWzBdLnRpbWUpIC8gKHBvaW50c1szXS50aW1lIC0gcG9pbnRzWzBdLnRpbWUpO1xuICBpZiAodCA8IDApIHtcbiAgICB0ID0gMDtcbiAgfVxuICBjb25zdCBwMDEgPSBsZXJwUG9pbnRzKHBvaW50c1swXSwgcG9pbnRzWzFdLCB0KTtcbiAgY29uc3QgcDEyID0gbGVycFBvaW50cyhwb2ludHNbMV0sIHBvaW50c1syXSwgdCk7XG4gIGNvbnN0IHAyMyA9IGxlcnBQb2ludHMocG9pbnRzWzJdLCBwb2ludHNbM10sIHQpO1xuICBjb25zdCBwMDEyID0gbGVycFBvaW50cyhwMDEsIHAxMiwgdCk7XG4gIGNvbnN0IHAxMjMgPSBsZXJwUG9pbnRzKHAxMiwgcDIzLCB0KTtcbiAgcmV0dXJuIGxlcnBQb2ludHMocDAxMiwgcDEyMywgdCkudmFsdWU7XG59XG5mdW5jdGlvbiBiZXppZXJFdmFsdWF0ZUNhcmRhbm9JbnRlcnByZXRhdGlvbihwb2ludHMsIHRpbWUpIHtcbiAgY29uc3QgeCA9IHRpbWU7XG4gIGNvbnN0IHgxID0gcG9pbnRzWzBdLnRpbWU7XG4gIGNvbnN0IHgyID0gcG9pbnRzWzNdLnRpbWU7XG4gIGNvbnN0IGN4MSA9IHBvaW50c1sxXS50aW1lO1xuICBjb25zdCBjeDIgPSBwb2ludHNbMl0udGltZTtcbiAgY29uc3QgYSA9IHgyIC0gMyAqIGN4MiArIDMgKiBjeDEgLSB4MTtcbiAgY29uc3QgYiA9IDMgKiBjeDIgLSA2ICogY3gxICsgMyAqIHgxO1xuICBjb25zdCBjID0gMyAqIGN4MSAtIDMgKiB4MTtcbiAgY29uc3QgZCA9IHgxIC0geDtcbiAgY29uc3QgdCA9IEN1YmlzbU1hdGguY2FyZGFub0FsZ29yaXRobUZvckJlemllcihhLCBiLCBjLCBkKTtcbiAgY29uc3QgcDAxID0gbGVycFBvaW50cyhwb2ludHNbMF0sIHBvaW50c1sxXSwgdCk7XG4gIGNvbnN0IHAxMiA9IGxlcnBQb2ludHMocG9pbnRzWzFdLCBwb2ludHNbMl0sIHQpO1xuICBjb25zdCBwMjMgPSBsZXJwUG9pbnRzKHBvaW50c1syXSwgcG9pbnRzWzNdLCB0KTtcbiAgY29uc3QgcDAxMiA9IGxlcnBQb2ludHMocDAxLCBwMTIsIHQpO1xuICBjb25zdCBwMTIzID0gbGVycFBvaW50cyhwMTIsIHAyMywgdCk7XG4gIHJldHVybiBsZXJwUG9pbnRzKHAwMTIsIHAxMjMsIHQpLnZhbHVlO1xufVxuZnVuY3Rpb24gc3RlcHBlZEV2YWx1YXRlKHBvaW50cywgdGltZSkge1xuICByZXR1cm4gcG9pbnRzWzBdLnZhbHVlO1xufVxuZnVuY3Rpb24gaW52ZXJzZVN0ZXBwZWRFdmFsdWF0ZShwb2ludHMsIHRpbWUpIHtcbiAgcmV0dXJuIHBvaW50c1sxXS52YWx1ZTtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlQ3VydmUobW90aW9uRGF0YSwgaW5kZXgsIHRpbWUpIHtcbiAgY29uc3QgY3VydmUgPSBtb3Rpb25EYXRhLmN1cnZlc1tpbmRleF07XG4gIGxldCB0YXJnZXQgPSAtMTtcbiAgY29uc3QgdG90YWxTZWdtZW50Q291bnQgPSBjdXJ2ZS5iYXNlU2VnbWVudEluZGV4ICsgY3VydmUuc2VnbWVudENvdW50O1xuICBsZXQgcG9pbnRQb3NpdGlvbiA9IDA7XG4gIGZvciAobGV0IGkgPSBjdXJ2ZS5iYXNlU2VnbWVudEluZGV4OyBpIDwgdG90YWxTZWdtZW50Q291bnQ7ICsraSkge1xuICAgIHBvaW50UG9zaXRpb24gPSBtb3Rpb25EYXRhLnNlZ21lbnRzW2ldLmJhc2VQb2ludEluZGV4ICsgKG1vdGlvbkRhdGEuc2VnbWVudHNbaV0uc2VnbWVudFR5cGUgPT0gQ3ViaXNtTW90aW9uU2VnbWVudFR5cGUuQ3ViaXNtTW90aW9uU2VnbWVudFR5cGVfQmV6aWVyID8gMyA6IDEpO1xuICAgIGlmIChtb3Rpb25EYXRhLnBvaW50c1twb2ludFBvc2l0aW9uXS50aW1lID4gdGltZSkge1xuICAgICAgdGFyZ2V0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAodGFyZ2V0ID09IC0xKSB7XG4gICAgcmV0dXJuIG1vdGlvbkRhdGEucG9pbnRzW3BvaW50UG9zaXRpb25dLnZhbHVlO1xuICB9XG4gIGNvbnN0IHNlZ21lbnQgPSBtb3Rpb25EYXRhLnNlZ21lbnRzW3RhcmdldF07XG4gIHJldHVybiBzZWdtZW50LmV2YWx1YXRlKG1vdGlvbkRhdGEucG9pbnRzLnNsaWNlKHNlZ21lbnQuYmFzZVBvaW50SW5kZXgpLCB0aW1lKTtcbn1cbmNsYXNzIEN1YmlzbU1vdGlvbiBleHRlbmRzIEFDdWJpc21Nb3Rpb24ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2V5ZUJsaW5rUGFyYW1ldGVySWRzID0gW107XG4gICAgdGhpcy5fbGlwU3luY1BhcmFtZXRlcklkcyA9IFtdO1xuICAgIHRoaXMuX3NvdXJjZUZyYW1lUmF0ZSA9IDMwO1xuICAgIHRoaXMuX2xvb3BEdXJhdGlvblNlY29uZHMgPSAtMTtcbiAgICB0aGlzLl9pc0xvb3AgPSBmYWxzZTtcbiAgICB0aGlzLl9pc0xvb3BGYWRlSW4gPSB0cnVlO1xuICAgIHRoaXMuX2xhc3RXZWlnaHQgPSAwO1xuICB9XG4gIHN0YXRpYyBjcmVhdGUoanNvbiwgb25GaW5pc2hlZE1vdGlvbkhhbmRsZXIpIHtcbiAgICBjb25zdCByZXQgPSBuZXcgQ3ViaXNtTW90aW9uKCk7XG4gICAgcmV0LnBhcnNlKGpzb24pO1xuICAgIHJldC5fc291cmNlRnJhbWVSYXRlID0gcmV0Ll9tb3Rpb25EYXRhLmZwcztcbiAgICByZXQuX2xvb3BEdXJhdGlvblNlY29uZHMgPSByZXQuX21vdGlvbkRhdGEuZHVyYXRpb247XG4gICAgcmV0Ll9vbkZpbmlzaGVkTW90aW9uID0gb25GaW5pc2hlZE1vdGlvbkhhbmRsZXI7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBkb1VwZGF0ZVBhcmFtZXRlcnMobW9kZWwsIHVzZXJUaW1lU2Vjb25kcywgZmFkZVdlaWdodCwgbW90aW9uUXVldWVFbnRyeSkge1xuICAgIGlmICh0aGlzLl9tb2RlbEN1cnZlSWRFeWVCbGluayA9PSBudWxsKSB7XG4gICAgICB0aGlzLl9tb2RlbEN1cnZlSWRFeWVCbGluayA9IEVmZmVjdE5hbWVFeWVCbGluaztcbiAgICB9XG4gICAgaWYgKHRoaXMuX21vZGVsQ3VydmVJZExpcFN5bmMgPT0gbnVsbCkge1xuICAgICAgdGhpcy5fbW9kZWxDdXJ2ZUlkTGlwU3luYyA9IEVmZmVjdE5hbWVMaXBTeW5jO1xuICAgIH1cbiAgICBsZXQgdGltZU9mZnNldFNlY29uZHMgPSB1c2VyVGltZVNlY29uZHMgLSBtb3Rpb25RdWV1ZUVudHJ5LmdldFN0YXJ0VGltZSgpO1xuICAgIGlmICh0aW1lT2Zmc2V0U2Vjb25kcyA8IDApIHtcbiAgICAgIHRpbWVPZmZzZXRTZWNvbmRzID0gMDtcbiAgICB9XG4gICAgbGV0IGxpcFN5bmNWYWx1ZSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgbGV0IGV5ZUJsaW5rVmFsdWUgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIGNvbnN0IE1heFRhcmdldFNpemUgPSA2NDtcbiAgICBsZXQgbGlwU3luY0ZsYWdzID0gMDtcbiAgICBsZXQgZXllQmxpbmtGbGFncyA9IDA7XG4gICAgaWYgKHRoaXMuX2V5ZUJsaW5rUGFyYW1ldGVySWRzLmxlbmd0aCA+IE1heFRhcmdldFNpemUpIHtcbiAgICAgIEN1YmlzbUxvZ0RlYnVnKFwidG9vIG1hbnkgZXllIGJsaW5rIHRhcmdldHMgOiB7MH1cIiwgdGhpcy5fZXllQmxpbmtQYXJhbWV0ZXJJZHMubGVuZ3RoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xpcFN5bmNQYXJhbWV0ZXJJZHMubGVuZ3RoID4gTWF4VGFyZ2V0U2l6ZSkge1xuICAgICAgQ3ViaXNtTG9nRGVidWcoXCJ0b28gbWFueSBsaXAgc3luYyB0YXJnZXRzIDogezB9XCIsIHRoaXMuX2xpcFN5bmNQYXJhbWV0ZXJJZHMubGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgdG1wRmFkZUluID0gdGhpcy5fZmFkZUluU2Vjb25kcyA8PSAwID8gMSA6IEN1YmlzbU1hdGguZ2V0RWFzaW5nU2luZSgodXNlclRpbWVTZWNvbmRzIC0gbW90aW9uUXVldWVFbnRyeS5nZXRGYWRlSW5TdGFydFRpbWUoKSkgLyB0aGlzLl9mYWRlSW5TZWNvbmRzKTtcbiAgICBjb25zdCB0bXBGYWRlT3V0ID0gdGhpcy5fZmFkZU91dFNlY29uZHMgPD0gMCB8fCBtb3Rpb25RdWV1ZUVudHJ5LmdldEVuZFRpbWUoKSA8IDAgPyAxIDogQ3ViaXNtTWF0aC5nZXRFYXNpbmdTaW5lKChtb3Rpb25RdWV1ZUVudHJ5LmdldEVuZFRpbWUoKSAtIHVzZXJUaW1lU2Vjb25kcykgLyB0aGlzLl9mYWRlT3V0U2Vjb25kcyk7XG4gICAgbGV0IHZhbHVlO1xuICAgIGxldCBjLCBwYXJhbWV0ZXJJbmRleDtcbiAgICBsZXQgdGltZSA9IHRpbWVPZmZzZXRTZWNvbmRzO1xuICAgIGlmICh0aGlzLl9pc0xvb3ApIHtcbiAgICAgIHdoaWxlICh0aW1lID4gdGhpcy5fbW90aW9uRGF0YS5kdXJhdGlvbikge1xuICAgICAgICB0aW1lIC09IHRoaXMuX21vdGlvbkRhdGEuZHVyYXRpb247XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGN1cnZlcyA9IHRoaXMuX21vdGlvbkRhdGEuY3VydmVzO1xuICAgIGZvciAoYyA9IDA7IGMgPCB0aGlzLl9tb3Rpb25EYXRhLmN1cnZlQ291bnQgJiYgY3VydmVzW2NdLnR5cGUgPT0gQ3ViaXNtTW90aW9uQ3VydmVUYXJnZXQuQ3ViaXNtTW90aW9uQ3VydmVUYXJnZXRfTW9kZWw7ICsrYykge1xuICAgICAgdmFsdWUgPSBldmFsdWF0ZUN1cnZlKHRoaXMuX21vdGlvbkRhdGEsIGMsIHRpbWUpO1xuICAgICAgaWYgKGN1cnZlc1tjXS5pZCA9PSB0aGlzLl9tb2RlbEN1cnZlSWRFeWVCbGluaykge1xuICAgICAgICBleWVCbGlua1ZhbHVlID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKGN1cnZlc1tjXS5pZCA9PSB0aGlzLl9tb2RlbEN1cnZlSWRMaXBTeW5jKSB7XG4gICAgICAgIGxpcFN5bmNWYWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKDsgYyA8IHRoaXMuX21vdGlvbkRhdGEuY3VydmVDb3VudCAmJiBjdXJ2ZXNbY10udHlwZSA9PSBDdWJpc21Nb3Rpb25DdXJ2ZVRhcmdldC5DdWJpc21Nb3Rpb25DdXJ2ZVRhcmdldF9QYXJhbWV0ZXI7ICsrYykge1xuICAgICAgcGFyYW1ldGVySW5kZXggPSBtb2RlbC5nZXRQYXJhbWV0ZXJJbmRleChjdXJ2ZXNbY10uaWQpO1xuICAgICAgaWYgKHBhcmFtZXRlckluZGV4ID09IC0xKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc291cmNlVmFsdWUgPSBtb2RlbC5nZXRQYXJhbWV0ZXJWYWx1ZUJ5SW5kZXgocGFyYW1ldGVySW5kZXgpO1xuICAgICAgdmFsdWUgPSBldmFsdWF0ZUN1cnZlKHRoaXMuX21vdGlvbkRhdGEsIGMsIHRpbWUpO1xuICAgICAgaWYgKGV5ZUJsaW5rVmFsdWUgIT0gTnVtYmVyLk1BWF9WQUxVRSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2V5ZUJsaW5rUGFyYW1ldGVySWRzLmxlbmd0aCAmJiBpIDwgTWF4VGFyZ2V0U2l6ZTsgKytpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2V5ZUJsaW5rUGFyYW1ldGVySWRzW2ldID09IGN1cnZlc1tjXS5pZCkge1xuICAgICAgICAgICAgdmFsdWUgKj0gZXllQmxpbmtWYWx1ZTtcbiAgICAgICAgICAgIGV5ZUJsaW5rRmxhZ3MgfD0gMSA8PCBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGlwU3luY1ZhbHVlICE9IE51bWJlci5NQVhfVkFMVUUpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9saXBTeW5jUGFyYW1ldGVySWRzLmxlbmd0aCAmJiBpIDwgTWF4VGFyZ2V0U2l6ZTsgKytpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2xpcFN5bmNQYXJhbWV0ZXJJZHNbaV0gPT0gY3VydmVzW2NdLmlkKSB7XG4gICAgICAgICAgICB2YWx1ZSArPSBsaXBTeW5jVmFsdWU7XG4gICAgICAgICAgICBsaXBTeW5jRmxhZ3MgfD0gMSA8PCBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgdjtcbiAgICAgIGlmIChjdXJ2ZXNbY10uZmFkZUluVGltZSA8IDAgJiYgY3VydmVzW2NdLmZhZGVPdXRUaW1lIDwgMCkge1xuICAgICAgICB2ID0gc291cmNlVmFsdWUgKyAodmFsdWUgLSBzb3VyY2VWYWx1ZSkgKiBmYWRlV2VpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGZpbjtcbiAgICAgICAgbGV0IGZvdXQ7XG4gICAgICAgIGlmIChjdXJ2ZXNbY10uZmFkZUluVGltZSA8IDApIHtcbiAgICAgICAgICBmaW4gPSB0bXBGYWRlSW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmluID0gY3VydmVzW2NdLmZhZGVJblRpbWUgPT0gMCA/IDEgOiBDdWJpc21NYXRoLmdldEVhc2luZ1NpbmUoKHVzZXJUaW1lU2Vjb25kcyAtIG1vdGlvblF1ZXVlRW50cnkuZ2V0RmFkZUluU3RhcnRUaW1lKCkpIC8gY3VydmVzW2NdLmZhZGVJblRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJ2ZXNbY10uZmFkZU91dFRpbWUgPCAwKSB7XG4gICAgICAgICAgZm91dCA9IHRtcEZhZGVPdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm91dCA9IGN1cnZlc1tjXS5mYWRlT3V0VGltZSA9PSAwIHx8IG1vdGlvblF1ZXVlRW50cnkuZ2V0RW5kVGltZSgpIDwgMCA/IDEgOiBDdWJpc21NYXRoLmdldEVhc2luZ1NpbmUoKG1vdGlvblF1ZXVlRW50cnkuZ2V0RW5kVGltZSgpIC0gdXNlclRpbWVTZWNvbmRzKSAvIGN1cnZlc1tjXS5mYWRlT3V0VGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1XZWlnaHQgPSB0aGlzLl93ZWlnaHQgKiBmaW4gKiBmb3V0O1xuICAgICAgICB2ID0gc291cmNlVmFsdWUgKyAodmFsdWUgLSBzb3VyY2VWYWx1ZSkgKiBwYXJhbVdlaWdodDtcbiAgICAgIH1cbiAgICAgIG1vZGVsLnNldFBhcmFtZXRlclZhbHVlQnlJbmRleChwYXJhbWV0ZXJJbmRleCwgdiwgMSk7XG4gICAgfVxuICAgIHtcbiAgICAgIGlmIChleWVCbGlua1ZhbHVlICE9IE51bWJlci5NQVhfVkFMVUUpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9leWVCbGlua1BhcmFtZXRlcklkcy5sZW5ndGggJiYgaSA8IE1heFRhcmdldFNpemU7ICsraSkge1xuICAgICAgICAgIGNvbnN0IHNvdXJjZVZhbHVlID0gbW9kZWwuZ2V0UGFyYW1ldGVyVmFsdWVCeUlkKHRoaXMuX2V5ZUJsaW5rUGFyYW1ldGVySWRzW2ldKTtcbiAgICAgICAgICBpZiAoZXllQmxpbmtGbGFncyA+PiBpICYgMSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHYgPSBzb3VyY2VWYWx1ZSArIChleWVCbGlua1ZhbHVlIC0gc291cmNlVmFsdWUpICogZmFkZVdlaWdodDtcbiAgICAgICAgICBtb2RlbC5zZXRQYXJhbWV0ZXJWYWx1ZUJ5SWQodGhpcy5fZXllQmxpbmtQYXJhbWV0ZXJJZHNbaV0sIHYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGlwU3luY1ZhbHVlICE9IE51bWJlci5NQVhfVkFMVUUpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9saXBTeW5jUGFyYW1ldGVySWRzLmxlbmd0aCAmJiBpIDwgTWF4VGFyZ2V0U2l6ZTsgKytpKSB7XG4gICAgICAgICAgY29uc3Qgc291cmNlVmFsdWUgPSBtb2RlbC5nZXRQYXJhbWV0ZXJWYWx1ZUJ5SWQodGhpcy5fbGlwU3luY1BhcmFtZXRlcklkc1tpXSk7XG4gICAgICAgICAgaWYgKGxpcFN5bmNGbGFncyA+PiBpICYgMSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHYgPSBzb3VyY2VWYWx1ZSArIChsaXBTeW5jVmFsdWUgLSBzb3VyY2VWYWx1ZSkgKiBmYWRlV2VpZ2h0O1xuICAgICAgICAgIG1vZGVsLnNldFBhcmFtZXRlclZhbHVlQnlJZCh0aGlzLl9saXBTeW5jUGFyYW1ldGVySWRzW2ldLCB2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKDsgYyA8IHRoaXMuX21vdGlvbkRhdGEuY3VydmVDb3VudCAmJiBjdXJ2ZXNbY10udHlwZSA9PSBDdWJpc21Nb3Rpb25DdXJ2ZVRhcmdldC5DdWJpc21Nb3Rpb25DdXJ2ZVRhcmdldF9QYXJ0T3BhY2l0eTsgKytjKSB7XG4gICAgICB2YWx1ZSA9IGV2YWx1YXRlQ3VydmUodGhpcy5fbW90aW9uRGF0YSwgYywgdGltZSk7XG4gICAgICBpZiAoQ3ViaXNtQ29uZmlnLnNldE9wYWNpdHlGcm9tTW90aW9uKSB7XG4gICAgICAgIG1vZGVsLnNldFBhcnRPcGFjaXR5QnlJZChjdXJ2ZXNbY10uaWQsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtZXRlckluZGV4ID0gbW9kZWwuZ2V0UGFyYW1ldGVySW5kZXgoY3VydmVzW2NdLmlkKTtcbiAgICAgICAgaWYgKHBhcmFtZXRlckluZGV4ID09IC0xKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbW9kZWwuc2V0UGFyYW1ldGVyVmFsdWVCeUluZGV4KHBhcmFtZXRlckluZGV4LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aW1lT2Zmc2V0U2Vjb25kcyA+PSB0aGlzLl9tb3Rpb25EYXRhLmR1cmF0aW9uKSB7XG4gICAgICBpZiAodGhpcy5faXNMb29wKSB7XG4gICAgICAgIG1vdGlvblF1ZXVlRW50cnkuc2V0U3RhcnRUaW1lKHVzZXJUaW1lU2Vjb25kcyk7XG4gICAgICAgIGlmICh0aGlzLl9pc0xvb3BGYWRlSW4pIHtcbiAgICAgICAgICBtb3Rpb25RdWV1ZUVudHJ5LnNldEZhZGVJblN0YXJ0VGltZSh1c2VyVGltZVNlY29uZHMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5fb25GaW5pc2hlZE1vdGlvbikge1xuICAgICAgICAgIHRoaXMuX29uRmluaXNoZWRNb3Rpb24odGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgbW90aW9uUXVldWVFbnRyeS5zZXRJc0ZpbmlzaGVkKHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9sYXN0V2VpZ2h0ID0gZmFkZVdlaWdodDtcbiAgfVxuICBzZXRJc0xvb3AobG9vcCkge1xuICAgIHRoaXMuX2lzTG9vcCA9IGxvb3A7XG4gIH1cbiAgaXNMb29wKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0xvb3A7XG4gIH1cbiAgc2V0SXNMb29wRmFkZUluKGxvb3BGYWRlSW4pIHtcbiAgICB0aGlzLl9pc0xvb3BGYWRlSW4gPSBsb29wRmFkZUluO1xuICB9XG4gIGlzTG9vcEZhZGVJbigpIHtcbiAgICByZXR1cm4gdGhpcy5faXNMb29wRmFkZUluO1xuICB9XG4gIGdldER1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0xvb3AgPyAtMSA6IHRoaXMuX2xvb3BEdXJhdGlvblNlY29uZHM7XG4gIH1cbiAgZ2V0TG9vcER1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9sb29wRHVyYXRpb25TZWNvbmRzO1xuICB9XG4gIHNldFBhcmFtZXRlckZhZGVJblRpbWUocGFyYW1ldGVySWQsIHZhbHVlKSB7XG4gICAgY29uc3QgY3VydmVzID0gdGhpcy5fbW90aW9uRGF0YS5jdXJ2ZXM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9tb3Rpb25EYXRhLmN1cnZlQ291bnQ7ICsraSkge1xuICAgICAgaWYgKHBhcmFtZXRlcklkID09IGN1cnZlc1tpXS5pZCkge1xuICAgICAgICBjdXJ2ZXNbaV0uZmFkZUluVGltZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNldFBhcmFtZXRlckZhZGVPdXRUaW1lKHBhcmFtZXRlcklkLCB2YWx1ZSkge1xuICAgIGNvbnN0IGN1cnZlcyA9IHRoaXMuX21vdGlvbkRhdGEuY3VydmVzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbW90aW9uRGF0YS5jdXJ2ZUNvdW50OyArK2kpIHtcbiAgICAgIGlmIChwYXJhbWV0ZXJJZCA9PSBjdXJ2ZXNbaV0uaWQpIHtcbiAgICAgICAgY3VydmVzW2ldLmZhZGVPdXRUaW1lID0gdmFsdWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0UGFyYW1ldGVyRmFkZUluVGltZShwYXJhbWV0ZXJJZCkge1xuICAgIGNvbnN0IGN1cnZlcyA9IHRoaXMuX21vdGlvbkRhdGEuY3VydmVzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbW90aW9uRGF0YS5jdXJ2ZUNvdW50OyArK2kpIHtcbiAgICAgIGlmIChwYXJhbWV0ZXJJZCA9PSBjdXJ2ZXNbaV0uaWQpIHtcbiAgICAgICAgcmV0dXJuIGN1cnZlc1tpXS5mYWRlSW5UaW1lO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgZ2V0UGFyYW1ldGVyRmFkZU91dFRpbWUocGFyYW1ldGVySWQpIHtcbiAgICBjb25zdCBjdXJ2ZXMgPSB0aGlzLl9tb3Rpb25EYXRhLmN1cnZlcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX21vdGlvbkRhdGEuY3VydmVDb3VudDsgKytpKSB7XG4gICAgICBpZiAocGFyYW1ldGVySWQgPT0gY3VydmVzW2ldLmlkKSB7XG4gICAgICAgIHJldHVybiBjdXJ2ZXNbaV0uZmFkZU91dFRpbWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBzZXRFZmZlY3RJZHMoZXllQmxpbmtQYXJhbWV0ZXJJZHMsIGxpcFN5bmNQYXJhbWV0ZXJJZHMpIHtcbiAgICB0aGlzLl9leWVCbGlua1BhcmFtZXRlcklkcyA9IGV5ZUJsaW5rUGFyYW1ldGVySWRzO1xuICAgIHRoaXMuX2xpcFN5bmNQYXJhbWV0ZXJJZHMgPSBsaXBTeW5jUGFyYW1ldGVySWRzO1xuICB9XG4gIHJlbGVhc2UoKSB7XG4gICAgdGhpcy5fbW90aW9uRGF0YSA9IHZvaWQgMDtcbiAgfVxuICBwYXJzZShtb3Rpb25Kc29uKSB7XG4gICAgdGhpcy5fbW90aW9uRGF0YSA9IG5ldyBDdWJpc21Nb3Rpb25EYXRhKCk7XG4gICAgbGV0IGpzb24gPSBuZXcgQ3ViaXNtTW90aW9uSnNvbihtb3Rpb25Kc29uKTtcbiAgICB0aGlzLl9tb3Rpb25EYXRhLmR1cmF0aW9uID0ganNvbi5nZXRNb3Rpb25EdXJhdGlvbigpO1xuICAgIHRoaXMuX21vdGlvbkRhdGEubG9vcCA9IGpzb24uaXNNb3Rpb25Mb29wKCk7XG4gICAgdGhpcy5fbW90aW9uRGF0YS5jdXJ2ZUNvdW50ID0ganNvbi5nZXRNb3Rpb25DdXJ2ZUNvdW50KCk7XG4gICAgdGhpcy5fbW90aW9uRGF0YS5mcHMgPSBqc29uLmdldE1vdGlvbkZwcygpO1xuICAgIHRoaXMuX21vdGlvbkRhdGEuZXZlbnRDb3VudCA9IGpzb24uZ2V0RXZlbnRDb3VudCgpO1xuICAgIGNvbnN0IGFyZUJlemllcnNSZXN0cnVjdGVkID0ganNvbi5nZXRFdmFsdWF0aW9uT3B0aW9uRmxhZyhFdmFsdWF0aW9uT3B0aW9uRmxhZy5FdmFsdWF0aW9uT3B0aW9uRmxhZ19BcmVCZXppZXJzUmlzdHJpY3RlZCk7XG4gICAgY29uc3QgZmFkZUluU2Vjb25kcyA9IGpzb24uZ2V0TW90aW9uRmFkZUluVGltZSgpO1xuICAgIGNvbnN0IGZhZGVPdXRTZWNvbmRzID0ganNvbi5nZXRNb3Rpb25GYWRlT3V0VGltZSgpO1xuICAgIGlmIChmYWRlSW5TZWNvbmRzICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuX2ZhZGVJblNlY29uZHMgPSBmYWRlSW5TZWNvbmRzIDwgMCA/IDEgOiBmYWRlSW5TZWNvbmRzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9mYWRlSW5TZWNvbmRzID0gMTtcbiAgICB9XG4gICAgaWYgKGZhZGVPdXRTZWNvbmRzICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuX2ZhZGVPdXRTZWNvbmRzID0gZmFkZU91dFNlY29uZHMgPCAwID8gMSA6IGZhZGVPdXRTZWNvbmRzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9mYWRlT3V0U2Vjb25kcyA9IDE7XG4gICAgfVxuICAgIHRoaXMuX21vdGlvbkRhdGEuY3VydmVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogdGhpcy5fbW90aW9uRGF0YS5jdXJ2ZUNvdW50IH0pLm1hcCgoKSA9PiBuZXcgQ3ViaXNtTW90aW9uQ3VydmUoKSk7XG4gICAgdGhpcy5fbW90aW9uRGF0YS5zZWdtZW50cyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IGpzb24uZ2V0TW90aW9uVG90YWxTZWdtZW50Q291bnQoKSB9KS5tYXAoKCkgPT4gbmV3IEN1YmlzbU1vdGlvblNlZ21lbnQoKSk7XG4gICAgdGhpcy5fbW90aW9uRGF0YS5ldmVudHMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiB0aGlzLl9tb3Rpb25EYXRhLmV2ZW50Q291bnQgfSkubWFwKCgpID0+IG5ldyBDdWJpc21Nb3Rpb25FdmVudCgpKTtcbiAgICB0aGlzLl9tb3Rpb25EYXRhLnBvaW50cyA9IFtdO1xuICAgIGxldCB0b3RhbFBvaW50Q291bnQgPSAwO1xuICAgIGxldCB0b3RhbFNlZ21lbnRDb3VudCA9IDA7XG4gICAgZm9yIChsZXQgY3VydmVDb3VudCA9IDA7IGN1cnZlQ291bnQgPCB0aGlzLl9tb3Rpb25EYXRhLmN1cnZlQ291bnQ7ICsrY3VydmVDb3VudCkge1xuICAgICAgY29uc3QgY3VydmUgPSB0aGlzLl9tb3Rpb25EYXRhLmN1cnZlc1tjdXJ2ZUNvdW50XTtcbiAgICAgIHN3aXRjaCAoanNvbi5nZXRNb3Rpb25DdXJ2ZVRhcmdldChjdXJ2ZUNvdW50KSkge1xuICAgICAgICBjYXNlIFRhcmdldE5hbWVNb2RlbDpcbiAgICAgICAgICBjdXJ2ZS50eXBlID0gQ3ViaXNtTW90aW9uQ3VydmVUYXJnZXQuQ3ViaXNtTW90aW9uQ3VydmVUYXJnZXRfTW9kZWw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVGFyZ2V0TmFtZVBhcmFtZXRlcjpcbiAgICAgICAgICBjdXJ2ZS50eXBlID0gQ3ViaXNtTW90aW9uQ3VydmVUYXJnZXQuQ3ViaXNtTW90aW9uQ3VydmVUYXJnZXRfUGFyYW1ldGVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFRhcmdldE5hbWVQYXJ0T3BhY2l0eTpcbiAgICAgICAgICBjdXJ2ZS50eXBlID0gQ3ViaXNtTW90aW9uQ3VydmVUYXJnZXQuQ3ViaXNtTW90aW9uQ3VydmVUYXJnZXRfUGFydE9wYWNpdHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgQ3ViaXNtTG9nV2FybmluZygnV2FybmluZyA6IFVuYWJsZSB0byBnZXQgc2VnbWVudCB0eXBlIGZyb20gQ3VydmUhIFRoZSBudW1iZXIgb2YgXCJDdXJ2ZUNvdW50XCIgbWF5IGJlIGluY29ycmVjdCEnKTtcbiAgICAgIH1cbiAgICAgIGN1cnZlLmlkID0ganNvbi5nZXRNb3Rpb25DdXJ2ZUlkKGN1cnZlQ291bnQpO1xuICAgICAgY3VydmUuYmFzZVNlZ21lbnRJbmRleCA9IHRvdGFsU2VnbWVudENvdW50O1xuICAgICAgY29uc3QgZmFkZUluVGltZSA9IGpzb24uZ2V0TW90aW9uQ3VydmVGYWRlSW5UaW1lKGN1cnZlQ291bnQpO1xuICAgICAgY29uc3QgZmFkZU91dFRpbWUgPSBqc29uLmdldE1vdGlvbkN1cnZlRmFkZU91dFRpbWUoY3VydmVDb3VudCk7XG4gICAgICBjdXJ2ZS5mYWRlSW5UaW1lID0gZmFkZUluVGltZSAhPT0gdm9pZCAwID8gZmFkZUluVGltZSA6IC0xO1xuICAgICAgY3VydmUuZmFkZU91dFRpbWUgPSBmYWRlT3V0VGltZSAhPT0gdm9pZCAwID8gZmFkZU91dFRpbWUgOiAtMTtcbiAgICAgIGZvciAobGV0IHNlZ21lbnRQb3NpdGlvbiA9IDA7IHNlZ21lbnRQb3NpdGlvbiA8IGpzb24uZ2V0TW90aW9uQ3VydmVTZWdtZW50Q291bnQoY3VydmVDb3VudCk7ICkge1xuICAgICAgICBpZiAoc2VnbWVudFBvc2l0aW9uID09IDApIHtcbiAgICAgICAgICB0aGlzLl9tb3Rpb25EYXRhLnNlZ21lbnRzW3RvdGFsU2VnbWVudENvdW50XS5iYXNlUG9pbnRJbmRleCA9IHRvdGFsUG9pbnRDb3VudDtcbiAgICAgICAgICB0aGlzLl9tb3Rpb25EYXRhLnBvaW50c1t0b3RhbFBvaW50Q291bnRdID0gbmV3IEN1YmlzbU1vdGlvblBvaW50KGpzb24uZ2V0TW90aW9uQ3VydmVTZWdtZW50KGN1cnZlQ291bnQsIHNlZ21lbnRQb3NpdGlvbiksIGpzb24uZ2V0TW90aW9uQ3VydmVTZWdtZW50KGN1cnZlQ291bnQsIHNlZ21lbnRQb3NpdGlvbiArIDEpKTtcbiAgICAgICAgICB0b3RhbFBvaW50Q291bnQgKz0gMTtcbiAgICAgICAgICBzZWdtZW50UG9zaXRpb24gKz0gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9tb3Rpb25EYXRhLnNlZ21lbnRzW3RvdGFsU2VnbWVudENvdW50XS5iYXNlUG9pbnRJbmRleCA9IHRvdGFsUG9pbnRDb3VudCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VnbWVudCA9IGpzb24uZ2V0TW90aW9uQ3VydmVTZWdtZW50KGN1cnZlQ291bnQsIHNlZ21lbnRQb3NpdGlvbik7XG4gICAgICAgIHN3aXRjaCAoc2VnbWVudCkge1xuICAgICAgICAgIGNhc2UgQ3ViaXNtTW90aW9uU2VnbWVudFR5cGUuQ3ViaXNtTW90aW9uU2VnbWVudFR5cGVfTGluZWFyOiB7XG4gICAgICAgICAgICB0aGlzLl9tb3Rpb25EYXRhLnNlZ21lbnRzW3RvdGFsU2VnbWVudENvdW50XS5zZWdtZW50VHlwZSA9IEN1YmlzbU1vdGlvblNlZ21lbnRUeXBlLkN1YmlzbU1vdGlvblNlZ21lbnRUeXBlX0xpbmVhcjtcbiAgICAgICAgICAgIHRoaXMuX21vdGlvbkRhdGEuc2VnbWVudHNbdG90YWxTZWdtZW50Q291bnRdLmV2YWx1YXRlID0gbGluZWFyRXZhbHVhdGU7XG4gICAgICAgICAgICB0aGlzLl9tb3Rpb25EYXRhLnBvaW50c1t0b3RhbFBvaW50Q291bnRdID0gbmV3IEN1YmlzbU1vdGlvblBvaW50KGpzb24uZ2V0TW90aW9uQ3VydmVTZWdtZW50KGN1cnZlQ291bnQsIHNlZ21lbnRQb3NpdGlvbiArIDEpLCBqc29uLmdldE1vdGlvbkN1cnZlU2VnbWVudChjdXJ2ZUNvdW50LCBzZWdtZW50UG9zaXRpb24gKyAyKSk7XG4gICAgICAgICAgICB0b3RhbFBvaW50Q291bnQgKz0gMTtcbiAgICAgICAgICAgIHNlZ21lbnRQb3NpdGlvbiArPSAzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgQ3ViaXNtTW90aW9uU2VnbWVudFR5cGUuQ3ViaXNtTW90aW9uU2VnbWVudFR5cGVfQmV6aWVyOiB7XG4gICAgICAgICAgICB0aGlzLl9tb3Rpb25EYXRhLnNlZ21lbnRzW3RvdGFsU2VnbWVudENvdW50XS5zZWdtZW50VHlwZSA9IEN1YmlzbU1vdGlvblNlZ21lbnRUeXBlLkN1YmlzbU1vdGlvblNlZ21lbnRUeXBlX0JlemllcjtcbiAgICAgICAgICAgIGlmIChhcmVCZXppZXJzUmVzdHJ1Y3RlZCB8fCBVc2VPbGRCZXppZXJzQ3VydmVNb3Rpb24pIHtcbiAgICAgICAgICAgICAgdGhpcy5fbW90aW9uRGF0YS5zZWdtZW50c1t0b3RhbFNlZ21lbnRDb3VudF0uZXZhbHVhdGUgPSBiZXppZXJFdmFsdWF0ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX21vdGlvbkRhdGEuc2VnbWVudHNbdG90YWxTZWdtZW50Q291bnRdLmV2YWx1YXRlID0gYmV6aWVyRXZhbHVhdGVDYXJkYW5vSW50ZXJwcmV0YXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tb3Rpb25EYXRhLnBvaW50c1t0b3RhbFBvaW50Q291bnRdID0gbmV3IEN1YmlzbU1vdGlvblBvaW50KGpzb24uZ2V0TW90aW9uQ3VydmVTZWdtZW50KGN1cnZlQ291bnQsIHNlZ21lbnRQb3NpdGlvbiArIDEpLCBqc29uLmdldE1vdGlvbkN1cnZlU2VnbWVudChjdXJ2ZUNvdW50LCBzZWdtZW50UG9zaXRpb24gKyAyKSk7XG4gICAgICAgICAgICB0aGlzLl9tb3Rpb25EYXRhLnBvaW50c1t0b3RhbFBvaW50Q291bnQgKyAxXSA9IG5ldyBDdWJpc21Nb3Rpb25Qb2ludChqc29uLmdldE1vdGlvbkN1cnZlU2VnbWVudChjdXJ2ZUNvdW50LCBzZWdtZW50UG9zaXRpb24gKyAzKSwganNvbi5nZXRNb3Rpb25DdXJ2ZVNlZ21lbnQoY3VydmVDb3VudCwgc2VnbWVudFBvc2l0aW9uICsgNCkpO1xuICAgICAgICAgICAgdGhpcy5fbW90aW9uRGF0YS5wb2ludHNbdG90YWxQb2ludENvdW50ICsgMl0gPSBuZXcgQ3ViaXNtTW90aW9uUG9pbnQoanNvbi5nZXRNb3Rpb25DdXJ2ZVNlZ21lbnQoY3VydmVDb3VudCwgc2VnbWVudFBvc2l0aW9uICsgNSksIGpzb24uZ2V0TW90aW9uQ3VydmVTZWdtZW50KGN1cnZlQ291bnQsIHNlZ21lbnRQb3NpdGlvbiArIDYpKTtcbiAgICAgICAgICAgIHRvdGFsUG9pbnRDb3VudCArPSAzO1xuICAgICAgICAgICAgc2VnbWVudFBvc2l0aW9uICs9IDc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBDdWJpc21Nb3Rpb25TZWdtZW50VHlwZS5DdWJpc21Nb3Rpb25TZWdtZW50VHlwZV9TdGVwcGVkOiB7XG4gICAgICAgICAgICB0aGlzLl9tb3Rpb25EYXRhLnNlZ21lbnRzW3RvdGFsU2VnbWVudENvdW50XS5zZWdtZW50VHlwZSA9IEN1YmlzbU1vdGlvblNlZ21lbnRUeXBlLkN1YmlzbU1vdGlvblNlZ21lbnRUeXBlX1N0ZXBwZWQ7XG4gICAgICAgICAgICB0aGlzLl9tb3Rpb25EYXRhLnNlZ21lbnRzW3RvdGFsU2VnbWVudENvdW50XS5ldmFsdWF0ZSA9IHN0ZXBwZWRFdmFsdWF0ZTtcbiAgICAgICAgICAgIHRoaXMuX21vdGlvbkRhdGEucG9pbnRzW3RvdGFsUG9pbnRDb3VudF0gPSBuZXcgQ3ViaXNtTW90aW9uUG9pbnQoanNvbi5nZXRNb3Rpb25DdXJ2ZVNlZ21lbnQoY3VydmVDb3VudCwgc2VnbWVudFBvc2l0aW9uICsgMSksIGpzb24uZ2V0TW90aW9uQ3VydmVTZWdtZW50KGN1cnZlQ291bnQsIHNlZ21lbnRQb3NpdGlvbiArIDIpKTtcbiAgICAgICAgICAgIHRvdGFsUG9pbnRDb3VudCArPSAxO1xuICAgICAgICAgICAgc2VnbWVudFBvc2l0aW9uICs9IDM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBDdWJpc21Nb3Rpb25TZWdtZW50VHlwZS5DdWJpc21Nb3Rpb25TZWdtZW50VHlwZV9JbnZlcnNlU3RlcHBlZDoge1xuICAgICAgICAgICAgdGhpcy5fbW90aW9uRGF0YS5zZWdtZW50c1t0b3RhbFNlZ21lbnRDb3VudF0uc2VnbWVudFR5cGUgPSBDdWJpc21Nb3Rpb25TZWdtZW50VHlwZS5DdWJpc21Nb3Rpb25TZWdtZW50VHlwZV9JbnZlcnNlU3RlcHBlZDtcbiAgICAgICAgICAgIHRoaXMuX21vdGlvbkRhdGEuc2VnbWVudHNbdG90YWxTZWdtZW50Q291bnRdLmV2YWx1YXRlID0gaW52ZXJzZVN0ZXBwZWRFdmFsdWF0ZTtcbiAgICAgICAgICAgIHRoaXMuX21vdGlvbkRhdGEucG9pbnRzW3RvdGFsUG9pbnRDb3VudF0gPSBuZXcgQ3ViaXNtTW90aW9uUG9pbnQoanNvbi5nZXRNb3Rpb25DdXJ2ZVNlZ21lbnQoY3VydmVDb3VudCwgc2VnbWVudFBvc2l0aW9uICsgMSksIGpzb24uZ2V0TW90aW9uQ3VydmVTZWdtZW50KGN1cnZlQ291bnQsIHNlZ21lbnRQb3NpdGlvbiArIDIpKTtcbiAgICAgICAgICAgIHRvdGFsUG9pbnRDb3VudCArPSAxO1xuICAgICAgICAgICAgc2VnbWVudFBvc2l0aW9uICs9IDM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKytjdXJ2ZS5zZWdtZW50Q291bnQ7XG4gICAgICAgICsrdG90YWxTZWdtZW50Q291bnQ7XG4gICAgICB9XG4gICAgICB0aGlzLl9tb3Rpb25EYXRhLmN1cnZlcy5wdXNoKGN1cnZlKTtcbiAgICB9XG4gICAgZm9yIChsZXQgdXNlcmRhdGFjb3VudCA9IDA7IHVzZXJkYXRhY291bnQgPCBqc29uLmdldEV2ZW50Q291bnQoKTsgKyt1c2VyZGF0YWNvdW50KSB7XG4gICAgICB0aGlzLl9tb3Rpb25EYXRhLmV2ZW50c1t1c2VyZGF0YWNvdW50XS5maXJlVGltZSA9IGpzb24uZ2V0RXZlbnRUaW1lKHVzZXJkYXRhY291bnQpO1xuICAgICAgdGhpcy5fbW90aW9uRGF0YS5ldmVudHNbdXNlcmRhdGFjb3VudF0udmFsdWUgPSBqc29uLmdldEV2ZW50VmFsdWUodXNlcmRhdGFjb3VudCk7XG4gICAgfVxuICAgIGpzb24ucmVsZWFzZSgpO1xuICB9XG4gIGdldEZpcmVkRXZlbnQoYmVmb3JlQ2hlY2tUaW1lU2Vjb25kcywgbW90aW9uVGltZVNlY29uZHMpIHtcbiAgICB0aGlzLl9maXJlZEV2ZW50VmFsdWVzLmxlbmd0aCA9IDA7XG4gICAgZm9yIChsZXQgdSA9IDA7IHUgPCB0aGlzLl9tb3Rpb25EYXRhLmV2ZW50Q291bnQ7ICsrdSkge1xuICAgICAgaWYgKHRoaXMuX21vdGlvbkRhdGEuZXZlbnRzW3VdLmZpcmVUaW1lID4gYmVmb3JlQ2hlY2tUaW1lU2Vjb25kcyAmJiB0aGlzLl9tb3Rpb25EYXRhLmV2ZW50c1t1XS5maXJlVGltZSA8PSBtb3Rpb25UaW1lU2Vjb25kcykge1xuICAgICAgICB0aGlzLl9maXJlZEV2ZW50VmFsdWVzLnB1c2godGhpcy5fbW90aW9uRGF0YS5ldmVudHNbdV0udmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZmlyZWRFdmVudFZhbHVlcztcbiAgfVxufVxuY2xhc3MgQ3ViaXNtTW90aW9uUXVldWVFbnRyeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2F1dG9EZWxldGUgPSBmYWxzZTtcbiAgICB0aGlzLl9hdmFpbGFibGUgPSB0cnVlO1xuICAgIHRoaXMuX2ZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3N0YXJ0VGltZVNlY29uZHMgPSAtMTtcbiAgICB0aGlzLl9mYWRlSW5TdGFydFRpbWVTZWNvbmRzID0gMDtcbiAgICB0aGlzLl9lbmRUaW1lU2Vjb25kcyA9IC0xO1xuICAgIHRoaXMuX3N0YXRlVGltZVNlY29uZHMgPSAwO1xuICAgIHRoaXMuX3N0YXRlV2VpZ2h0ID0gMDtcbiAgICB0aGlzLl9sYXN0RXZlbnRDaGVja1NlY29uZHMgPSAwO1xuICAgIHRoaXMuX21vdGlvblF1ZXVlRW50cnlIYW5kbGUgPSB0aGlzO1xuICAgIHRoaXMuX2ZhZGVPdXRTZWNvbmRzID0gMDtcbiAgICB0aGlzLl9pc1RyaWdnZXJlZEZhZGVPdXQgPSBmYWxzZTtcbiAgfVxuICByZWxlYXNlKCkge1xuICAgIGlmICh0aGlzLl9hdXRvRGVsZXRlICYmIHRoaXMuX21vdGlvbikge1xuICAgICAgdGhpcy5fbW90aW9uLnJlbGVhc2UoKTtcbiAgICB9XG4gIH1cbiAgc2V0RmFkZU91dChmYWRlT3V0U2Vjb25kcykge1xuICAgIHRoaXMuX2ZhZGVPdXRTZWNvbmRzID0gZmFkZU91dFNlY29uZHM7XG4gICAgdGhpcy5faXNUcmlnZ2VyZWRGYWRlT3V0ID0gdHJ1ZTtcbiAgfVxuICBzdGFydEZhZGVPdXQoZmFkZU91dFNlY29uZHMsIHVzZXJUaW1lU2Vjb25kcykge1xuICAgIGNvbnN0IG5ld0VuZFRpbWVTZWNvbmRzID0gdXNlclRpbWVTZWNvbmRzICsgZmFkZU91dFNlY29uZHM7XG4gICAgdGhpcy5faXNUcmlnZ2VyZWRGYWRlT3V0ID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5fZW5kVGltZVNlY29uZHMgPCAwIHx8IG5ld0VuZFRpbWVTZWNvbmRzIDwgdGhpcy5fZW5kVGltZVNlY29uZHMpIHtcbiAgICAgIHRoaXMuX2VuZFRpbWVTZWNvbmRzID0gbmV3RW5kVGltZVNlY29uZHM7XG4gICAgfVxuICB9XG4gIGlzRmluaXNoZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbmlzaGVkO1xuICB9XG4gIGlzU3RhcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnRlZDtcbiAgfVxuICBnZXRTdGFydFRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0VGltZVNlY29uZHM7XG4gIH1cbiAgZ2V0RmFkZUluU3RhcnRUaW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9mYWRlSW5TdGFydFRpbWVTZWNvbmRzO1xuICB9XG4gIGdldEVuZFRpbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuZFRpbWVTZWNvbmRzO1xuICB9XG4gIHNldFN0YXJ0VGltZShzdGFydFRpbWUpIHtcbiAgICB0aGlzLl9zdGFydFRpbWVTZWNvbmRzID0gc3RhcnRUaW1lO1xuICB9XG4gIHNldEZhZGVJblN0YXJ0VGltZShzdGFydFRpbWUpIHtcbiAgICB0aGlzLl9mYWRlSW5TdGFydFRpbWVTZWNvbmRzID0gc3RhcnRUaW1lO1xuICB9XG4gIHNldEVuZFRpbWUoZW5kVGltZSkge1xuICAgIHRoaXMuX2VuZFRpbWVTZWNvbmRzID0gZW5kVGltZTtcbiAgfVxuICBzZXRJc0ZpbmlzaGVkKGYpIHtcbiAgICB0aGlzLl9maW5pc2hlZCA9IGY7XG4gIH1cbiAgc2V0SXNTdGFydGVkKGYpIHtcbiAgICB0aGlzLl9zdGFydGVkID0gZjtcbiAgfVxuICBpc0F2YWlsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXZhaWxhYmxlO1xuICB9XG4gIHNldElzQXZhaWxhYmxlKHYpIHtcbiAgICB0aGlzLl9hdmFpbGFibGUgPSB2O1xuICB9XG4gIHNldFN0YXRlKHRpbWVTZWNvbmRzLCB3ZWlnaHQpIHtcbiAgICB0aGlzLl9zdGF0ZVRpbWVTZWNvbmRzID0gdGltZVNlY29uZHM7XG4gICAgdGhpcy5fc3RhdGVXZWlnaHQgPSB3ZWlnaHQ7XG4gIH1cbiAgZ2V0U3RhdGVUaW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZVRpbWVTZWNvbmRzO1xuICB9XG4gIGdldFN0YXRlV2VpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZVdlaWdodDtcbiAgfVxuICBnZXRMYXN0Q2hlY2tFdmVudFNlY29uZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xhc3RFdmVudENoZWNrU2Vjb25kcztcbiAgfVxuICBzZXRMYXN0Q2hlY2tFdmVudFNlY29uZHMoY2hlY2tTZWNvbmRzKSB7XG4gICAgdGhpcy5fbGFzdEV2ZW50Q2hlY2tTZWNvbmRzID0gY2hlY2tTZWNvbmRzO1xuICB9XG4gIGlzVHJpZ2dlcmVkRmFkZU91dCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNUcmlnZ2VyZWRGYWRlT3V0O1xuICB9XG4gIGdldEZhZGVPdXRTZWNvbmRzKCkge1xuICAgIHJldHVybiB0aGlzLl9mYWRlT3V0U2Vjb25kcztcbiAgfVxufVxuY2xhc3MgQ3ViaXNtTW90aW9uUXVldWVNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fdXNlclRpbWVTZWNvbmRzID0gMDtcbiAgICB0aGlzLl9ldmVudEN1c3RvbURhdGEgPSBudWxsO1xuICAgIHRoaXMuX21vdGlvbnMgPSBbXTtcbiAgfVxuICByZWxlYXNlKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbW90aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHRoaXMuX21vdGlvbnNbaV0pIHtcbiAgICAgICAgdGhpcy5fbW90aW9uc1tpXS5yZWxlYXNlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX21vdGlvbnMgPSB2b2lkIDA7XG4gIH1cbiAgc3RhcnRNb3Rpb24obW90aW9uLCBhdXRvRGVsZXRlLCB1c2VyVGltZVNlY29uZHMpIHtcbiAgICBpZiAobW90aW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybiBJbnZhbGlkTW90aW9uUXVldWVFbnRyeUhhbmRsZVZhbHVlO1xuICAgIH1cbiAgICBsZXQgbW90aW9uUXVldWVFbnRyeTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX21vdGlvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIG1vdGlvblF1ZXVlRW50cnkgPSB0aGlzLl9tb3Rpb25zW2ldO1xuICAgICAgaWYgKG1vdGlvblF1ZXVlRW50cnkgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG1vdGlvblF1ZXVlRW50cnkuc2V0RmFkZU91dChtb3Rpb25RdWV1ZUVudHJ5Ll9tb3Rpb24uZ2V0RmFkZU91dFRpbWUoKSk7XG4gICAgfVxuICAgIG1vdGlvblF1ZXVlRW50cnkgPSBuZXcgQ3ViaXNtTW90aW9uUXVldWVFbnRyeSgpO1xuICAgIG1vdGlvblF1ZXVlRW50cnkuX2F1dG9EZWxldGUgPSBhdXRvRGVsZXRlO1xuICAgIG1vdGlvblF1ZXVlRW50cnkuX21vdGlvbiA9IG1vdGlvbjtcbiAgICB0aGlzLl9tb3Rpb25zLnB1c2gobW90aW9uUXVldWVFbnRyeSk7XG4gICAgcmV0dXJuIG1vdGlvblF1ZXVlRW50cnkuX21vdGlvblF1ZXVlRW50cnlIYW5kbGU7XG4gIH1cbiAgaXNGaW5pc2hlZCgpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCB0aGlzLl9tb3Rpb25zLmxlbmd0aCkge1xuICAgICAgY29uc3QgbW90aW9uUXVldWVFbnRyeSA9IHRoaXMuX21vdGlvbnNbaV07XG4gICAgICBpZiAobW90aW9uUXVldWVFbnRyeSA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX21vdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vdGlvbiA9IG1vdGlvblF1ZXVlRW50cnkuX21vdGlvbjtcbiAgICAgIGlmIChtb3Rpb24gPT0gbnVsbCkge1xuICAgICAgICBtb3Rpb25RdWV1ZUVudHJ5LnJlbGVhc2UoKTtcbiAgICAgICAgdGhpcy5fbW90aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFtb3Rpb25RdWV1ZUVudHJ5LmlzRmluaXNoZWQoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlzRmluaXNoZWRCeUhhbmRsZShtb3Rpb25RdWV1ZUVudHJ5TnVtYmVyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9tb3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBtb3Rpb25RdWV1ZUVudHJ5ID0gdGhpcy5fbW90aW9uc1tpXTtcbiAgICAgIGlmIChtb3Rpb25RdWV1ZUVudHJ5ID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobW90aW9uUXVldWVFbnRyeS5fbW90aW9uUXVldWVFbnRyeUhhbmRsZSA9PSBtb3Rpb25RdWV1ZUVudHJ5TnVtYmVyICYmICFtb3Rpb25RdWV1ZUVudHJ5LmlzRmluaXNoZWQoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN0b3BBbGxNb3Rpb25zKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbW90aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbW90aW9uUXVldWVFbnRyeSA9IHRoaXMuX21vdGlvbnNbaV07XG4gICAgICBpZiAobW90aW9uUXVldWVFbnRyeSAhPSBudWxsKSB7XG4gICAgICAgIG1vdGlvblF1ZXVlRW50cnkucmVsZWFzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9tb3Rpb25zID0gW107XG4gIH1cbiAgZ2V0Q3ViaXNtTW90aW9uUXVldWVFbnRyeShtb3Rpb25RdWV1ZUVudHJ5TnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vdGlvbnMuZmluZCgoZW50cnkpID0+IGVudHJ5ICE9IG51bGwgJiYgZW50cnkuX21vdGlvblF1ZXVlRW50cnlIYW5kbGUgPT0gbW90aW9uUXVldWVFbnRyeU51bWJlcik7XG4gIH1cbiAgc2V0RXZlbnRDYWxsYmFjayhjYWxsYmFjaywgY3VzdG9tRGF0YSA9IG51bGwpIHtcbiAgICB0aGlzLl9ldmVudENhbGxCYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5fZXZlbnRDdXN0b21EYXRhID0gY3VzdG9tRGF0YTtcbiAgfVxuICBkb1VwZGF0ZU1vdGlvbihtb2RlbCwgdXNlclRpbWVTZWNvbmRzKSB7XG4gICAgbGV0IHVwZGF0ZWQgPSBmYWxzZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCB0aGlzLl9tb3Rpb25zLmxlbmd0aCkge1xuICAgICAgY29uc3QgbW90aW9uUXVldWVFbnRyeSA9IHRoaXMuX21vdGlvbnNbaV07XG4gICAgICBpZiAobW90aW9uUXVldWVFbnRyeSA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX21vdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1vdGlvbiA9IG1vdGlvblF1ZXVlRW50cnkuX21vdGlvbjtcbiAgICAgIGlmIChtb3Rpb24gPT0gbnVsbCkge1xuICAgICAgICBtb3Rpb25RdWV1ZUVudHJ5LnJlbGVhc2UoKTtcbiAgICAgICAgdGhpcy5fbW90aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbW90aW9uLnVwZGF0ZVBhcmFtZXRlcnMobW9kZWwsIG1vdGlvblF1ZXVlRW50cnksIHVzZXJUaW1lU2Vjb25kcyk7XG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGZpcmVkTGlzdCA9IG1vdGlvbi5nZXRGaXJlZEV2ZW50KG1vdGlvblF1ZXVlRW50cnkuZ2V0TGFzdENoZWNrRXZlbnRTZWNvbmRzKCkgLSBtb3Rpb25RdWV1ZUVudHJ5LmdldFN0YXJ0VGltZSgpLCB1c2VyVGltZVNlY29uZHMgLSBtb3Rpb25RdWV1ZUVudHJ5LmdldFN0YXJ0VGltZSgpKTtcbiAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBmaXJlZExpc3QubGVuZ3RoOyArK2kyKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50Q2FsbEJhY2sodGhpcywgZmlyZWRMaXN0W2kyXSwgdGhpcy5fZXZlbnRDdXN0b21EYXRhKTtcbiAgICAgIH1cbiAgICAgIG1vdGlvblF1ZXVlRW50cnkuc2V0TGFzdENoZWNrRXZlbnRTZWNvbmRzKHVzZXJUaW1lU2Vjb25kcyk7XG4gICAgICBpZiAobW90aW9uUXVldWVFbnRyeS5pc0ZpbmlzaGVkKCkpIHtcbiAgICAgICAgbW90aW9uUXVldWVFbnRyeS5yZWxlYXNlKCk7XG4gICAgICAgIHRoaXMuX21vdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG1vdGlvblF1ZXVlRW50cnkuaXNUcmlnZ2VyZWRGYWRlT3V0KCkpIHtcbiAgICAgICAgICBtb3Rpb25RdWV1ZUVudHJ5LnN0YXJ0RmFkZU91dChtb3Rpb25RdWV1ZUVudHJ5LmdldEZhZGVPdXRTZWNvbmRzKCksIHVzZXJUaW1lU2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlZDtcbiAgfVxufVxuY29uc3QgSW52YWxpZE1vdGlvblF1ZXVlRW50cnlIYW5kbGVWYWx1ZSA9IC0xO1xuY2xhc3MgQ3ViaXNtTW90aW9uTWFuYWdlciBleHRlbmRzIEN1YmlzbU1vdGlvblF1ZXVlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fY3VycmVudFByaW9yaXR5ID0gMDtcbiAgICB0aGlzLl9yZXNlcnZlUHJpb3JpdHkgPSAwO1xuICB9XG4gIGdldEN1cnJlbnRQcmlvcml0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFByaW9yaXR5O1xuICB9XG4gIGdldFJlc2VydmVQcmlvcml0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzZXJ2ZVByaW9yaXR5O1xuICB9XG4gIHNldFJlc2VydmVQcmlvcml0eSh2YWwpIHtcbiAgICB0aGlzLl9yZXNlcnZlUHJpb3JpdHkgPSB2YWw7XG4gIH1cbiAgc3RhcnRNb3Rpb25Qcmlvcml0eShtb3Rpb24sIGF1dG9EZWxldGUsIHByaW9yaXR5KSB7XG4gICAgaWYgKHByaW9yaXR5ID09IHRoaXMuX3Jlc2VydmVQcmlvcml0eSkge1xuICAgICAgdGhpcy5fcmVzZXJ2ZVByaW9yaXR5ID0gMDtcbiAgICB9XG4gICAgdGhpcy5fY3VycmVudFByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgcmV0dXJuIHN1cGVyLnN0YXJ0TW90aW9uKG1vdGlvbiwgYXV0b0RlbGV0ZSwgdGhpcy5fdXNlclRpbWVTZWNvbmRzKTtcbiAgfVxuICB1cGRhdGVNb3Rpb24obW9kZWwsIGRlbHRhVGltZVNlY29uZHMpIHtcbiAgICB0aGlzLl91c2VyVGltZVNlY29uZHMgKz0gZGVsdGFUaW1lU2Vjb25kcztcbiAgICBjb25zdCB1cGRhdGVkID0gc3VwZXIuZG9VcGRhdGVNb3Rpb24obW9kZWwsIHRoaXMuX3VzZXJUaW1lU2Vjb25kcyk7XG4gICAgaWYgKHRoaXMuaXNGaW5pc2hlZCgpKSB7XG4gICAgICB0aGlzLl9jdXJyZW50UHJpb3JpdHkgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlZDtcbiAgfVxuICByZXNlcnZlTW90aW9uKHByaW9yaXR5KSB7XG4gICAgaWYgKHByaW9yaXR5IDw9IHRoaXMuX3Jlc2VydmVQcmlvcml0eSB8fCBwcmlvcml0eSA8PSB0aGlzLl9jdXJyZW50UHJpb3JpdHkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5fcmVzZXJ2ZVByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbnZhciBDdWJpc21QaHlzaWNzVGFyZ2V0VHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEN1YmlzbVBoeXNpY3NUYXJnZXRUeXBlMikgPT4ge1xuICBDdWJpc21QaHlzaWNzVGFyZ2V0VHlwZTJbQ3ViaXNtUGh5c2ljc1RhcmdldFR5cGUyW1wiQ3ViaXNtUGh5c2ljc1RhcmdldFR5cGVfUGFyYW1ldGVyXCJdID0gMF0gPSBcIkN1YmlzbVBoeXNpY3NUYXJnZXRUeXBlX1BhcmFtZXRlclwiO1xuICByZXR1cm4gQ3ViaXNtUGh5c2ljc1RhcmdldFR5cGUyO1xufSkoQ3ViaXNtUGh5c2ljc1RhcmdldFR5cGUgfHwge30pO1xudmFyIEN1YmlzbVBoeXNpY3NTb3VyY2UgPSAvKiBAX19QVVJFX18gKi8gKChDdWJpc21QaHlzaWNzU291cmNlMikgPT4ge1xuICBDdWJpc21QaHlzaWNzU291cmNlMltDdWJpc21QaHlzaWNzU291cmNlMltcIkN1YmlzbVBoeXNpY3NTb3VyY2VfWFwiXSA9IDBdID0gXCJDdWJpc21QaHlzaWNzU291cmNlX1hcIjtcbiAgQ3ViaXNtUGh5c2ljc1NvdXJjZTJbQ3ViaXNtUGh5c2ljc1NvdXJjZTJbXCJDdWJpc21QaHlzaWNzU291cmNlX1lcIl0gPSAxXSA9IFwiQ3ViaXNtUGh5c2ljc1NvdXJjZV9ZXCI7XG4gIEN1YmlzbVBoeXNpY3NTb3VyY2UyW0N1YmlzbVBoeXNpY3NTb3VyY2UyW1wiQ3ViaXNtUGh5c2ljc1NvdXJjZV9BbmdsZVwiXSA9IDJdID0gXCJDdWJpc21QaHlzaWNzU291cmNlX0FuZ2xlXCI7XG4gIHJldHVybiBDdWJpc21QaHlzaWNzU291cmNlMjtcbn0pKEN1YmlzbVBoeXNpY3NTb3VyY2UgfHwge30pO1xuY2xhc3MgUGh5c2ljc0pzb25FZmZlY3RpdmVGb3JjZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmdyYXZpdHkgPSBuZXcgQ3ViaXNtVmVjdG9yMigwLCAwKTtcbiAgICB0aGlzLndpbmQgPSBuZXcgQ3ViaXNtVmVjdG9yMigwLCAwKTtcbiAgfVxufVxuY2xhc3MgQ3ViaXNtUGh5c2ljc1BhcnRpY2xlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pbml0aWFsUG9zaXRpb24gPSBuZXcgQ3ViaXNtVmVjdG9yMigwLCAwKTtcbiAgICB0aGlzLnBvc2l0aW9uID0gbmV3IEN1YmlzbVZlY3RvcjIoMCwgMCk7XG4gICAgdGhpcy5sYXN0UG9zaXRpb24gPSBuZXcgQ3ViaXNtVmVjdG9yMigwLCAwKTtcbiAgICB0aGlzLmxhc3RHcmF2aXR5ID0gbmV3IEN1YmlzbVZlY3RvcjIoMCwgMCk7XG4gICAgdGhpcy5mb3JjZSA9IG5ldyBDdWJpc21WZWN0b3IyKDAsIDApO1xuICAgIHRoaXMudmVsb2NpdHkgPSBuZXcgQ3ViaXNtVmVjdG9yMigwLCAwKTtcbiAgfVxufVxuY2xhc3MgQ3ViaXNtUGh5c2ljc1N1YlJpZyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubm9ybWFsaXphdGlvblBvc2l0aW9uID0ge307XG4gICAgdGhpcy5ub3JtYWxpemF0aW9uQW5nbGUgPSB7fTtcbiAgfVxufVxuY2xhc3MgQ3ViaXNtUGh5c2ljc0lucHV0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zb3VyY2UgPSB7fTtcbiAgfVxufVxuY2xhc3MgQ3ViaXNtUGh5c2ljc091dHB1dCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZGVzdGluYXRpb24gPSB7fTtcbiAgICB0aGlzLnRyYW5zbGF0aW9uU2NhbGUgPSBuZXcgQ3ViaXNtVmVjdG9yMigwLCAwKTtcbiAgfVxufVxuY2xhc3MgQ3ViaXNtUGh5c2ljc1JpZyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2V0dGluZ3MgPSBbXTtcbiAgICB0aGlzLmlucHV0cyA9IFtdO1xuICAgIHRoaXMub3V0cHV0cyA9IFtdO1xuICAgIHRoaXMucGFydGljbGVzID0gW107XG4gICAgdGhpcy5ncmF2aXR5ID0gbmV3IEN1YmlzbVZlY3RvcjIoMCwgMCk7XG4gICAgdGhpcy53aW5kID0gbmV3IEN1YmlzbVZlY3RvcjIoMCwgMCk7XG4gIH1cbn1cbmNsYXNzIEN1YmlzbVBoeXNpY3NKc29uIHtcbiAgY29uc3RydWN0b3IoanNvbikge1xuICAgIHRoaXMuX2pzb24gPSBqc29uO1xuICB9XG4gIHJlbGVhc2UoKSB7XG4gICAgdGhpcy5fanNvbiA9IHZvaWQgMDtcbiAgfVxuICBnZXRHcmF2aXR5KCkge1xuICAgIGNvbnN0IHJldCA9IG5ldyBDdWJpc21WZWN0b3IyKDAsIDApO1xuICAgIHJldC54ID0gdGhpcy5fanNvbi5NZXRhLkVmZmVjdGl2ZUZvcmNlcy5HcmF2aXR5Llg7XG4gICAgcmV0LnkgPSB0aGlzLl9qc29uLk1ldGEuRWZmZWN0aXZlRm9yY2VzLkdyYXZpdHkuWTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGdldFdpbmQoKSB7XG4gICAgY29uc3QgcmV0ID0gbmV3IEN1YmlzbVZlY3RvcjIoMCwgMCk7XG4gICAgcmV0LnggPSB0aGlzLl9qc29uLk1ldGEuRWZmZWN0aXZlRm9yY2VzLldpbmQuWDtcbiAgICByZXQueSA9IHRoaXMuX2pzb24uTWV0YS5FZmZlY3RpdmVGb3JjZXMuV2luZC5ZO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgZ2V0U3ViUmlnQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2pzb24uTWV0YS5QaHlzaWNzU2V0dGluZ0NvdW50O1xuICB9XG4gIGdldFRvdGFsSW5wdXRDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fanNvbi5NZXRhLlRvdGFsSW5wdXRDb3VudDtcbiAgfVxuICBnZXRUb3RhbE91dHB1dENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLl9qc29uLk1ldGEuVG90YWxPdXRwdXRDb3VudDtcbiAgfVxuICBnZXRWZXJ0ZXhDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fanNvbi5NZXRhLlZlcnRleENvdW50O1xuICB9XG4gIGdldE5vcm1hbGl6YXRpb25Qb3NpdGlvbk1pbmltdW1WYWx1ZShwaHlzaWNzU2V0dGluZ0luZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2pzb24uUGh5c2ljc1NldHRpbmdzW3BoeXNpY3NTZXR0aW5nSW5kZXhdLk5vcm1hbGl6YXRpb24uUG9zaXRpb24uTWluaW11bTtcbiAgfVxuICBnZXROb3JtYWxpemF0aW9uUG9zaXRpb25NYXhpbXVtVmFsdWUocGh5c2ljc1NldHRpbmdJbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9qc29uLlBoeXNpY3NTZXR0aW5nc1twaHlzaWNzU2V0dGluZ0luZGV4XS5Ob3JtYWxpemF0aW9uLlBvc2l0aW9uLk1heGltdW07XG4gIH1cbiAgZ2V0Tm9ybWFsaXphdGlvblBvc2l0aW9uRGVmYXVsdFZhbHVlKHBoeXNpY3NTZXR0aW5nSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fanNvbi5QaHlzaWNzU2V0dGluZ3NbcGh5c2ljc1NldHRpbmdJbmRleF0uTm9ybWFsaXphdGlvbi5Qb3NpdGlvbi5EZWZhdWx0O1xuICB9XG4gIGdldE5vcm1hbGl6YXRpb25BbmdsZU1pbmltdW1WYWx1ZShwaHlzaWNzU2V0dGluZ0luZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2pzb24uUGh5c2ljc1NldHRpbmdzW3BoeXNpY3NTZXR0aW5nSW5kZXhdLk5vcm1hbGl6YXRpb24uQW5nbGUuTWluaW11bTtcbiAgfVxuICBnZXROb3JtYWxpemF0aW9uQW5nbGVNYXhpbXVtVmFsdWUocGh5c2ljc1NldHRpbmdJbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9qc29uLlBoeXNpY3NTZXR0aW5nc1twaHlzaWNzU2V0dGluZ0luZGV4XS5Ob3JtYWxpemF0aW9uLkFuZ2xlLk1heGltdW07XG4gIH1cbiAgZ2V0Tm9ybWFsaXphdGlvbkFuZ2xlRGVmYXVsdFZhbHVlKHBoeXNpY3NTZXR0aW5nSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fanNvbi5QaHlzaWNzU2V0dGluZ3NbcGh5c2ljc1NldHRpbmdJbmRleF0uTm9ybWFsaXphdGlvbi5BbmdsZS5EZWZhdWx0O1xuICB9XG4gIGdldElucHV0Q291bnQocGh5c2ljc1NldHRpbmdJbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9qc29uLlBoeXNpY3NTZXR0aW5nc1twaHlzaWNzU2V0dGluZ0luZGV4XS5JbnB1dC5sZW5ndGg7XG4gIH1cbiAgZ2V0SW5wdXRXZWlnaHQocGh5c2ljc1NldHRpbmdJbmRleCwgaW5wdXRJbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9qc29uLlBoeXNpY3NTZXR0aW5nc1twaHlzaWNzU2V0dGluZ0luZGV4XS5JbnB1dFtpbnB1dEluZGV4XS5XZWlnaHQ7XG4gIH1cbiAgZ2V0SW5wdXRSZWZsZWN0KHBoeXNpY3NTZXR0aW5nSW5kZXgsIGlucHV0SW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fanNvbi5QaHlzaWNzU2V0dGluZ3NbcGh5c2ljc1NldHRpbmdJbmRleF0uSW5wdXRbaW5wdXRJbmRleF0uUmVmbGVjdDtcbiAgfVxuICBnZXRJbnB1dFR5cGUocGh5c2ljc1NldHRpbmdJbmRleCwgaW5wdXRJbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9qc29uLlBoeXNpY3NTZXR0aW5nc1twaHlzaWNzU2V0dGluZ0luZGV4XS5JbnB1dFtpbnB1dEluZGV4XS5UeXBlO1xuICB9XG4gIGdldElucHV0U291cmNlSWQocGh5c2ljc1NldHRpbmdJbmRleCwgaW5wdXRJbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9qc29uLlBoeXNpY3NTZXR0aW5nc1twaHlzaWNzU2V0dGluZ0luZGV4XS5JbnB1dFtpbnB1dEluZGV4XS5Tb3VyY2UuSWQ7XG4gIH1cbiAgZ2V0T3V0cHV0Q291bnQocGh5c2ljc1NldHRpbmdJbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9qc29uLlBoeXNpY3NTZXR0aW5nc1twaHlzaWNzU2V0dGluZ0luZGV4XS5PdXRwdXQubGVuZ3RoO1xuICB9XG4gIGdldE91dHB1dFZlcnRleEluZGV4KHBoeXNpY3NTZXR0aW5nSW5kZXgsIG91dHB1dEluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2pzb24uUGh5c2ljc1NldHRpbmdzW3BoeXNpY3NTZXR0aW5nSW5kZXhdLk91dHB1dFtvdXRwdXRJbmRleF0uVmVydGV4SW5kZXg7XG4gIH1cbiAgZ2V0T3V0cHV0QW5nbGVTY2FsZShwaHlzaWNzU2V0dGluZ0luZGV4LCBvdXRwdXRJbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9qc29uLlBoeXNpY3NTZXR0aW5nc1twaHlzaWNzU2V0dGluZ0luZGV4XS5PdXRwdXRbb3V0cHV0SW5kZXhdLlNjYWxlO1xuICB9XG4gIGdldE91dHB1dFdlaWdodChwaHlzaWNzU2V0dGluZ0luZGV4LCBvdXRwdXRJbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9qc29uLlBoeXNpY3NTZXR0aW5nc1twaHlzaWNzU2V0dGluZ0luZGV4XS5PdXRwdXRbb3V0cHV0SW5kZXhdLldlaWdodDtcbiAgfVxuICBnZXRPdXRwdXREZXN0aW5hdGlvbklkKHBoeXNpY3NTZXR0aW5nSW5kZXgsIG91dHB1dEluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2pzb24uUGh5c2ljc1NldHRpbmdzW3BoeXNpY3NTZXR0aW5nSW5kZXhdLk91dHB1dFtvdXRwdXRJbmRleF0uRGVzdGluYXRpb24uSWQ7XG4gIH1cbiAgZ2V0T3V0cHV0VHlwZShwaHlzaWNzU2V0dGluZ0luZGV4LCBvdXRwdXRJbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9qc29uLlBoeXNpY3NTZXR0aW5nc1twaHlzaWNzU2V0dGluZ0luZGV4XS5PdXRwdXRbb3V0cHV0SW5kZXhdLlR5cGU7XG4gIH1cbiAgZ2V0T3V0cHV0UmVmbGVjdChwaHlzaWNzU2V0dGluZ0luZGV4LCBvdXRwdXRJbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9qc29uLlBoeXNpY3NTZXR0aW5nc1twaHlzaWNzU2V0dGluZ0luZGV4XS5PdXRwdXRbb3V0cHV0SW5kZXhdLlJlZmxlY3Q7XG4gIH1cbiAgZ2V0UGFydGljbGVDb3VudChwaHlzaWNzU2V0dGluZ0luZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2pzb24uUGh5c2ljc1NldHRpbmdzW3BoeXNpY3NTZXR0aW5nSW5kZXhdLlZlcnRpY2VzLmxlbmd0aDtcbiAgfVxuICBnZXRQYXJ0aWNsZU1vYmlsaXR5KHBoeXNpY3NTZXR0aW5nSW5kZXgsIHZlcnRleEluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2pzb24uUGh5c2ljc1NldHRpbmdzW3BoeXNpY3NTZXR0aW5nSW5kZXhdLlZlcnRpY2VzW3ZlcnRleEluZGV4XS5Nb2JpbGl0eTtcbiAgfVxuICBnZXRQYXJ0aWNsZURlbGF5KHBoeXNpY3NTZXR0aW5nSW5kZXgsIHZlcnRleEluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2pzb24uUGh5c2ljc1NldHRpbmdzW3BoeXNpY3NTZXR0aW5nSW5kZXhdLlZlcnRpY2VzW3ZlcnRleEluZGV4XS5EZWxheTtcbiAgfVxuICBnZXRQYXJ0aWNsZUFjY2VsZXJhdGlvbihwaHlzaWNzU2V0dGluZ0luZGV4LCB2ZXJ0ZXhJbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9qc29uLlBoeXNpY3NTZXR0aW5nc1twaHlzaWNzU2V0dGluZ0luZGV4XS5WZXJ0aWNlc1t2ZXJ0ZXhJbmRleF0uQWNjZWxlcmF0aW9uO1xuICB9XG4gIGdldFBhcnRpY2xlUmFkaXVzKHBoeXNpY3NTZXR0aW5nSW5kZXgsIHZlcnRleEluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2pzb24uUGh5c2ljc1NldHRpbmdzW3BoeXNpY3NTZXR0aW5nSW5kZXhdLlZlcnRpY2VzW3ZlcnRleEluZGV4XS5SYWRpdXM7XG4gIH1cbiAgZ2V0UGFydGljbGVQb3NpdGlvbihwaHlzaWNzU2V0dGluZ0luZGV4LCB2ZXJ0ZXhJbmRleCkge1xuICAgIGNvbnN0IHJldCA9IG5ldyBDdWJpc21WZWN0b3IyKDAsIDApO1xuICAgIHJldC54ID0gdGhpcy5fanNvbi5QaHlzaWNzU2V0dGluZ3NbcGh5c2ljc1NldHRpbmdJbmRleF0uVmVydGljZXNbdmVydGV4SW5kZXhdLlBvc2l0aW9uLlg7XG4gICAgcmV0LnkgPSB0aGlzLl9qc29uLlBoeXNpY3NTZXR0aW5nc1twaHlzaWNzU2V0dGluZ0luZGV4XS5WZXJ0aWNlc1t2ZXJ0ZXhJbmRleF0uUG9zaXRpb24uWTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG59XG5jb25zdCBQaHlzaWNzVHlwZVRhZ1ggPSBcIlhcIjtcbmNvbnN0IFBoeXNpY3NUeXBlVGFnWSA9IFwiWVwiO1xuY29uc3QgUGh5c2ljc1R5cGVUYWdBbmdsZSA9IFwiQW5nbGVcIjtcbmNvbnN0IEFpclJlc2lzdGFuY2UgPSA1O1xuY29uc3QgTWF4aW11bVdlaWdodCA9IDEwMDtcbmNvbnN0IE1vdmVtZW50VGhyZXNob2xkID0gMWUtMztcbmNsYXNzIEN1YmlzbVBoeXNpY3Mge1xuICBzdGF0aWMgY3JlYXRlKGpzb24pIHtcbiAgICBjb25zdCByZXQgPSBuZXcgQ3ViaXNtUGh5c2ljcygpO1xuICAgIHJldC5wYXJzZShqc29uKTtcbiAgICByZXQuX3BoeXNpY3NSaWcuZ3Jhdml0eS55ID0gMDtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGV2YWx1YXRlKG1vZGVsLCBkZWx0YVRpbWVTZWNvbmRzKSB7XG4gICAgbGV0IHRvdGFsQW5nbGU7XG4gICAgbGV0IHdlaWdodDtcbiAgICBsZXQgcmFkQW5nbGU7XG4gICAgbGV0IG91dHB1dFZhbHVlO1xuICAgIGNvbnN0IHRvdGFsVHJhbnNsYXRpb24gPSBuZXcgQ3ViaXNtVmVjdG9yMigpO1xuICAgIGxldCBjdXJyZW50U2V0dGluZztcbiAgICBsZXQgY3VycmVudElucHV0O1xuICAgIGxldCBjdXJyZW50T3V0cHV0O1xuICAgIGxldCBjdXJyZW50UGFydGljbGVzO1xuICAgIGxldCBwYXJhbWV0ZXJWYWx1ZTtcbiAgICBsZXQgcGFyYW1ldGVyTWF4aW11bVZhbHVlO1xuICAgIGxldCBwYXJhbWV0ZXJNaW5pbXVtVmFsdWU7XG4gICAgbGV0IHBhcmFtZXRlckRlZmF1bHRWYWx1ZTtcbiAgICBwYXJhbWV0ZXJWYWx1ZSA9IG1vZGVsLmdldE1vZGVsKCkucGFyYW1ldGVycy52YWx1ZXM7XG4gICAgcGFyYW1ldGVyTWF4aW11bVZhbHVlID0gbW9kZWwuZ2V0TW9kZWwoKS5wYXJhbWV0ZXJzLm1heGltdW1WYWx1ZXM7XG4gICAgcGFyYW1ldGVyTWluaW11bVZhbHVlID0gbW9kZWwuZ2V0TW9kZWwoKS5wYXJhbWV0ZXJzLm1pbmltdW1WYWx1ZXM7XG4gICAgcGFyYW1ldGVyRGVmYXVsdFZhbHVlID0gbW9kZWwuZ2V0TW9kZWwoKS5wYXJhbWV0ZXJzLmRlZmF1bHRWYWx1ZXM7XG4gICAgZm9yIChsZXQgc2V0dGluZ0luZGV4ID0gMDsgc2V0dGluZ0luZGV4IDwgdGhpcy5fcGh5c2ljc1JpZy5zdWJSaWdDb3VudDsgKytzZXR0aW5nSW5kZXgpIHtcbiAgICAgIHRvdGFsQW5nbGUgPSB7IGFuZ2xlOiAwIH07XG4gICAgICB0b3RhbFRyYW5zbGF0aW9uLnggPSAwO1xuICAgICAgdG90YWxUcmFuc2xhdGlvbi55ID0gMDtcbiAgICAgIGN1cnJlbnRTZXR0aW5nID0gdGhpcy5fcGh5c2ljc1JpZy5zZXR0aW5nc1tzZXR0aW5nSW5kZXhdO1xuICAgICAgY3VycmVudElucHV0ID0gdGhpcy5fcGh5c2ljc1JpZy5pbnB1dHMuc2xpY2UoY3VycmVudFNldHRpbmcuYmFzZUlucHV0SW5kZXgpO1xuICAgICAgY3VycmVudE91dHB1dCA9IHRoaXMuX3BoeXNpY3NSaWcub3V0cHV0cy5zbGljZShjdXJyZW50U2V0dGluZy5iYXNlT3V0cHV0SW5kZXgpO1xuICAgICAgY3VycmVudFBhcnRpY2xlcyA9IHRoaXMuX3BoeXNpY3NSaWcucGFydGljbGVzLnNsaWNlKGN1cnJlbnRTZXR0aW5nLmJhc2VQYXJ0aWNsZUluZGV4KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudFNldHRpbmcuaW5wdXRDb3VudDsgKytpKSB7XG4gICAgICAgIHdlaWdodCA9IGN1cnJlbnRJbnB1dFtpXS53ZWlnaHQgLyBNYXhpbXVtV2VpZ2h0O1xuICAgICAgICBpZiAoY3VycmVudElucHV0W2ldLnNvdXJjZVBhcmFtZXRlckluZGV4ID09IC0xKSB7XG4gICAgICAgICAgY3VycmVudElucHV0W2ldLnNvdXJjZVBhcmFtZXRlckluZGV4ID0gbW9kZWwuZ2V0UGFyYW1ldGVySW5kZXgoY3VycmVudElucHV0W2ldLnNvdXJjZS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudElucHV0W2ldLmdldE5vcm1hbGl6ZWRQYXJhbWV0ZXJWYWx1ZSh0b3RhbFRyYW5zbGF0aW9uLCB0b3RhbEFuZ2xlLCBwYXJhbWV0ZXJWYWx1ZVtjdXJyZW50SW5wdXRbaV0uc291cmNlUGFyYW1ldGVySW5kZXhdLCBwYXJhbWV0ZXJNaW5pbXVtVmFsdWVbY3VycmVudElucHV0W2ldLnNvdXJjZVBhcmFtZXRlckluZGV4XSwgcGFyYW1ldGVyTWF4aW11bVZhbHVlW2N1cnJlbnRJbnB1dFtpXS5zb3VyY2VQYXJhbWV0ZXJJbmRleF0sIHBhcmFtZXRlckRlZmF1bHRWYWx1ZVtjdXJyZW50SW5wdXRbaV0uc291cmNlUGFyYW1ldGVySW5kZXhdLCBjdXJyZW50U2V0dGluZy5ub3JtYWxpemF0aW9uUG9zaXRpb24sIGN1cnJlbnRTZXR0aW5nLm5vcm1hbGl6YXRpb25BbmdsZSwgY3VycmVudElucHV0W2ldLnJlZmxlY3QsIHdlaWdodCk7XG4gICAgICB9XG4gICAgICByYWRBbmdsZSA9IEN1YmlzbU1hdGguZGVncmVlc1RvUmFkaWFuKC10b3RhbEFuZ2xlLmFuZ2xlKTtcbiAgICAgIHRvdGFsVHJhbnNsYXRpb24ueCA9IHRvdGFsVHJhbnNsYXRpb24ueCAqIEN1YmlzbU1hdGguY29zKHJhZEFuZ2xlKSAtIHRvdGFsVHJhbnNsYXRpb24ueSAqIEN1YmlzbU1hdGguc2luKHJhZEFuZ2xlKTtcbiAgICAgIHRvdGFsVHJhbnNsYXRpb24ueSA9IHRvdGFsVHJhbnNsYXRpb24ueCAqIEN1YmlzbU1hdGguc2luKHJhZEFuZ2xlKSArIHRvdGFsVHJhbnNsYXRpb24ueSAqIEN1YmlzbU1hdGguY29zKHJhZEFuZ2xlKTtcbiAgICAgIHVwZGF0ZVBhcnRpY2xlcyhjdXJyZW50UGFydGljbGVzLCBjdXJyZW50U2V0dGluZy5wYXJ0aWNsZUNvdW50LCB0b3RhbFRyYW5zbGF0aW9uLCB0b3RhbEFuZ2xlLmFuZ2xlLCB0aGlzLl9vcHRpb25zLndpbmQsIE1vdmVtZW50VGhyZXNob2xkICogY3VycmVudFNldHRpbmcubm9ybWFsaXphdGlvblBvc2l0aW9uLm1heGltdW0sIGRlbHRhVGltZVNlY29uZHMsIEFpclJlc2lzdGFuY2UpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50U2V0dGluZy5vdXRwdXRDb3VudDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHBhcnRpY2xlSW5kZXggPSBjdXJyZW50T3V0cHV0W2ldLnZlcnRleEluZGV4O1xuICAgICAgICBpZiAocGFydGljbGVJbmRleCA8IDEgfHwgcGFydGljbGVJbmRleCA+PSBjdXJyZW50U2V0dGluZy5wYXJ0aWNsZUNvdW50KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRPdXRwdXRbaV0uZGVzdGluYXRpb25QYXJhbWV0ZXJJbmRleCA9PSAtMSkge1xuICAgICAgICAgIGN1cnJlbnRPdXRwdXRbaV0uZGVzdGluYXRpb25QYXJhbWV0ZXJJbmRleCA9IG1vZGVsLmdldFBhcmFtZXRlckluZGV4KGN1cnJlbnRPdXRwdXRbaV0uZGVzdGluYXRpb24uaWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zbGF0aW9uID0gbmV3IEN1YmlzbVZlY3RvcjIoKTtcbiAgICAgICAgdHJhbnNsYXRpb24ueCA9IGN1cnJlbnRQYXJ0aWNsZXNbcGFydGljbGVJbmRleF0ucG9zaXRpb24ueCAtIGN1cnJlbnRQYXJ0aWNsZXNbcGFydGljbGVJbmRleCAtIDFdLnBvc2l0aW9uLng7XG4gICAgICAgIHRyYW5zbGF0aW9uLnkgPSBjdXJyZW50UGFydGljbGVzW3BhcnRpY2xlSW5kZXhdLnBvc2l0aW9uLnkgLSBjdXJyZW50UGFydGljbGVzW3BhcnRpY2xlSW5kZXggLSAxXS5wb3NpdGlvbi55O1xuICAgICAgICBvdXRwdXRWYWx1ZSA9IGN1cnJlbnRPdXRwdXRbaV0uZ2V0VmFsdWUodHJhbnNsYXRpb24sIGN1cnJlbnRQYXJ0aWNsZXMsIHBhcnRpY2xlSW5kZXgsIGN1cnJlbnRPdXRwdXRbaV0ucmVmbGVjdCwgdGhpcy5fb3B0aW9ucy5ncmF2aXR5KTtcbiAgICAgICAgY29uc3QgZGVzdGluYXRpb25QYXJhbWV0ZXJJbmRleCA9IGN1cnJlbnRPdXRwdXRbaV0uZGVzdGluYXRpb25QYXJhbWV0ZXJJbmRleDtcbiAgICAgICAgY29uc3Qgb3V0UGFyYW1ldGVyVmFsdWUgPSAhRmxvYXQzMkFycmF5LnByb3RvdHlwZS5zbGljZSAmJiBcInN1YmFycmF5XCIgaW4gRmxvYXQzMkFycmF5LnByb3RvdHlwZSA/IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocGFyYW1ldGVyVmFsdWUuc3ViYXJyYXkoZGVzdGluYXRpb25QYXJhbWV0ZXJJbmRleCkpKSA6IHBhcmFtZXRlclZhbHVlLnNsaWNlKGRlc3RpbmF0aW9uUGFyYW1ldGVySW5kZXgpO1xuICAgICAgICB1cGRhdGVPdXRwdXRQYXJhbWV0ZXJWYWx1ZShvdXRQYXJhbWV0ZXJWYWx1ZSwgcGFyYW1ldGVyTWluaW11bVZhbHVlW2Rlc3RpbmF0aW9uUGFyYW1ldGVySW5kZXhdLCBwYXJhbWV0ZXJNYXhpbXVtVmFsdWVbZGVzdGluYXRpb25QYXJhbWV0ZXJJbmRleF0sIG91dHB1dFZhbHVlLCBjdXJyZW50T3V0cHV0W2ldKTtcbiAgICAgICAgZm9yIChsZXQgb2Zmc2V0ID0gZGVzdGluYXRpb25QYXJhbWV0ZXJJbmRleCwgb3V0UGFyYW1JbmRleCA9IDA7IG9mZnNldCA8IHBhcmFtZXRlclZhbHVlLmxlbmd0aDsgb2Zmc2V0KyssIG91dFBhcmFtSW5kZXgrKykge1xuICAgICAgICAgIHBhcmFtZXRlclZhbHVlW29mZnNldF0gPSBvdXRQYXJhbWV0ZXJWYWx1ZVtvdXRQYXJhbUluZGV4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICBnZXRPcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gIH1cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG5ldyBPcHRpb25zKCk7XG4gICAgdGhpcy5fb3B0aW9ucy5ncmF2aXR5LnkgPSAtMTtcbiAgICB0aGlzLl9vcHRpb25zLmdyYXZpdHkueCA9IDA7XG4gICAgdGhpcy5fb3B0aW9ucy53aW5kLnggPSAwO1xuICAgIHRoaXMuX29wdGlvbnMud2luZC55ID0gMDtcbiAgfVxuICByZWxlYXNlKCkge1xuICAgIHRoaXMuX3BoeXNpY3NSaWcgPSB2b2lkIDA7XG4gIH1cbiAgcGFyc2UocGh5c2ljc0pzb24pIHtcbiAgICB0aGlzLl9waHlzaWNzUmlnID0gbmV3IEN1YmlzbVBoeXNpY3NSaWcoKTtcbiAgICBsZXQganNvbiA9IG5ldyBDdWJpc21QaHlzaWNzSnNvbihwaHlzaWNzSnNvbik7XG4gICAgdGhpcy5fcGh5c2ljc1JpZy5ncmF2aXR5ID0ganNvbi5nZXRHcmF2aXR5KCk7XG4gICAgdGhpcy5fcGh5c2ljc1JpZy53aW5kID0ganNvbi5nZXRXaW5kKCk7XG4gICAgdGhpcy5fcGh5c2ljc1JpZy5zdWJSaWdDb3VudCA9IGpzb24uZ2V0U3ViUmlnQ291bnQoKTtcbiAgICBsZXQgaW5wdXRJbmRleCA9IDAsIG91dHB1dEluZGV4ID0gMCwgcGFydGljbGVJbmRleCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9waHlzaWNzUmlnLnN1YlJpZ0NvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IHNldHRpbmcgPSBuZXcgQ3ViaXNtUGh5c2ljc1N1YlJpZygpO1xuICAgICAgc2V0dGluZy5ub3JtYWxpemF0aW9uUG9zaXRpb24ubWluaW11bSA9IGpzb24uZ2V0Tm9ybWFsaXphdGlvblBvc2l0aW9uTWluaW11bVZhbHVlKGkpO1xuICAgICAgc2V0dGluZy5ub3JtYWxpemF0aW9uUG9zaXRpb24ubWF4aW11bSA9IGpzb24uZ2V0Tm9ybWFsaXphdGlvblBvc2l0aW9uTWF4aW11bVZhbHVlKGkpO1xuICAgICAgc2V0dGluZy5ub3JtYWxpemF0aW9uUG9zaXRpb24uZGVmYWx1dCA9IGpzb24uZ2V0Tm9ybWFsaXphdGlvblBvc2l0aW9uRGVmYXVsdFZhbHVlKGkpO1xuICAgICAgc2V0dGluZy5ub3JtYWxpemF0aW9uQW5nbGUubWluaW11bSA9IGpzb24uZ2V0Tm9ybWFsaXphdGlvbkFuZ2xlTWluaW11bVZhbHVlKGkpO1xuICAgICAgc2V0dGluZy5ub3JtYWxpemF0aW9uQW5nbGUubWF4aW11bSA9IGpzb24uZ2V0Tm9ybWFsaXphdGlvbkFuZ2xlTWF4aW11bVZhbHVlKGkpO1xuICAgICAgc2V0dGluZy5ub3JtYWxpemF0aW9uQW5nbGUuZGVmYWx1dCA9IGpzb24uZ2V0Tm9ybWFsaXphdGlvbkFuZ2xlRGVmYXVsdFZhbHVlKGkpO1xuICAgICAgc2V0dGluZy5pbnB1dENvdW50ID0ganNvbi5nZXRJbnB1dENvdW50KGkpO1xuICAgICAgc2V0dGluZy5iYXNlSW5wdXRJbmRleCA9IGlucHV0SW5kZXg7XG4gICAgICBpbnB1dEluZGV4ICs9IHNldHRpbmcuaW5wdXRDb3VudDtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2V0dGluZy5pbnB1dENvdW50OyArK2opIHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBuZXcgQ3ViaXNtUGh5c2ljc0lucHV0KCk7XG4gICAgICAgIGlucHV0LnNvdXJjZVBhcmFtZXRlckluZGV4ID0gLTE7XG4gICAgICAgIGlucHV0LndlaWdodCA9IGpzb24uZ2V0SW5wdXRXZWlnaHQoaSwgaik7XG4gICAgICAgIGlucHV0LnJlZmxlY3QgPSBqc29uLmdldElucHV0UmVmbGVjdChpLCBqKTtcbiAgICAgICAgc3dpdGNoIChqc29uLmdldElucHV0VHlwZShpLCBqKSkge1xuICAgICAgICAgIGNhc2UgUGh5c2ljc1R5cGVUYWdYOlxuICAgICAgICAgICAgaW5wdXQudHlwZSA9IEN1YmlzbVBoeXNpY3NTb3VyY2UuQ3ViaXNtUGh5c2ljc1NvdXJjZV9YO1xuICAgICAgICAgICAgaW5wdXQuZ2V0Tm9ybWFsaXplZFBhcmFtZXRlclZhbHVlID0gZ2V0SW5wdXRUcmFuc2xhdGlvblhGcm9tTm9ybWFsaXplZFBhcmFtZXRlclZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBQaHlzaWNzVHlwZVRhZ1k6XG4gICAgICAgICAgICBpbnB1dC50eXBlID0gQ3ViaXNtUGh5c2ljc1NvdXJjZS5DdWJpc21QaHlzaWNzU291cmNlX1k7XG4gICAgICAgICAgICBpbnB1dC5nZXROb3JtYWxpemVkUGFyYW1ldGVyVmFsdWUgPSBnZXRJbnB1dFRyYW5zbGF0aW9uWUZyb21Ob3JtYWxpemVkUGFyYW10ZXJWYWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgUGh5c2ljc1R5cGVUYWdBbmdsZTpcbiAgICAgICAgICAgIGlucHV0LnR5cGUgPSBDdWJpc21QaHlzaWNzU291cmNlLkN1YmlzbVBoeXNpY3NTb3VyY2VfQW5nbGU7XG4gICAgICAgICAgICBpbnB1dC5nZXROb3JtYWxpemVkUGFyYW1ldGVyVmFsdWUgPSBnZXRJbnB1dEFuZ2xlRnJvbU5vcm1hbGl6ZWRQYXJhbWV0ZXJWYWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0LnNvdXJjZS50YXJnZXRUeXBlID0gQ3ViaXNtUGh5c2ljc1RhcmdldFR5cGUuQ3ViaXNtUGh5c2ljc1RhcmdldFR5cGVfUGFyYW1ldGVyO1xuICAgICAgICBpbnB1dC5zb3VyY2UuaWQgPSBqc29uLmdldElucHV0U291cmNlSWQoaSwgaik7XG4gICAgICAgIHRoaXMuX3BoeXNpY3NSaWcuaW5wdXRzLnB1c2goaW5wdXQpO1xuICAgICAgfVxuICAgICAgc2V0dGluZy5vdXRwdXRDb3VudCA9IGpzb24uZ2V0T3V0cHV0Q291bnQoaSk7XG4gICAgICBzZXR0aW5nLmJhc2VPdXRwdXRJbmRleCA9IG91dHB1dEluZGV4O1xuICAgICAgb3V0cHV0SW5kZXggKz0gc2V0dGluZy5vdXRwdXRDb3VudDtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2V0dGluZy5vdXRwdXRDb3VudDsgKytqKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IG5ldyBDdWJpc21QaHlzaWNzT3V0cHV0KCk7XG4gICAgICAgIG91dHB1dC5kZXN0aW5hdGlvblBhcmFtZXRlckluZGV4ID0gLTE7XG4gICAgICAgIG91dHB1dC52ZXJ0ZXhJbmRleCA9IGpzb24uZ2V0T3V0cHV0VmVydGV4SW5kZXgoaSwgaik7XG4gICAgICAgIG91dHB1dC5hbmdsZVNjYWxlID0ganNvbi5nZXRPdXRwdXRBbmdsZVNjYWxlKGksIGopO1xuICAgICAgICBvdXRwdXQud2VpZ2h0ID0ganNvbi5nZXRPdXRwdXRXZWlnaHQoaSwgaik7XG4gICAgICAgIG91dHB1dC5kZXN0aW5hdGlvbi50YXJnZXRUeXBlID0gQ3ViaXNtUGh5c2ljc1RhcmdldFR5cGUuQ3ViaXNtUGh5c2ljc1RhcmdldFR5cGVfUGFyYW1ldGVyO1xuICAgICAgICBvdXRwdXQuZGVzdGluYXRpb24uaWQgPSBqc29uLmdldE91dHB1dERlc3RpbmF0aW9uSWQoaSwgaik7XG4gICAgICAgIHN3aXRjaCAoanNvbi5nZXRPdXRwdXRUeXBlKGksIGopKSB7XG4gICAgICAgICAgY2FzZSBQaHlzaWNzVHlwZVRhZ1g6XG4gICAgICAgICAgICBvdXRwdXQudHlwZSA9IEN1YmlzbVBoeXNpY3NTb3VyY2UuQ3ViaXNtUGh5c2ljc1NvdXJjZV9YO1xuICAgICAgICAgICAgb3V0cHV0LmdldFZhbHVlID0gZ2V0T3V0cHV0VHJhbnNsYXRpb25YO1xuICAgICAgICAgICAgb3V0cHV0LmdldFNjYWxlID0gZ2V0T3V0cHV0U2NhbGVUcmFuc2xhdGlvblg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFBoeXNpY3NUeXBlVGFnWTpcbiAgICAgICAgICAgIG91dHB1dC50eXBlID0gQ3ViaXNtUGh5c2ljc1NvdXJjZS5DdWJpc21QaHlzaWNzU291cmNlX1k7XG4gICAgICAgICAgICBvdXRwdXQuZ2V0VmFsdWUgPSBnZXRPdXRwdXRUcmFuc2xhdGlvblk7XG4gICAgICAgICAgICBvdXRwdXQuZ2V0U2NhbGUgPSBnZXRPdXRwdXRTY2FsZVRyYW5zbGF0aW9uWTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgUGh5c2ljc1R5cGVUYWdBbmdsZTpcbiAgICAgICAgICAgIG91dHB1dC50eXBlID0gQ3ViaXNtUGh5c2ljc1NvdXJjZS5DdWJpc21QaHlzaWNzU291cmNlX0FuZ2xlO1xuICAgICAgICAgICAgb3V0cHV0LmdldFZhbHVlID0gZ2V0T3V0cHV0QW5nbGU7XG4gICAgICAgICAgICBvdXRwdXQuZ2V0U2NhbGUgPSBnZXRPdXRwdXRTY2FsZUFuZ2xlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnJlZmxlY3QgPSBqc29uLmdldE91dHB1dFJlZmxlY3QoaSwgaik7XG4gICAgICAgIHRoaXMuX3BoeXNpY3NSaWcub3V0cHV0cy5wdXNoKG91dHB1dCk7XG4gICAgICB9XG4gICAgICBzZXR0aW5nLnBhcnRpY2xlQ291bnQgPSBqc29uLmdldFBhcnRpY2xlQ291bnQoaSk7XG4gICAgICBzZXR0aW5nLmJhc2VQYXJ0aWNsZUluZGV4ID0gcGFydGljbGVJbmRleDtcbiAgICAgIHBhcnRpY2xlSW5kZXggKz0gc2V0dGluZy5wYXJ0aWNsZUNvdW50O1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzZXR0aW5nLnBhcnRpY2xlQ291bnQ7ICsraikge1xuICAgICAgICBjb25zdCBwYXJ0aWNsZSA9IG5ldyBDdWJpc21QaHlzaWNzUGFydGljbGUoKTtcbiAgICAgICAgcGFydGljbGUubW9iaWxpdHkgPSBqc29uLmdldFBhcnRpY2xlTW9iaWxpdHkoaSwgaik7XG4gICAgICAgIHBhcnRpY2xlLmRlbGF5ID0ganNvbi5nZXRQYXJ0aWNsZURlbGF5KGksIGopO1xuICAgICAgICBwYXJ0aWNsZS5hY2NlbGVyYXRpb24gPSBqc29uLmdldFBhcnRpY2xlQWNjZWxlcmF0aW9uKGksIGopO1xuICAgICAgICBwYXJ0aWNsZS5yYWRpdXMgPSBqc29uLmdldFBhcnRpY2xlUmFkaXVzKGksIGopO1xuICAgICAgICBwYXJ0aWNsZS5wb3NpdGlvbiA9IGpzb24uZ2V0UGFydGljbGVQb3NpdGlvbihpLCBqKTtcbiAgICAgICAgdGhpcy5fcGh5c2ljc1JpZy5wYXJ0aWNsZXMucHVzaChwYXJ0aWNsZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9waHlzaWNzUmlnLnNldHRpbmdzLnB1c2goc2V0dGluZyk7XG4gICAgfVxuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIGpzb24ucmVsZWFzZSgpO1xuICB9XG4gIGluaXRpYWxpemUoKSB7XG4gICAgbGV0IHN0cmFuZDtcbiAgICBsZXQgY3VycmVudFNldHRpbmc7XG4gICAgbGV0IHJhZGl1cztcbiAgICBmb3IgKGxldCBzZXR0aW5nSW5kZXggPSAwOyBzZXR0aW5nSW5kZXggPCB0aGlzLl9waHlzaWNzUmlnLnN1YlJpZ0NvdW50OyArK3NldHRpbmdJbmRleCkge1xuICAgICAgY3VycmVudFNldHRpbmcgPSB0aGlzLl9waHlzaWNzUmlnLnNldHRpbmdzW3NldHRpbmdJbmRleF07XG4gICAgICBzdHJhbmQgPSB0aGlzLl9waHlzaWNzUmlnLnBhcnRpY2xlcy5zbGljZShjdXJyZW50U2V0dGluZy5iYXNlUGFydGljbGVJbmRleCk7XG4gICAgICBzdHJhbmRbMF0uaW5pdGlhbFBvc2l0aW9uID0gbmV3IEN1YmlzbVZlY3RvcjIoMCwgMCk7XG4gICAgICBzdHJhbmRbMF0ubGFzdFBvc2l0aW9uID0gbmV3IEN1YmlzbVZlY3RvcjIoc3RyYW5kWzBdLmluaXRpYWxQb3NpdGlvbi54LCBzdHJhbmRbMF0uaW5pdGlhbFBvc2l0aW9uLnkpO1xuICAgICAgc3RyYW5kWzBdLmxhc3RHcmF2aXR5ID0gbmV3IEN1YmlzbVZlY3RvcjIoMCwgLTEpO1xuICAgICAgc3RyYW5kWzBdLmxhc3RHcmF2aXR5LnkgKj0gLTE7XG4gICAgICBzdHJhbmRbMF0udmVsb2NpdHkgPSBuZXcgQ3ViaXNtVmVjdG9yMigwLCAwKTtcbiAgICAgIHN0cmFuZFswXS5mb3JjZSA9IG5ldyBDdWJpc21WZWN0b3IyKDAsIDApO1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjdXJyZW50U2V0dGluZy5wYXJ0aWNsZUNvdW50OyArK2kpIHtcbiAgICAgICAgcmFkaXVzID0gbmV3IEN1YmlzbVZlY3RvcjIoMCwgMCk7XG4gICAgICAgIHJhZGl1cy55ID0gc3RyYW5kW2ldLnJhZGl1cztcbiAgICAgICAgc3RyYW5kW2ldLmluaXRpYWxQb3NpdGlvbiA9IG5ldyBDdWJpc21WZWN0b3IyKHN0cmFuZFtpIC0gMV0uaW5pdGlhbFBvc2l0aW9uLnggKyByYWRpdXMueCwgc3RyYW5kW2kgLSAxXS5pbml0aWFsUG9zaXRpb24ueSArIHJhZGl1cy55KTtcbiAgICAgICAgc3RyYW5kW2ldLnBvc2l0aW9uID0gbmV3IEN1YmlzbVZlY3RvcjIoc3RyYW5kW2ldLmluaXRpYWxQb3NpdGlvbi54LCBzdHJhbmRbaV0uaW5pdGlhbFBvc2l0aW9uLnkpO1xuICAgICAgICBzdHJhbmRbaV0ubGFzdFBvc2l0aW9uID0gbmV3IEN1YmlzbVZlY3RvcjIoc3RyYW5kW2ldLmluaXRpYWxQb3NpdGlvbi54LCBzdHJhbmRbaV0uaW5pdGlhbFBvc2l0aW9uLnkpO1xuICAgICAgICBzdHJhbmRbaV0ubGFzdEdyYXZpdHkgPSBuZXcgQ3ViaXNtVmVjdG9yMigwLCAtMSk7XG4gICAgICAgIHN0cmFuZFtpXS5sYXN0R3Jhdml0eS55ICo9IC0xO1xuICAgICAgICBzdHJhbmRbaV0udmVsb2NpdHkgPSBuZXcgQ3ViaXNtVmVjdG9yMigwLCAwKTtcbiAgICAgICAgc3RyYW5kW2ldLmZvcmNlID0gbmV3IEN1YmlzbVZlY3RvcjIoMCwgMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jbGFzcyBPcHRpb25zIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5ncmF2aXR5ID0gbmV3IEN1YmlzbVZlY3RvcjIoMCwgMCk7XG4gICAgdGhpcy53aW5kID0gbmV3IEN1YmlzbVZlY3RvcjIoMCwgMCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldElucHV0VHJhbnNsYXRpb25YRnJvbU5vcm1hbGl6ZWRQYXJhbWV0ZXJWYWx1ZSh0YXJnZXRUcmFuc2xhdGlvbiwgdGFyZ2V0QW5nbGUsIHZhbHVlLCBwYXJhbWV0ZXJNaW5pbXVtVmFsdWUsIHBhcmFtZXRlck1heGltdW1WYWx1ZSwgcGFyYW1ldGVyRGVmYXVsdFZhbHVlLCBub3JtYWxpemF0aW9uUG9zaXRpb24sIG5vcm1hbGl6YXRpb25BbmdsZSwgaXNJbnZlcnRlZCwgd2VpZ2h0KSB7XG4gIHRhcmdldFRyYW5zbGF0aW9uLnggKz0gbm9ybWFsaXplUGFyYW1ldGVyVmFsdWUodmFsdWUsIHBhcmFtZXRlck1pbmltdW1WYWx1ZSwgcGFyYW1ldGVyTWF4aW11bVZhbHVlLCBwYXJhbWV0ZXJEZWZhdWx0VmFsdWUsIG5vcm1hbGl6YXRpb25Qb3NpdGlvbi5taW5pbXVtLCBub3JtYWxpemF0aW9uUG9zaXRpb24ubWF4aW11bSwgbm9ybWFsaXphdGlvblBvc2l0aW9uLmRlZmFsdXQsIGlzSW52ZXJ0ZWQpICogd2VpZ2h0O1xufVxuZnVuY3Rpb24gZ2V0SW5wdXRUcmFuc2xhdGlvbllGcm9tTm9ybWFsaXplZFBhcmFtdGVyVmFsdWUodGFyZ2V0VHJhbnNsYXRpb24sIHRhcmdldEFuZ2xlLCB2YWx1ZSwgcGFyYW1ldGVyTWluaW11bVZhbHVlLCBwYXJhbWV0ZXJNYXhpbXVtVmFsdWUsIHBhcmFtZXRlckRlZmF1bHRWYWx1ZSwgbm9ybWFsaXphdGlvblBvc2l0aW9uLCBub3JtYWxpemF0aW9uQW5nbGUsIGlzSW52ZXJ0ZWQsIHdlaWdodCkge1xuICB0YXJnZXRUcmFuc2xhdGlvbi55ICs9IG5vcm1hbGl6ZVBhcmFtZXRlclZhbHVlKHZhbHVlLCBwYXJhbWV0ZXJNaW5pbXVtVmFsdWUsIHBhcmFtZXRlck1heGltdW1WYWx1ZSwgcGFyYW1ldGVyRGVmYXVsdFZhbHVlLCBub3JtYWxpemF0aW9uUG9zaXRpb24ubWluaW11bSwgbm9ybWFsaXphdGlvblBvc2l0aW9uLm1heGltdW0sIG5vcm1hbGl6YXRpb25Qb3NpdGlvbi5kZWZhbHV0LCBpc0ludmVydGVkKSAqIHdlaWdodDtcbn1cbmZ1bmN0aW9uIGdldElucHV0QW5nbGVGcm9tTm9ybWFsaXplZFBhcmFtZXRlclZhbHVlKHRhcmdldFRyYW5zbGF0aW9uLCB0YXJnZXRBbmdsZSwgdmFsdWUsIHBhcmFtZXRlck1pbmltdW1WYWx1ZSwgcGFyYW1ldGVyTWF4aW11bVZhbHVlLCBwYXJhbWV0ZXJEZWZhdWx0VmFsdWUsIG5vcm1hbGl6YWl0aW9uUG9zaXRpb24sIG5vcm1hbGl6YXRpb25BbmdsZSwgaXNJbnZlcnRlZCwgd2VpZ2h0KSB7XG4gIHRhcmdldEFuZ2xlLmFuZ2xlICs9IG5vcm1hbGl6ZVBhcmFtZXRlclZhbHVlKHZhbHVlLCBwYXJhbWV0ZXJNaW5pbXVtVmFsdWUsIHBhcmFtZXRlck1heGltdW1WYWx1ZSwgcGFyYW1ldGVyRGVmYXVsdFZhbHVlLCBub3JtYWxpemF0aW9uQW5nbGUubWluaW11bSwgbm9ybWFsaXphdGlvbkFuZ2xlLm1heGltdW0sIG5vcm1hbGl6YXRpb25BbmdsZS5kZWZhbHV0LCBpc0ludmVydGVkKSAqIHdlaWdodDtcbn1cbmZ1bmN0aW9uIGdldE91dHB1dFRyYW5zbGF0aW9uWCh0cmFuc2xhdGlvbiwgcGFydGljbGVzLCBwYXJ0aWNsZUluZGV4LCBpc0ludmVydGVkLCBwYXJlbnRHcmF2aXR5KSB7XG4gIGxldCBvdXRwdXRWYWx1ZSA9IHRyYW5zbGF0aW9uLng7XG4gIGlmIChpc0ludmVydGVkKSB7XG4gICAgb3V0cHV0VmFsdWUgKj0gLTE7XG4gIH1cbiAgcmV0dXJuIG91dHB1dFZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0T3V0cHV0VHJhbnNsYXRpb25ZKHRyYW5zbGF0aW9uLCBwYXJ0aWNsZXMsIHBhcnRpY2xlSW5kZXgsIGlzSW52ZXJ0ZWQsIHBhcmVudEdyYXZpdHkpIHtcbiAgbGV0IG91dHB1dFZhbHVlID0gdHJhbnNsYXRpb24ueTtcbiAgaWYgKGlzSW52ZXJ0ZWQpIHtcbiAgICBvdXRwdXRWYWx1ZSAqPSAtMTtcbiAgfVxuICByZXR1cm4gb3V0cHV0VmFsdWU7XG59XG5mdW5jdGlvbiBnZXRPdXRwdXRBbmdsZSh0cmFuc2xhdGlvbiwgcGFydGljbGVzLCBwYXJ0aWNsZUluZGV4LCBpc0ludmVydGVkLCBwYXJlbnRHcmF2aXR5KSB7XG4gIGxldCBvdXRwdXRWYWx1ZTtcbiAgaWYgKHBhcnRpY2xlSW5kZXggPj0gMikge1xuICAgIHBhcmVudEdyYXZpdHkgPSBwYXJ0aWNsZXNbcGFydGljbGVJbmRleCAtIDFdLnBvc2l0aW9uLnN1YnN0cmFjdChwYXJ0aWNsZXNbcGFydGljbGVJbmRleCAtIDJdLnBvc2l0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnRHcmF2aXR5ID0gcGFyZW50R3Jhdml0eS5tdWx0aXBseUJ5U2NhbGVyKC0xKTtcbiAgfVxuICBvdXRwdXRWYWx1ZSA9IEN1YmlzbU1hdGguZGlyZWN0aW9uVG9SYWRpYW4ocGFyZW50R3Jhdml0eSwgdHJhbnNsYXRpb24pO1xuICBpZiAoaXNJbnZlcnRlZCkge1xuICAgIG91dHB1dFZhbHVlICo9IC0xO1xuICB9XG4gIHJldHVybiBvdXRwdXRWYWx1ZTtcbn1cbmZ1bmN0aW9uIGdldFJhbmdlVmFsdWUobWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGguYWJzKE1hdGgubWF4KG1pbiwgbWF4KSAtIE1hdGgubWluKG1pbiwgbWF4KSk7XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0VmFsdWUobWluLCBtYXgpIHtcbiAgY29uc3QgbWluVmFsdWUgPSBNYXRoLm1pbihtaW4sIG1heCk7XG4gIHJldHVybiBtaW5WYWx1ZSArIGdldFJhbmdlVmFsdWUobWluLCBtYXgpIC8gMjtcbn1cbmZ1bmN0aW9uIGdldE91dHB1dFNjYWxlVHJhbnNsYXRpb25YKHRyYW5zbGF0aW9uU2NhbGUsIGFuZ2xlU2NhbGUpIHtcbiAgcmV0dXJuIHRyYW5zbGF0aW9uU2NhbGUueDtcbn1cbmZ1bmN0aW9uIGdldE91dHB1dFNjYWxlVHJhbnNsYXRpb25ZKHRyYW5zbGF0aW9uU2NhbGUsIGFuZ2xlU2NhbGUpIHtcbiAgcmV0dXJuIHRyYW5zbGF0aW9uU2NhbGUueTtcbn1cbmZ1bmN0aW9uIGdldE91dHB1dFNjYWxlQW5nbGUodHJhbnNsYXRpb25TY2FsZSwgYW5nbGVTY2FsZSkge1xuICByZXR1cm4gYW5nbGVTY2FsZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVBhcnRpY2xlcyhzdHJhbmQsIHN0cmFuZENvdW50LCB0b3RhbFRyYW5zbGF0aW9uLCB0b3RhbEFuZ2xlLCB3aW5kRGlyZWN0aW9uLCB0aHJlc2hvbGRWYWx1ZSwgZGVsdGFUaW1lU2Vjb25kcywgYWlyUmVzaXN0YW5jZSkge1xuICBsZXQgdG90YWxSYWRpYW47XG4gIGxldCBkZWxheTtcbiAgbGV0IHJhZGlhbjtcbiAgbGV0IGN1cnJlbnRHcmF2aXR5O1xuICBsZXQgZGlyZWN0aW9uID0gbmV3IEN1YmlzbVZlY3RvcjIoMCwgMCk7XG4gIGxldCB2ZWxvY2l0eSA9IG5ldyBDdWJpc21WZWN0b3IyKDAsIDApO1xuICBsZXQgZm9yY2UgPSBuZXcgQ3ViaXNtVmVjdG9yMigwLCAwKTtcbiAgbGV0IG5ld0RpcmVjdGlvbiA9IG5ldyBDdWJpc21WZWN0b3IyKDAsIDApO1xuICBzdHJhbmRbMF0ucG9zaXRpb24gPSBuZXcgQ3ViaXNtVmVjdG9yMih0b3RhbFRyYW5zbGF0aW9uLngsIHRvdGFsVHJhbnNsYXRpb24ueSk7XG4gIHRvdGFsUmFkaWFuID0gQ3ViaXNtTWF0aC5kZWdyZWVzVG9SYWRpYW4odG90YWxBbmdsZSk7XG4gIGN1cnJlbnRHcmF2aXR5ID0gQ3ViaXNtTWF0aC5yYWRpYW5Ub0RpcmVjdGlvbih0b3RhbFJhZGlhbik7XG4gIGN1cnJlbnRHcmF2aXR5Lm5vcm1hbGl6ZSgpO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IHN0cmFuZENvdW50OyArK2kpIHtcbiAgICBzdHJhbmRbaV0uZm9yY2UgPSBjdXJyZW50R3Jhdml0eS5tdWx0aXBseUJ5U2NhbGVyKHN0cmFuZFtpXS5hY2NlbGVyYXRpb24pLmFkZCh3aW5kRGlyZWN0aW9uKTtcbiAgICBzdHJhbmRbaV0ubGFzdFBvc2l0aW9uID0gbmV3IEN1YmlzbVZlY3RvcjIoc3RyYW5kW2ldLnBvc2l0aW9uLngsIHN0cmFuZFtpXS5wb3NpdGlvbi55KTtcbiAgICBkZWxheSA9IHN0cmFuZFtpXS5kZWxheSAqIGRlbHRhVGltZVNlY29uZHMgKiAzMDtcbiAgICBkaXJlY3Rpb24gPSBzdHJhbmRbaV0ucG9zaXRpb24uc3Vic3RyYWN0KHN0cmFuZFtpIC0gMV0ucG9zaXRpb24pO1xuICAgIHJhZGlhbiA9IEN1YmlzbU1hdGguZGlyZWN0aW9uVG9SYWRpYW4oc3RyYW5kW2ldLmxhc3RHcmF2aXR5LCBjdXJyZW50R3Jhdml0eSkgLyBhaXJSZXNpc3RhbmNlO1xuICAgIGRpcmVjdGlvbi54ID0gQ3ViaXNtTWF0aC5jb3MocmFkaWFuKSAqIGRpcmVjdGlvbi54IC0gZGlyZWN0aW9uLnkgKiBDdWJpc21NYXRoLnNpbihyYWRpYW4pO1xuICAgIGRpcmVjdGlvbi55ID0gQ3ViaXNtTWF0aC5zaW4ocmFkaWFuKSAqIGRpcmVjdGlvbi54ICsgZGlyZWN0aW9uLnkgKiBDdWJpc21NYXRoLmNvcyhyYWRpYW4pO1xuICAgIHN0cmFuZFtpXS5wb3NpdGlvbiA9IHN0cmFuZFtpIC0gMV0ucG9zaXRpb24uYWRkKGRpcmVjdGlvbik7XG4gICAgdmVsb2NpdHkgPSBzdHJhbmRbaV0udmVsb2NpdHkubXVsdGlwbHlCeVNjYWxlcihkZWxheSk7XG4gICAgZm9yY2UgPSBzdHJhbmRbaV0uZm9yY2UubXVsdGlwbHlCeVNjYWxlcihkZWxheSkubXVsdGlwbHlCeVNjYWxlcihkZWxheSk7XG4gICAgc3RyYW5kW2ldLnBvc2l0aW9uID0gc3RyYW5kW2ldLnBvc2l0aW9uLmFkZCh2ZWxvY2l0eSkuYWRkKGZvcmNlKTtcbiAgICBuZXdEaXJlY3Rpb24gPSBzdHJhbmRbaV0ucG9zaXRpb24uc3Vic3RyYWN0KHN0cmFuZFtpIC0gMV0ucG9zaXRpb24pO1xuICAgIG5ld0RpcmVjdGlvbi5ub3JtYWxpemUoKTtcbiAgICBzdHJhbmRbaV0ucG9zaXRpb24gPSBzdHJhbmRbaSAtIDFdLnBvc2l0aW9uLmFkZChuZXdEaXJlY3Rpb24ubXVsdGlwbHlCeVNjYWxlcihzdHJhbmRbaV0ucmFkaXVzKSk7XG4gICAgaWYgKEN1YmlzbU1hdGguYWJzKHN0cmFuZFtpXS5wb3NpdGlvbi54KSA8IHRocmVzaG9sZFZhbHVlKSB7XG4gICAgICBzdHJhbmRbaV0ucG9zaXRpb24ueCA9IDA7XG4gICAgfVxuICAgIGlmIChkZWxheSAhPSAwKSB7XG4gICAgICBzdHJhbmRbaV0udmVsb2NpdHkgPSBzdHJhbmRbaV0ucG9zaXRpb24uc3Vic3RyYWN0KHN0cmFuZFtpXS5sYXN0UG9zaXRpb24pO1xuICAgICAgc3RyYW5kW2ldLnZlbG9jaXR5ID0gc3RyYW5kW2ldLnZlbG9jaXR5LmRpdmlzaW9uQnlTY2FsYXIoZGVsYXkpO1xuICAgICAgc3RyYW5kW2ldLnZlbG9jaXR5ID0gc3RyYW5kW2ldLnZlbG9jaXR5Lm11bHRpcGx5QnlTY2FsZXIoc3RyYW5kW2ldLm1vYmlsaXR5KTtcbiAgICB9XG4gICAgc3RyYW5kW2ldLmZvcmNlID0gbmV3IEN1YmlzbVZlY3RvcjIoMCwgMCk7XG4gICAgc3RyYW5kW2ldLmxhc3RHcmF2aXR5ID0gbmV3IEN1YmlzbVZlY3RvcjIoY3VycmVudEdyYXZpdHkueCwgY3VycmVudEdyYXZpdHkueSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZU91dHB1dFBhcmFtZXRlclZhbHVlKHBhcmFtZXRlclZhbHVlLCBwYXJhbWV0ZXJWYWx1ZU1pbmltdW0sIHBhcmFtZXRlclZhbHVlTWF4aW11bSwgdHJhbnNsYXRpb24sIG91dHB1dCkge1xuICBsZXQgb3V0cHV0U2NhbGU7XG4gIGxldCB2YWx1ZTtcbiAgbGV0IHdlaWdodDtcbiAgb3V0cHV0U2NhbGUgPSBvdXRwdXQuZ2V0U2NhbGUob3V0cHV0LnRyYW5zbGF0aW9uU2NhbGUsIG91dHB1dC5hbmdsZVNjYWxlKTtcbiAgdmFsdWUgPSB0cmFuc2xhdGlvbiAqIG91dHB1dFNjYWxlO1xuICBpZiAodmFsdWUgPCBwYXJhbWV0ZXJWYWx1ZU1pbmltdW0pIHtcbiAgICBpZiAodmFsdWUgPCBvdXRwdXQudmFsdWVCZWxvd01pbmltdW0pIHtcbiAgICAgIG91dHB1dC52YWx1ZUJlbG93TWluaW11bSA9IHZhbHVlO1xuICAgIH1cbiAgICB2YWx1ZSA9IHBhcmFtZXRlclZhbHVlTWluaW11bTtcbiAgfSBlbHNlIGlmICh2YWx1ZSA+IHBhcmFtZXRlclZhbHVlTWF4aW11bSkge1xuICAgIGlmICh2YWx1ZSA+IG91dHB1dC52YWx1ZUV4Y2VlZGVkTWF4aW11bSkge1xuICAgICAgb3V0cHV0LnZhbHVlRXhjZWVkZWRNYXhpbXVtID0gdmFsdWU7XG4gICAgfVxuICAgIHZhbHVlID0gcGFyYW1ldGVyVmFsdWVNYXhpbXVtO1xuICB9XG4gIHdlaWdodCA9IG91dHB1dC53ZWlnaHQgLyBNYXhpbXVtV2VpZ2h0O1xuICBpZiAod2VpZ2h0ID49IDEpIHtcbiAgICBwYXJhbWV0ZXJWYWx1ZVswXSA9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gcGFyYW1ldGVyVmFsdWVbMF0gKiAoMSAtIHdlaWdodCkgKyB2YWx1ZSAqIHdlaWdodDtcbiAgICBwYXJhbWV0ZXJWYWx1ZVswXSA9IHZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVQYXJhbWV0ZXJWYWx1ZSh2YWx1ZSwgcGFyYW1ldGVyTWluaW11bSwgcGFyYW1ldGVyTWF4aW11bSwgcGFyYW1ldGVyRGVmYXVsdCwgbm9ybWFsaXplZE1pbmltdW0sIG5vcm1hbGl6ZWRNYXhpbXVtLCBub3JtYWxpemVkRGVmYXVsdCwgaXNJbnZlcnRlZCkge1xuICBsZXQgcmVzdWx0ID0gMDtcbiAgY29uc3QgbWF4VmFsdWUgPSBDdWJpc21NYXRoLm1heChwYXJhbWV0ZXJNYXhpbXVtLCBwYXJhbWV0ZXJNaW5pbXVtKTtcbiAgaWYgKG1heFZhbHVlIDwgdmFsdWUpIHtcbiAgICB2YWx1ZSA9IG1heFZhbHVlO1xuICB9XG4gIGNvbnN0IG1pblZhbHVlID0gQ3ViaXNtTWF0aC5taW4ocGFyYW1ldGVyTWF4aW11bSwgcGFyYW1ldGVyTWluaW11bSk7XG4gIGlmIChtaW5WYWx1ZSA+IHZhbHVlKSB7XG4gICAgdmFsdWUgPSBtaW5WYWx1ZTtcbiAgfVxuICBjb25zdCBtaW5Ob3JtVmFsdWUgPSBDdWJpc21NYXRoLm1pbihub3JtYWxpemVkTWluaW11bSwgbm9ybWFsaXplZE1heGltdW0pO1xuICBjb25zdCBtYXhOb3JtVmFsdWUgPSBDdWJpc21NYXRoLm1heChub3JtYWxpemVkTWluaW11bSwgbm9ybWFsaXplZE1heGltdW0pO1xuICBjb25zdCBtaWRkbGVOb3JtVmFsdWUgPSBub3JtYWxpemVkRGVmYXVsdDtcbiAgY29uc3QgbWlkZGxlVmFsdWUgPSBnZXREZWZhdWx0VmFsdWUobWluVmFsdWUsIG1heFZhbHVlKTtcbiAgY29uc3QgcGFyYW1WYWx1ZSA9IHZhbHVlIC0gbWlkZGxlVmFsdWU7XG4gIHN3aXRjaCAoTWF0aC5zaWduKHBhcmFtVmFsdWUpKSB7XG4gICAgY2FzZSAxOiB7XG4gICAgICBjb25zdCBuTGVuZ3RoID0gbWF4Tm9ybVZhbHVlIC0gbWlkZGxlTm9ybVZhbHVlO1xuICAgICAgY29uc3QgcExlbmd0aCA9IG1heFZhbHVlIC0gbWlkZGxlVmFsdWU7XG4gICAgICBpZiAocExlbmd0aCAhPSAwKSB7XG4gICAgICAgIHJlc3VsdCA9IHBhcmFtVmFsdWUgKiAobkxlbmd0aCAvIHBMZW5ndGgpO1xuICAgICAgICByZXN1bHQgKz0gbWlkZGxlTm9ybVZhbHVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgLTE6IHtcbiAgICAgIGNvbnN0IG5MZW5ndGggPSBtaW5Ob3JtVmFsdWUgLSBtaWRkbGVOb3JtVmFsdWU7XG4gICAgICBjb25zdCBwTGVuZ3RoID0gbWluVmFsdWUgLSBtaWRkbGVWYWx1ZTtcbiAgICAgIGlmIChwTGVuZ3RoICE9IDApIHtcbiAgICAgICAgcmVzdWx0ID0gcGFyYW1WYWx1ZSAqIChuTGVuZ3RoIC8gcExlbmd0aCk7XG4gICAgICAgIHJlc3VsdCArPSBtaWRkbGVOb3JtVmFsdWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSAwOiB7XG4gICAgICByZXN1bHQgPSBtaWRkbGVOb3JtVmFsdWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlzSW52ZXJ0ZWQgPyByZXN1bHQgOiByZXN1bHQgKiAtMTtcbn1cbmNsYXNzIGNzbVJlY3Qge1xuICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHcgPSAwLCBoID0gMCkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLndpZHRoID0gdztcbiAgICB0aGlzLmhlaWdodCA9IGg7XG4gIH1cbiAgZ2V0Q2VudGVyWCgpIHtcbiAgICByZXR1cm4gdGhpcy54ICsgMC41ICogdGhpcy53aWR0aDtcbiAgfVxuICBnZXRDZW50ZXJZKCkge1xuICAgIHJldHVybiB0aGlzLnkgKyAwLjUgKiB0aGlzLmhlaWdodDtcbiAgfVxuICBnZXRSaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy54ICsgdGhpcy53aWR0aDtcbiAgfVxuICBnZXRCb3R0b20oKSB7XG4gICAgcmV0dXJuIHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuICB9XG4gIHNldFJlY3Qocikge1xuICAgIHRoaXMueCA9IHIueDtcbiAgICB0aGlzLnkgPSByLnk7XG4gICAgdGhpcy53aWR0aCA9IHIud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSByLmhlaWdodDtcbiAgfVxuICBleHBhbmQodywgaCkge1xuICAgIHRoaXMueCAtPSB3O1xuICAgIHRoaXMueSAtPSBoO1xuICAgIHRoaXMud2lkdGggKz0gdyAqIDI7XG4gICAgdGhpcy5oZWlnaHQgKz0gaCAqIDI7XG4gIH1cbn1cbmNvbnN0IENvbG9yQ2hhbm5lbENvdW50ID0gNDtcbmNvbnN0IHNoYWRlckNvdW50ID0gMTA7XG5sZXQgc19pbnN0YW5jZTtcbmxldCBzX3ZpZXdwb3J0O1xubGV0IHNfZmJvO1xuY2xhc3MgQ3ViaXNtQ2xpcHBpbmdNYW5hZ2VyX1dlYkdMIHtcbiAgZ2V0Q2hhbm5lbEZsYWdBc0NvbG9yKGNoYW5uZWxObykge1xuICAgIHJldHVybiB0aGlzLl9jaGFubmVsQ29sb3JzW2NoYW5uZWxOb107XG4gIH1cbiAgZ2V0TWFza1JlbmRlclRleHR1cmUoKSB7XG4gICAgbGV0IHJldCA9IDA7XG4gICAgaWYgKHRoaXMuX21hc2tUZXh0dXJlICYmIHRoaXMuX21hc2tUZXh0dXJlLnRleHR1cmUgIT0gMCkge1xuICAgICAgdGhpcy5fbWFza1RleHR1cmUuZnJhbWVObyA9IHRoaXMuX2N1cnJlbnRGcmFtZU5vO1xuICAgICAgcmV0ID0gdGhpcy5fbWFza1RleHR1cmUudGV4dHVyZTtcbiAgICB9XG4gICAgaWYgKHJldCA9PSAwKSB7XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5fY2xpcHBpbmdNYXNrQnVmZmVyU2l6ZTtcbiAgICAgIHRoaXMuX2NvbG9yQnVmZmVyID0gdGhpcy5nbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICB0aGlzLmdsLmJpbmRUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5fY29sb3JCdWZmZXIpO1xuICAgICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMuZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5nbC5SR0JBLCBzaXplLCBzaXplLCAwLCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG4gICAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLmdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX1dSQVBfVCwgdGhpcy5nbC5DTEFNUF9UT19FREdFKTtcbiAgICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLmdsLkxJTkVBUik7XG4gICAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGhpcy5nbC5MSU5FQVIpO1xuICAgICAgdGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkVfMkQsIG51bGwpO1xuICAgICAgcmV0ID0gdGhpcy5nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgdGhpcy5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5nbC5GUkFNRUJVRkZFUiwgcmV0KTtcbiAgICAgIHRoaXMuZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQodGhpcy5nbC5GUkFNRUJVRkZFUiwgdGhpcy5nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgdGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLl9jb2xvckJ1ZmZlciwgMCk7XG4gICAgICB0aGlzLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLmdsLkZSQU1FQlVGRkVSLCBzX2Zibyk7XG4gICAgICB0aGlzLl9tYXNrVGV4dHVyZSA9IG5ldyBDdWJpc21SZW5kZXJUZXh0dXJlUmVzb3VyY2UodGhpcy5fY3VycmVudEZyYW1lTm8sIHJldCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgc2V0R0woZ2wpIHtcbiAgICB0aGlzLmdsID0gZ2w7XG4gIH1cbiAgY2FsY0NsaXBwZWREcmF3VG90YWxCb3VuZHMobW9kZWwsIGNsaXBwaW5nQ29udGV4dCkge1xuICAgIGxldCBjbGlwcGVkRHJhd1RvdGFsTWluWCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgbGV0IGNsaXBwZWREcmF3VG90YWxNaW5ZID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICBsZXQgY2xpcHBlZERyYXdUb3RhbE1heFggPSBOdW1iZXIuTUlOX1ZBTFVFO1xuICAgIGxldCBjbGlwcGVkRHJhd1RvdGFsTWF4WSA9IE51bWJlci5NSU5fVkFMVUU7XG4gICAgY29uc3QgY2xpcHBlZERyYXdDb3VudCA9IGNsaXBwaW5nQ29udGV4dC5fY2xpcHBlZERyYXdhYmxlSW5kZXhMaXN0Lmxlbmd0aDtcbiAgICBmb3IgKGxldCBjbGlwcGVkRHJhd2FibGVJbmRleCA9IDA7IGNsaXBwZWREcmF3YWJsZUluZGV4IDwgY2xpcHBlZERyYXdDb3VudDsgY2xpcHBlZERyYXdhYmxlSW5kZXgrKykge1xuICAgICAgY29uc3QgZHJhd2FibGVJbmRleCA9IGNsaXBwaW5nQ29udGV4dC5fY2xpcHBlZERyYXdhYmxlSW5kZXhMaXN0W2NsaXBwZWREcmF3YWJsZUluZGV4XTtcbiAgICAgIGNvbnN0IGRyYXdhYmxlVmVydGV4Q291bnQgPSBtb2RlbC5nZXREcmF3YWJsZVZlcnRleENvdW50KGRyYXdhYmxlSW5kZXgpO1xuICAgICAgY29uc3QgZHJhd2FibGVWZXJ0ZXhlcyA9IG1vZGVsLmdldERyYXdhYmxlVmVydGljZXMoZHJhd2FibGVJbmRleCk7XG4gICAgICBsZXQgbWluWCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICBsZXQgbWluWSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICBsZXQgbWF4WCA9IE51bWJlci5NSU5fVkFMVUU7XG4gICAgICBsZXQgbWF4WSA9IE51bWJlci5NSU5fVkFMVUU7XG4gICAgICBjb25zdCBsb29wID0gZHJhd2FibGVWZXJ0ZXhDb3VudCAqIENvbnN0YW50LnZlcnRleFN0ZXA7XG4gICAgICBmb3IgKGxldCBwaSA9IENvbnN0YW50LnZlcnRleE9mZnNldDsgcGkgPCBsb29wOyBwaSArPSBDb25zdGFudC52ZXJ0ZXhTdGVwKSB7XG4gICAgICAgIGNvbnN0IHggPSBkcmF3YWJsZVZlcnRleGVzW3BpXTtcbiAgICAgICAgY29uc3QgeSA9IGRyYXdhYmxlVmVydGV4ZXNbcGkgKyAxXTtcbiAgICAgICAgaWYgKHggPCBtaW5YKSB7XG4gICAgICAgICAgbWluWCA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggPiBtYXhYKSB7XG4gICAgICAgICAgbWF4WCA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgPCBtaW5ZKSB7XG4gICAgICAgICAgbWluWSA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgPiBtYXhZKSB7XG4gICAgICAgICAgbWF4WSA9IHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtaW5YID09IE51bWJlci5NQVhfVkFMVUUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobWluWCA8IGNsaXBwZWREcmF3VG90YWxNaW5YKSB7XG4gICAgICAgIGNsaXBwZWREcmF3VG90YWxNaW5YID0gbWluWDtcbiAgICAgIH1cbiAgICAgIGlmIChtaW5ZIDwgY2xpcHBlZERyYXdUb3RhbE1pblkpIHtcbiAgICAgICAgY2xpcHBlZERyYXdUb3RhbE1pblkgPSBtaW5ZO1xuICAgICAgfVxuICAgICAgaWYgKG1heFggPiBjbGlwcGVkRHJhd1RvdGFsTWF4WCkge1xuICAgICAgICBjbGlwcGVkRHJhd1RvdGFsTWF4WCA9IG1heFg7XG4gICAgICB9XG4gICAgICBpZiAobWF4WSA+IGNsaXBwZWREcmF3VG90YWxNYXhZKSB7XG4gICAgICAgIGNsaXBwZWREcmF3VG90YWxNYXhZID0gbWF4WTtcbiAgICAgIH1cbiAgICAgIGlmIChjbGlwcGVkRHJhd1RvdGFsTWluWCA9PSBOdW1iZXIuTUFYX1ZBTFVFKSB7XG4gICAgICAgIGNsaXBwaW5nQ29udGV4dC5fYWxsQ2xpcHBlZERyYXdSZWN0LnggPSAwO1xuICAgICAgICBjbGlwcGluZ0NvbnRleHQuX2FsbENsaXBwZWREcmF3UmVjdC55ID0gMDtcbiAgICAgICAgY2xpcHBpbmdDb250ZXh0Ll9hbGxDbGlwcGVkRHJhd1JlY3Qud2lkdGggPSAwO1xuICAgICAgICBjbGlwcGluZ0NvbnRleHQuX2FsbENsaXBwZWREcmF3UmVjdC5oZWlnaHQgPSAwO1xuICAgICAgICBjbGlwcGluZ0NvbnRleHQuX2lzVXNpbmcgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsaXBwaW5nQ29udGV4dC5faXNVc2luZyA9IHRydWU7XG4gICAgICAgIGNvbnN0IHcgPSBjbGlwcGVkRHJhd1RvdGFsTWF4WCAtIGNsaXBwZWREcmF3VG90YWxNaW5YO1xuICAgICAgICBjb25zdCBoID0gY2xpcHBlZERyYXdUb3RhbE1heFkgLSBjbGlwcGVkRHJhd1RvdGFsTWluWTtcbiAgICAgICAgY2xpcHBpbmdDb250ZXh0Ll9hbGxDbGlwcGVkRHJhd1JlY3QueCA9IGNsaXBwZWREcmF3VG90YWxNaW5YO1xuICAgICAgICBjbGlwcGluZ0NvbnRleHQuX2FsbENsaXBwZWREcmF3UmVjdC55ID0gY2xpcHBlZERyYXdUb3RhbE1pblk7XG4gICAgICAgIGNsaXBwaW5nQ29udGV4dC5fYWxsQ2xpcHBlZERyYXdSZWN0LndpZHRoID0gdztcbiAgICAgICAgY2xpcHBpbmdDb250ZXh0Ll9hbGxDbGlwcGVkRHJhd1JlY3QuaGVpZ2h0ID0gaDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fbWFza1JlbmRlclRleHR1cmUgPSBudWxsO1xuICAgIHRoaXMuX2NvbG9yQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLl9jdXJyZW50RnJhbWVObyA9IDA7XG4gICAgdGhpcy5fY2xpcHBpbmdNYXNrQnVmZmVyU2l6ZSA9IDI1NjtcbiAgICB0aGlzLl9jbGlwcGluZ0NvbnRleHRMaXN0Rm9yTWFzayA9IFtdO1xuICAgIHRoaXMuX2NsaXBwaW5nQ29udGV4dExpc3RGb3JEcmF3ID0gW107XG4gICAgdGhpcy5fY2hhbm5lbENvbG9ycyA9IFtdO1xuICAgIHRoaXMuX3RtcEJvdW5kc09uTW9kZWwgPSBuZXcgY3NtUmVjdCgpO1xuICAgIHRoaXMuX3RtcE1hdHJpeCA9IG5ldyBDdWJpc21NYXRyaXg0NCgpO1xuICAgIHRoaXMuX3RtcE1hdHJpeEZvck1hc2sgPSBuZXcgQ3ViaXNtTWF0cml4NDQoKTtcbiAgICB0aGlzLl90bXBNYXRyaXhGb3JEcmF3ID0gbmV3IEN1YmlzbU1hdHJpeDQ0KCk7XG4gICAgbGV0IHRtcCA9IG5ldyBDdWJpc21UZXh0dXJlQ29sb3IoKTtcbiAgICB0bXAuUiA9IDE7XG4gICAgdG1wLkcgPSAwO1xuICAgIHRtcC5CID0gMDtcbiAgICB0bXAuQSA9IDA7XG4gICAgdGhpcy5fY2hhbm5lbENvbG9ycy5wdXNoKHRtcCk7XG4gICAgdG1wID0gbmV3IEN1YmlzbVRleHR1cmVDb2xvcigpO1xuICAgIHRtcC5SID0gMDtcbiAgICB0bXAuRyA9IDE7XG4gICAgdG1wLkIgPSAwO1xuICAgIHRtcC5BID0gMDtcbiAgICB0aGlzLl9jaGFubmVsQ29sb3JzLnB1c2godG1wKTtcbiAgICB0bXAgPSBuZXcgQ3ViaXNtVGV4dHVyZUNvbG9yKCk7XG4gICAgdG1wLlIgPSAwO1xuICAgIHRtcC5HID0gMDtcbiAgICB0bXAuQiA9IDE7XG4gICAgdG1wLkEgPSAwO1xuICAgIHRoaXMuX2NoYW5uZWxDb2xvcnMucHVzaCh0bXApO1xuICAgIHRtcCA9IG5ldyBDdWJpc21UZXh0dXJlQ29sb3IoKTtcbiAgICB0bXAuUiA9IDA7XG4gICAgdG1wLkcgPSAwO1xuICAgIHRtcC5CID0gMDtcbiAgICB0bXAuQSA9IDE7XG4gICAgdGhpcy5fY2hhbm5lbENvbG9ycy5wdXNoKHRtcCk7XG4gIH1cbiAgcmVsZWFzZSgpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2NsaXBwaW5nQ29udGV4dExpc3RGb3JNYXNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5fY2xpcHBpbmdDb250ZXh0TGlzdEZvck1hc2tbaV0pIHtcbiAgICAgICAgKF9hID0gdGhpcy5fY2xpcHBpbmdDb250ZXh0TGlzdEZvck1hc2tbaV0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5yZWxlYXNlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGYuX2NsaXBwaW5nQ29udGV4dExpc3RGb3JNYXNrID0gdm9pZCAwO1xuICAgIHNlbGYuX2NsaXBwaW5nQ29udGV4dExpc3RGb3JEcmF3ID0gdm9pZCAwO1xuICAgIGlmICh0aGlzLl9tYXNrVGV4dHVyZSkge1xuICAgICAgKF9iID0gdGhpcy5nbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmRlbGV0ZUZyYW1lYnVmZmVyKHRoaXMuX21hc2tUZXh0dXJlLnRleHR1cmUpO1xuICAgICAgc2VsZi5fbWFza1RleHR1cmUgPSB2b2lkIDA7XG4gICAgfVxuICAgIHNlbGYuX2NoYW5uZWxDb2xvcnMgPSB2b2lkIDA7XG4gICAgKF9jID0gdGhpcy5nbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmRlbGV0ZVRleHR1cmUodGhpcy5fY29sb3JCdWZmZXIpO1xuICAgIHRoaXMuX2NvbG9yQnVmZmVyID0gbnVsbDtcbiAgfVxuICBpbml0aWFsaXplKG1vZGVsLCBkcmF3YWJsZUNvdW50LCBkcmF3YWJsZU1hc2tzLCBkcmF3YWJsZU1hc2tDb3VudHMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRyYXdhYmxlQ291bnQ7IGkrKykge1xuICAgICAgaWYgKGRyYXdhYmxlTWFza0NvdW50c1tpXSA8PSAwKSB7XG4gICAgICAgIHRoaXMuX2NsaXBwaW5nQ29udGV4dExpc3RGb3JEcmF3LnB1c2gobnVsbCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IGNsaXBwaW5nQ29udGV4dCA9IHRoaXMuZmluZFNhbWVDbGlwKGRyYXdhYmxlTWFza3NbaV0sIGRyYXdhYmxlTWFza0NvdW50c1tpXSk7XG4gICAgICBpZiAoY2xpcHBpbmdDb250ZXh0ID09IG51bGwpIHtcbiAgICAgICAgY2xpcHBpbmdDb250ZXh0ID0gbmV3IEN1YmlzbUNsaXBwaW5nQ29udGV4dCh0aGlzLCBkcmF3YWJsZU1hc2tzW2ldLCBkcmF3YWJsZU1hc2tDb3VudHNbaV0pO1xuICAgICAgICB0aGlzLl9jbGlwcGluZ0NvbnRleHRMaXN0Rm9yTWFzay5wdXNoKGNsaXBwaW5nQ29udGV4dCk7XG4gICAgICB9XG4gICAgICBjbGlwcGluZ0NvbnRleHQuYWRkQ2xpcHBlZERyYXdhYmxlKGkpO1xuICAgICAgdGhpcy5fY2xpcHBpbmdDb250ZXh0TGlzdEZvckRyYXcucHVzaChjbGlwcGluZ0NvbnRleHQpO1xuICAgIH1cbiAgfVxuICBzZXR1cENsaXBwaW5nQ29udGV4dChtb2RlbCwgcmVuZGVyZXIpIHtcbiAgICB0aGlzLl9jdXJyZW50RnJhbWVObysrO1xuICAgIGxldCB1c2luZ0NsaXBDb3VudCA9IDA7XG4gICAgZm9yIChsZXQgY2xpcEluZGV4ID0gMDsgY2xpcEluZGV4IDwgdGhpcy5fY2xpcHBpbmdDb250ZXh0TGlzdEZvck1hc2subGVuZ3RoOyBjbGlwSW5kZXgrKykge1xuICAgICAgY29uc3QgY2MgPSB0aGlzLl9jbGlwcGluZ0NvbnRleHRMaXN0Rm9yTWFza1tjbGlwSW5kZXhdO1xuICAgICAgdGhpcy5jYWxjQ2xpcHBlZERyYXdUb3RhbEJvdW5kcyhtb2RlbCwgY2MpO1xuICAgICAgaWYgKGNjLl9pc1VzaW5nKSB7XG4gICAgICAgIHVzaW5nQ2xpcENvdW50Kys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1c2luZ0NsaXBDb3VudCA+IDApIHtcbiAgICAgIHRoaXMuZ2wudmlld3BvcnQoMCwgMCwgdGhpcy5fY2xpcHBpbmdNYXNrQnVmZmVyU2l6ZSwgdGhpcy5fY2xpcHBpbmdNYXNrQnVmZmVyU2l6ZSk7XG4gICAgICB0aGlzLl9tYXNrUmVuZGVyVGV4dHVyZSA9IHRoaXMuZ2V0TWFza1JlbmRlclRleHR1cmUoKTtcbiAgICAgIHJlbmRlcmVyLmdldE12cE1hdHJpeCgpO1xuICAgICAgcmVuZGVyZXIucHJlRHJhdygpO1xuICAgICAgdGhpcy5zZXR1cExheW91dEJvdW5kcyh1c2luZ0NsaXBDb3VudCk7XG4gICAgICB0aGlzLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLmdsLkZSQU1FQlVGRkVSLCB0aGlzLl9tYXNrUmVuZGVyVGV4dHVyZSk7XG4gICAgICB0aGlzLmdsLmNsZWFyQ29sb3IoMSwgMSwgMSwgMSk7XG4gICAgICB0aGlzLmdsLmNsZWFyKHRoaXMuZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgICBmb3IgKGxldCBjbGlwSW5kZXggPSAwOyBjbGlwSW5kZXggPCB0aGlzLl9jbGlwcGluZ0NvbnRleHRMaXN0Rm9yTWFzay5sZW5ndGg7IGNsaXBJbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IGNsaXBDb250ZXh0ID0gdGhpcy5fY2xpcHBpbmdDb250ZXh0TGlzdEZvck1hc2tbY2xpcEluZGV4XTtcbiAgICAgICAgY29uc3QgYWxsQ2xpcGVkRHJhd1JlY3QgPSBjbGlwQ29udGV4dC5fYWxsQ2xpcHBlZERyYXdSZWN0O1xuICAgICAgICBjb25zdCBsYXlvdXRCb3VuZHNPblRleDAxID0gY2xpcENvbnRleHQuX2xheW91dEJvdW5kcztcbiAgICAgICAgY29uc3QgTUFSR0lOID0gMC4wNTtcbiAgICAgICAgdGhpcy5fdG1wQm91bmRzT25Nb2RlbC5zZXRSZWN0KGFsbENsaXBlZERyYXdSZWN0KTtcbiAgICAgICAgdGhpcy5fdG1wQm91bmRzT25Nb2RlbC5leHBhbmQoYWxsQ2xpcGVkRHJhd1JlY3Qud2lkdGggKiBNQVJHSU4sIGFsbENsaXBlZERyYXdSZWN0LmhlaWdodCAqIE1BUkdJTik7XG4gICAgICAgIGNvbnN0IHNjYWxlWCA9IGxheW91dEJvdW5kc09uVGV4MDEud2lkdGggLyB0aGlzLl90bXBCb3VuZHNPbk1vZGVsLndpZHRoO1xuICAgICAgICBjb25zdCBzY2FsZVkgPSBsYXlvdXRCb3VuZHNPblRleDAxLmhlaWdodCAvIHRoaXMuX3RtcEJvdW5kc09uTW9kZWwuaGVpZ2h0O1xuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5fdG1wTWF0cml4LmxvYWRJZGVudGl0eSgpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3RtcE1hdHJpeC50cmFuc2xhdGVSZWxhdGl2ZSgtMSwgLTEpO1xuICAgICAgICAgICAgdGhpcy5fdG1wTWF0cml4LnNjYWxlUmVsYXRpdmUoMiwgMik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3RtcE1hdHJpeC50cmFuc2xhdGVSZWxhdGl2ZShsYXlvdXRCb3VuZHNPblRleDAxLngsIGxheW91dEJvdW5kc09uVGV4MDEueSk7XG4gICAgICAgICAgICB0aGlzLl90bXBNYXRyaXguc2NhbGVSZWxhdGl2ZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgICAgICB0aGlzLl90bXBNYXRyaXgudHJhbnNsYXRlUmVsYXRpdmUoLXRoaXMuX3RtcEJvdW5kc09uTW9kZWwueCwgLXRoaXMuX3RtcEJvdW5kc09uTW9kZWwueSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3RtcE1hdHJpeEZvck1hc2suc2V0TWF0cml4KHRoaXMuX3RtcE1hdHJpeC5nZXRBcnJheSgpKTtcbiAgICAgICAgfVxuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5fdG1wTWF0cml4LmxvYWRJZGVudGl0eSgpO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3RtcE1hdHJpeC50cmFuc2xhdGVSZWxhdGl2ZShsYXlvdXRCb3VuZHNPblRleDAxLngsIGxheW91dEJvdW5kc09uVGV4MDEueSk7XG4gICAgICAgICAgICB0aGlzLl90bXBNYXRyaXguc2NhbGVSZWxhdGl2ZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgICAgICB0aGlzLl90bXBNYXRyaXgudHJhbnNsYXRlUmVsYXRpdmUoLXRoaXMuX3RtcEJvdW5kc09uTW9kZWwueCwgLXRoaXMuX3RtcEJvdW5kc09uTW9kZWwueSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3RtcE1hdHJpeEZvckRyYXcuc2V0TWF0cml4KHRoaXMuX3RtcE1hdHJpeC5nZXRBcnJheSgpKTtcbiAgICAgICAgfVxuICAgICAgICBjbGlwQ29udGV4dC5fbWF0cml4Rm9yTWFzay5zZXRNYXRyaXgodGhpcy5fdG1wTWF0cml4Rm9yTWFzay5nZXRBcnJheSgpKTtcbiAgICAgICAgY2xpcENvbnRleHQuX21hdHJpeEZvckRyYXcuc2V0TWF0cml4KHRoaXMuX3RtcE1hdHJpeEZvckRyYXcuZ2V0QXJyYXkoKSk7XG4gICAgICAgIGNvbnN0IGNsaXBEcmF3Q291bnQgPSBjbGlwQ29udGV4dC5fY2xpcHBpbmdJZENvdW50O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsaXBEcmF3Q291bnQ7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNsaXBEcmF3SW5kZXggPSBjbGlwQ29udGV4dC5fY2xpcHBpbmdJZExpc3RbaV07XG4gICAgICAgICAgaWYgKCFtb2RlbC5nZXREcmF3YWJsZUR5bmFtaWNGbGFnVmVydGV4UG9zaXRpb25zRGlkQ2hhbmdlKGNsaXBEcmF3SW5kZXgpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVuZGVyZXIuc2V0SXNDdWxsaW5nKG1vZGVsLmdldERyYXdhYmxlQ3VsbGluZyhjbGlwRHJhd0luZGV4KSAhPSBmYWxzZSk7XG4gICAgICAgICAgcmVuZGVyZXIuc2V0Q2xpcHBpbmdDb250ZXh0QnVmZmVyRm9yTWFzayhjbGlwQ29udGV4dCk7XG4gICAgICAgICAgcmVuZGVyZXIuZHJhd01lc2gobW9kZWwuZ2V0RHJhd2FibGVUZXh0dXJlSW5kaWNlcyhjbGlwRHJhd0luZGV4KSwgbW9kZWwuZ2V0RHJhd2FibGVWZXJ0ZXhJbmRleENvdW50KGNsaXBEcmF3SW5kZXgpLCBtb2RlbC5nZXREcmF3YWJsZVZlcnRleENvdW50KGNsaXBEcmF3SW5kZXgpLCBtb2RlbC5nZXREcmF3YWJsZVZlcnRleEluZGljZXMoY2xpcERyYXdJbmRleCksIG1vZGVsLmdldERyYXdhYmxlVmVydGljZXMoY2xpcERyYXdJbmRleCksIG1vZGVsLmdldERyYXdhYmxlVmVydGV4VXZzKGNsaXBEcmF3SW5kZXgpLCBtb2RlbC5nZXREcmF3YWJsZU9wYWNpdHkoY2xpcERyYXdJbmRleCksIEN1YmlzbUJsZW5kTW9kZS5DdWJpc21CbGVuZE1vZGVfTm9ybWFsLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuZ2wuRlJBTUVCVUZGRVIsIHNfZmJvKTtcbiAgICAgIHJlbmRlcmVyLnNldENsaXBwaW5nQ29udGV4dEJ1ZmZlckZvck1hc2sobnVsbCk7XG4gICAgICB0aGlzLmdsLnZpZXdwb3J0KHNfdmlld3BvcnRbMF0sIHNfdmlld3BvcnRbMV0sIHNfdmlld3BvcnRbMl0sIHNfdmlld3BvcnRbM10pO1xuICAgIH1cbiAgfVxuICBmaW5kU2FtZUNsaXAoZHJhd2FibGVNYXNrcywgZHJhd2FibGVNYXNrQ291bnRzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9jbGlwcGluZ0NvbnRleHRMaXN0Rm9yTWFzay5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2xpcHBpbmdDb250ZXh0ID0gdGhpcy5fY2xpcHBpbmdDb250ZXh0TGlzdEZvck1hc2tbaV07XG4gICAgICBjb25zdCBjb3VudCA9IGNsaXBwaW5nQ29udGV4dC5fY2xpcHBpbmdJZENvdW50O1xuICAgICAgaWYgKGNvdW50ICE9IGRyYXdhYmxlTWFza0NvdW50cykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBzYW1lQ291bnQgPSAwO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgIGNvbnN0IGNsaXBJZCA9IGNsaXBwaW5nQ29udGV4dC5fY2xpcHBpbmdJZExpc3Rbal07XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgY291bnQ7IGsrKykge1xuICAgICAgICAgIGlmIChkcmF3YWJsZU1hc2tzW2tdID09IGNsaXBJZCkge1xuICAgICAgICAgICAgc2FtZUNvdW50Kys7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzYW1lQ291bnQgPT0gY291bnQpIHtcbiAgICAgICAgcmV0dXJuIGNsaXBwaW5nQ29udGV4dDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc2V0dXBMYXlvdXRCb3VuZHModXNpbmdDbGlwQ291bnQpIHtcbiAgICBsZXQgZGl2ID0gdXNpbmdDbGlwQ291bnQgLyBDb2xvckNoYW5uZWxDb3VudDtcbiAgICBsZXQgbW9kID0gdXNpbmdDbGlwQ291bnQgJSBDb2xvckNoYW5uZWxDb3VudDtcbiAgICBkaXYgPSB+fmRpdjtcbiAgICBtb2QgPSB+fm1vZDtcbiAgICBsZXQgY3VyQ2xpcEluZGV4ID0gMDtcbiAgICBmb3IgKGxldCBjaGFubmVsTm8gPSAwOyBjaGFubmVsTm8gPCBDb2xvckNoYW5uZWxDb3VudDsgY2hhbm5lbE5vKyspIHtcbiAgICAgIGNvbnN0IGxheW91dENvdW50ID0gZGl2ICsgKGNoYW5uZWxObyA8IG1vZCA/IDEgOiAwKTtcbiAgICAgIGlmIChsYXlvdXRDb3VudCA9PSAwKVxuICAgICAgICA7XG4gICAgICBlbHNlIGlmIChsYXlvdXRDb3VudCA9PSAxKSB7XG4gICAgICAgIGNvbnN0IGNsaXBDb250ZXh0ID0gdGhpcy5fY2xpcHBpbmdDb250ZXh0TGlzdEZvck1hc2tbY3VyQ2xpcEluZGV4KytdO1xuICAgICAgICBjbGlwQ29udGV4dC5fbGF5b3V0Q2hhbm5lbE5vID0gY2hhbm5lbE5vO1xuICAgICAgICBjbGlwQ29udGV4dC5fbGF5b3V0Qm91bmRzLnggPSAwO1xuICAgICAgICBjbGlwQ29udGV4dC5fbGF5b3V0Qm91bmRzLnkgPSAwO1xuICAgICAgICBjbGlwQ29udGV4dC5fbGF5b3V0Qm91bmRzLndpZHRoID0gMTtcbiAgICAgICAgY2xpcENvbnRleHQuX2xheW91dEJvdW5kcy5oZWlnaHQgPSAxO1xuICAgICAgfSBlbHNlIGlmIChsYXlvdXRDb3VudCA9PSAyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGF5b3V0Q291bnQ7IGkrKykge1xuICAgICAgICAgIGxldCB4cG9zID0gaSAlIDI7XG4gICAgICAgICAgeHBvcyA9IH5+eHBvcztcbiAgICAgICAgICBjb25zdCBjYyA9IHRoaXMuX2NsaXBwaW5nQ29udGV4dExpc3RGb3JNYXNrW2N1ckNsaXBJbmRleCsrXTtcbiAgICAgICAgICBjYy5fbGF5b3V0Q2hhbm5lbE5vID0gY2hhbm5lbE5vO1xuICAgICAgICAgIGNjLl9sYXlvdXRCb3VuZHMueCA9IHhwb3MgKiAwLjU7XG4gICAgICAgICAgY2MuX2xheW91dEJvdW5kcy55ID0gMDtcbiAgICAgICAgICBjYy5fbGF5b3V0Qm91bmRzLndpZHRoID0gMC41O1xuICAgICAgICAgIGNjLl9sYXlvdXRCb3VuZHMuaGVpZ2h0ID0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsYXlvdXRDb3VudCA8PSA0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGF5b3V0Q291bnQ7IGkrKykge1xuICAgICAgICAgIGxldCB4cG9zID0gaSAlIDI7XG4gICAgICAgICAgbGV0IHlwb3MgPSBpIC8gMjtcbiAgICAgICAgICB4cG9zID0gfn54cG9zO1xuICAgICAgICAgIHlwb3MgPSB+fnlwb3M7XG4gICAgICAgICAgY29uc3QgY2MgPSB0aGlzLl9jbGlwcGluZ0NvbnRleHRMaXN0Rm9yTWFza1tjdXJDbGlwSW5kZXgrK107XG4gICAgICAgICAgY2MuX2xheW91dENoYW5uZWxObyA9IGNoYW5uZWxObztcbiAgICAgICAgICBjYy5fbGF5b3V0Qm91bmRzLnggPSB4cG9zICogMC41O1xuICAgICAgICAgIGNjLl9sYXlvdXRCb3VuZHMueSA9IHlwb3MgKiAwLjU7XG4gICAgICAgICAgY2MuX2xheW91dEJvdW5kcy53aWR0aCA9IDAuNTtcbiAgICAgICAgICBjYy5fbGF5b3V0Qm91bmRzLmhlaWdodCA9IDAuNTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsYXlvdXRDb3VudCA8PSA5KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGF5b3V0Q291bnQ7IGkrKykge1xuICAgICAgICAgIGxldCB4cG9zID0gaSAlIDM7XG4gICAgICAgICAgbGV0IHlwb3MgPSBpIC8gMztcbiAgICAgICAgICB4cG9zID0gfn54cG9zO1xuICAgICAgICAgIHlwb3MgPSB+fnlwb3M7XG4gICAgICAgICAgY29uc3QgY2MgPSB0aGlzLl9jbGlwcGluZ0NvbnRleHRMaXN0Rm9yTWFza1tjdXJDbGlwSW5kZXgrK107XG4gICAgICAgICAgY2MuX2xheW91dENoYW5uZWxObyA9IGNoYW5uZWxObztcbiAgICAgICAgICBjYy5fbGF5b3V0Qm91bmRzLnggPSB4cG9zIC8gMztcbiAgICAgICAgICBjYy5fbGF5b3V0Qm91bmRzLnkgPSB5cG9zIC8gMztcbiAgICAgICAgICBjYy5fbGF5b3V0Qm91bmRzLndpZHRoID0gMSAvIDM7XG4gICAgICAgICAgY2MuX2xheW91dEJvdW5kcy5oZWlnaHQgPSAxIC8gMztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChDdWJpc21Db25maWcuc3VwcG9ydE1vcmVNYXNrRGl2aXNpb25zICYmIGxheW91dENvdW50IDw9IDE2KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGF5b3V0Q291bnQ7IGkrKykge1xuICAgICAgICAgIGxldCB4cG9zID0gaSAlIDQ7XG4gICAgICAgICAgbGV0IHlwb3MgPSBpIC8gNDtcbiAgICAgICAgICB4cG9zID0gfn54cG9zO1xuICAgICAgICAgIHlwb3MgPSB+fnlwb3M7XG4gICAgICAgICAgY29uc3QgY2MgPSB0aGlzLl9jbGlwcGluZ0NvbnRleHRMaXN0Rm9yTWFza1tjdXJDbGlwSW5kZXgrK107XG4gICAgICAgICAgY2MuX2xheW91dENoYW5uZWxObyA9IGNoYW5uZWxObztcbiAgICAgICAgICBjYy5fbGF5b3V0Qm91bmRzLnggPSB4cG9zIC8gNDtcbiAgICAgICAgICBjYy5fbGF5b3V0Qm91bmRzLnkgPSB5cG9zIC8gNDtcbiAgICAgICAgICBjYy5fbGF5b3V0Qm91bmRzLndpZHRoID0gMSAvIDQ7XG4gICAgICAgICAgY2MuX2xheW91dEJvdW5kcy5oZWlnaHQgPSAxIC8gNDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQ3ViaXNtTG9nRXJyb3IoXCJub3Qgc3VwcG9ydGVkIG1hc2sgY291bnQgOiB7MH1cIiwgbGF5b3V0Q291bnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRDb2xvckJ1ZmZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fY29sb3JCdWZmZXI7XG4gIH1cbiAgZ2V0Q2xpcHBpbmdDb250ZXh0TGlzdEZvckRyYXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaXBwaW5nQ29udGV4dExpc3RGb3JEcmF3O1xuICB9XG4gIHNldENsaXBwaW5nTWFza0J1ZmZlclNpemUoc2l6ZSkge1xuICAgIHRoaXMuX2NsaXBwaW5nTWFza0J1ZmZlclNpemUgPSBzaXplO1xuICB9XG4gIGdldENsaXBwaW5nTWFza0J1ZmZlclNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaXBwaW5nTWFza0J1ZmZlclNpemU7XG4gIH1cbn1cbmNsYXNzIEN1YmlzbVJlbmRlclRleHR1cmVSZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yKGZyYW1lTm8sIHRleHR1cmUpIHtcbiAgICB0aGlzLmZyYW1lTm8gPSBmcmFtZU5vO1xuICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XG4gIH1cbn1cbmNsYXNzIEN1YmlzbUNsaXBwaW5nQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIsIGNsaXBwaW5nRHJhd2FibGVJbmRpY2VzLCBjbGlwQ291bnQpIHtcbiAgICB0aGlzLl9pc1VzaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fb3duZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuX2NsaXBwaW5nSWRMaXN0ID0gY2xpcHBpbmdEcmF3YWJsZUluZGljZXM7XG4gICAgdGhpcy5fY2xpcHBpbmdJZENvdW50ID0gY2xpcENvdW50O1xuICAgIHRoaXMuX2FsbENsaXBwZWREcmF3UmVjdCA9IG5ldyBjc21SZWN0KCk7XG4gICAgdGhpcy5fbGF5b3V0Qm91bmRzID0gbmV3IGNzbVJlY3QoKTtcbiAgICB0aGlzLl9jbGlwcGVkRHJhd2FibGVJbmRleExpc3QgPSBbXTtcbiAgICB0aGlzLl9tYXRyaXhGb3JNYXNrID0gbmV3IEN1YmlzbU1hdHJpeDQ0KCk7XG4gICAgdGhpcy5fbWF0cml4Rm9yRHJhdyA9IG5ldyBDdWJpc21NYXRyaXg0NCgpO1xuICB9XG4gIHJlbGVhc2UoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5fbGF5b3V0Qm91bmRzID0gdm9pZCAwO1xuICAgIHNlbGYuX2FsbENsaXBwZWREcmF3UmVjdCA9IHZvaWQgMDtcbiAgICBzZWxmLl9jbGlwcGVkRHJhd2FibGVJbmRleExpc3QgPSB2b2lkIDA7XG4gIH1cbiAgYWRkQ2xpcHBlZERyYXdhYmxlKGRyYXdhYmxlSW5kZXgpIHtcbiAgICB0aGlzLl9jbGlwcGVkRHJhd2FibGVJbmRleExpc3QucHVzaChkcmF3YWJsZUluZGV4KTtcbiAgfVxuICBnZXRDbGlwcGluZ01hbmFnZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX293bmVyO1xuICB9XG4gIHNldEdsKGdsKSB7XG4gICAgdGhpcy5fb3duZXIuc2V0R0woZ2wpO1xuICB9XG59XG5jbGFzcyBDdWJpc21TaGFkZXJfV2ViR0wge1xuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XG4gICAgaWYgKHNfaW5zdGFuY2UgPT0gbnVsbCkge1xuICAgICAgc19pbnN0YW5jZSA9IG5ldyBDdWJpc21TaGFkZXJfV2ViR0woKTtcbiAgICAgIHJldHVybiBzX2luc3RhbmNlO1xuICAgIH1cbiAgICByZXR1cm4gc19pbnN0YW5jZTtcbiAgfVxuICBzdGF0aWMgZGVsZXRlSW5zdGFuY2UoKSB7XG4gICAgaWYgKHNfaW5zdGFuY2UpIHtcbiAgICAgIHNfaW5zdGFuY2UucmVsZWFzZSgpO1xuICAgICAgc19pbnN0YW5jZSA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fc2hhZGVyU2V0cyA9IFtdO1xuICB9XG4gIHJlbGVhc2UoKSB7XG4gICAgdGhpcy5yZWxlYXNlU2hhZGVyUHJvZ3JhbSgpO1xuICB9XG4gIHNldHVwU2hhZGVyUHJvZ3JhbShyZW5kZXJlciwgdGV4dHVyZUlkLCB2ZXJ0ZXhDb3VudCwgdmVydGV4QXJyYXksIGluZGV4QXJyYXksIHV2QXJyYXksIGJ1ZmZlckRhdGEsIG9wYWNpdHksIGNvbG9yQmxlbmRNb2RlLCBiYXNlQ29sb3IsIGlzUHJlbXVsdGlwbGllZEFscGhhLCBtYXRyaXg0eDQsIGludmVydGVkTWFzaykge1xuICAgIGlmICghaXNQcmVtdWx0aXBsaWVkQWxwaGEpIHtcbiAgICAgIEN1YmlzbUxvZ0Vycm9yKFwiTm9QcmVtdWx0aXBsaWVkQWxwaGEgaXMgbm90IGFsbG93ZWRcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zaGFkZXJTZXRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICB0aGlzLmdlbmVyYXRlU2hhZGVycygpO1xuICAgIH1cbiAgICBsZXQgU1JDX0NPTE9SO1xuICAgIGxldCBEU1RfQ09MT1I7XG4gICAgbGV0IFNSQ19BTFBIQTtcbiAgICBsZXQgRFNUX0FMUEhBO1xuICAgIGNvbnN0IGNsaXBwaW5nQ29udGV4dEJ1ZmZlckZvck1hc2sgPSByZW5kZXJlci5nZXRDbGlwcGluZ0NvbnRleHRCdWZmZXJGb3JNYXNrKCk7XG4gICAgaWYgKGNsaXBwaW5nQ29udGV4dEJ1ZmZlckZvck1hc2sgIT0gbnVsbCkge1xuICAgICAgY29uc3Qgc2hhZGVyU2V0ID0gdGhpcy5fc2hhZGVyU2V0c1tTaGFkZXJOYW1lcy5TaGFkZXJOYW1lc19TZXR1cE1hc2tdO1xuICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKHNoYWRlclNldC5zaGFkZXJQcm9ncmFtKTtcbiAgICAgIHRoaXMuZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkUwKTtcbiAgICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCB0ZXh0dXJlSWQpO1xuICAgICAgdGhpcy5nbC51bmlmb3JtMWkoc2hhZGVyU2V0LnNhbXBsZXJUZXh0dXJlMExvY2F0aW9uLCAwKTtcbiAgICAgIGlmIChidWZmZXJEYXRhLnZlcnRleCA9PSBudWxsKSB7XG4gICAgICAgIGJ1ZmZlckRhdGEudmVydGV4ID0gdGhpcy5nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyRGF0YS52ZXJ0ZXgpO1xuICAgICAgdGhpcy5nbC5idWZmZXJEYXRhKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhBcnJheSwgdGhpcy5nbC5EWU5BTUlDX0RSQVcpO1xuICAgICAgdGhpcy5nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShzaGFkZXJTZXQuYXR0cmlidXRlUG9zaXRpb25Mb2NhdGlvbik7XG4gICAgICB0aGlzLmdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2hhZGVyU2V0LmF0dHJpYnV0ZVBvc2l0aW9uTG9jYXRpb24sIDIsIHRoaXMuZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICAgIGlmIChidWZmZXJEYXRhLnV2ID09IG51bGwpIHtcbiAgICAgICAgYnVmZmVyRGF0YS51diA9IHRoaXMuZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlckRhdGEudXYpO1xuICAgICAgdGhpcy5nbC5idWZmZXJEYXRhKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCB1dkFycmF5LCB0aGlzLmdsLkRZTkFNSUNfRFJBVyk7XG4gICAgICB0aGlzLmdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHNoYWRlclNldC5hdHRyaWJ1dGVUZXhDb29yZExvY2F0aW9uKTtcbiAgICAgIHRoaXMuZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXJTZXQuYXR0cmlidXRlVGV4Q29vcmRMb2NhdGlvbiwgMiwgdGhpcy5nbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgICAgY29uc3QgY2hhbm5lbE5vID0gY2xpcHBpbmdDb250ZXh0QnVmZmVyRm9yTWFzay5fbGF5b3V0Q2hhbm5lbE5vO1xuICAgICAgY29uc3QgY29sb3JDaGFubmVsID0gY2xpcHBpbmdDb250ZXh0QnVmZmVyRm9yTWFzay5nZXRDbGlwcGluZ01hbmFnZXIoKS5nZXRDaGFubmVsRmxhZ0FzQ29sb3IoY2hhbm5lbE5vKTtcbiAgICAgIHRoaXMuZ2wudW5pZm9ybTRmKHNoYWRlclNldC51bmlmb3JtQ2hhbm5lbEZsYWdMb2NhdGlvbiwgY29sb3JDaGFubmVsLlIsIGNvbG9yQ2hhbm5lbC5HLCBjb2xvckNoYW5uZWwuQiwgY29sb3JDaGFubmVsLkEpO1xuICAgICAgdGhpcy5nbC51bmlmb3JtTWF0cml4NGZ2KHNoYWRlclNldC51bmlmb3JtQ2xpcE1hdHJpeExvY2F0aW9uLCBmYWxzZSwgY2xpcHBpbmdDb250ZXh0QnVmZmVyRm9yTWFzay5fbWF0cml4Rm9yTWFzay5nZXRBcnJheSgpKTtcbiAgICAgIGNvbnN0IHJlY3QgPSBjbGlwcGluZ0NvbnRleHRCdWZmZXJGb3JNYXNrLl9sYXlvdXRCb3VuZHM7XG4gICAgICB0aGlzLmdsLnVuaWZvcm00ZihzaGFkZXJTZXQudW5pZm9ybUJhc2VDb2xvckxvY2F0aW9uLCByZWN0LnggKiAyIC0gMSwgcmVjdC55ICogMiAtIDEsIHJlY3QuZ2V0UmlnaHQoKSAqIDIgLSAxLCByZWN0LmdldEJvdHRvbSgpICogMiAtIDEpO1xuICAgICAgU1JDX0NPTE9SID0gdGhpcy5nbC5aRVJPO1xuICAgICAgRFNUX0NPTE9SID0gdGhpcy5nbC5PTkVfTUlOVVNfU1JDX0NPTE9SO1xuICAgICAgU1JDX0FMUEhBID0gdGhpcy5nbC5aRVJPO1xuICAgICAgRFNUX0FMUEhBID0gdGhpcy5nbC5PTkVfTUlOVVNfU1JDX0FMUEhBO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjbGlwcGluZ0NvbnRleHRCdWZmZXJGb3JEcmF3ID0gcmVuZGVyZXIuZ2V0Q2xpcHBpbmdDb250ZXh0QnVmZmVyRm9yRHJhdygpO1xuICAgICAgY29uc3QgbWFza2VkID0gY2xpcHBpbmdDb250ZXh0QnVmZmVyRm9yRHJhdyAhPSBudWxsO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gbWFza2VkID8gaW52ZXJ0ZWRNYXNrID8gMiA6IDEgOiAwO1xuICAgICAgbGV0IHNoYWRlclNldDtcbiAgICAgIHN3aXRjaCAoY29sb3JCbGVuZE1vZGUpIHtcbiAgICAgICAgY2FzZSBDdWJpc21CbGVuZE1vZGUuQ3ViaXNtQmxlbmRNb2RlX05vcm1hbDpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzaGFkZXJTZXQgPSB0aGlzLl9zaGFkZXJTZXRzW1NoYWRlck5hbWVzLlNoYWRlck5hbWVzX05vcm1hbFByZW11bHRpcGxpZWRBbHBoYSArIG9mZnNldF07XG4gICAgICAgICAgU1JDX0NPTE9SID0gdGhpcy5nbC5PTkU7XG4gICAgICAgICAgRFNUX0NPTE9SID0gdGhpcy5nbC5PTkVfTUlOVVNfU1JDX0FMUEhBO1xuICAgICAgICAgIFNSQ19BTFBIQSA9IHRoaXMuZ2wuT05FO1xuICAgICAgICAgIERTVF9BTFBIQSA9IHRoaXMuZ2wuT05FX01JTlVTX1NSQ19BTFBIQTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDdWJpc21CbGVuZE1vZGUuQ3ViaXNtQmxlbmRNb2RlX0FkZGl0aXZlOlxuICAgICAgICAgIHNoYWRlclNldCA9IHRoaXMuX3NoYWRlclNldHNbU2hhZGVyTmFtZXMuU2hhZGVyTmFtZXNfQWRkUHJlbXVsdGlwbGllZEFscGhhICsgb2Zmc2V0XTtcbiAgICAgICAgICBTUkNfQ09MT1IgPSB0aGlzLmdsLk9ORTtcbiAgICAgICAgICBEU1RfQ09MT1IgPSB0aGlzLmdsLk9ORTtcbiAgICAgICAgICBTUkNfQUxQSEEgPSB0aGlzLmdsLlpFUk87XG4gICAgICAgICAgRFNUX0FMUEhBID0gdGhpcy5nbC5PTkU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ3ViaXNtQmxlbmRNb2RlLkN1YmlzbUJsZW5kTW9kZV9NdWx0aXBsaWNhdGl2ZTpcbiAgICAgICAgICBzaGFkZXJTZXQgPSB0aGlzLl9zaGFkZXJTZXRzW1NoYWRlck5hbWVzLlNoYWRlck5hbWVzX011bHRQcmVtdWx0aXBsaWVkQWxwaGEgKyBvZmZzZXRdO1xuICAgICAgICAgIFNSQ19DT0xPUiA9IHRoaXMuZ2wuRFNUX0NPTE9SO1xuICAgICAgICAgIERTVF9DT0xPUiA9IHRoaXMuZ2wuT05FX01JTlVTX1NSQ19BTFBIQTtcbiAgICAgICAgICBTUkNfQUxQSEEgPSB0aGlzLmdsLlpFUk87XG4gICAgICAgICAgRFNUX0FMUEhBID0gdGhpcy5nbC5PTkU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0aGlzLmdsLnVzZVByb2dyYW0oc2hhZGVyU2V0LnNoYWRlclByb2dyYW0pO1xuICAgICAgaWYgKGJ1ZmZlckRhdGEudmVydGV4ID09IG51bGwpIHtcbiAgICAgICAgYnVmZmVyRGF0YS52ZXJ0ZXggPSB0aGlzLmdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgfVxuICAgICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJEYXRhLnZlcnRleCk7XG4gICAgICB0aGlzLmdsLmJ1ZmZlckRhdGEodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHZlcnRleEFycmF5LCB0aGlzLmdsLkRZTkFNSUNfRFJBVyk7XG4gICAgICB0aGlzLmdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHNoYWRlclNldC5hdHRyaWJ1dGVQb3NpdGlvbkxvY2F0aW9uKTtcbiAgICAgIHRoaXMuZ2wudmVydGV4QXR0cmliUG9pbnRlcihzaGFkZXJTZXQuYXR0cmlidXRlUG9zaXRpb25Mb2NhdGlvbiwgMiwgdGhpcy5nbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgICAgaWYgKGJ1ZmZlckRhdGEudXYgPT0gbnVsbCkge1xuICAgICAgICBidWZmZXJEYXRhLnV2ID0gdGhpcy5nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyRGF0YS51dik7XG4gICAgICB0aGlzLmdsLmJ1ZmZlckRhdGEodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHV2QXJyYXksIHRoaXMuZ2wuRFlOQU1JQ19EUkFXKTtcbiAgICAgIHRoaXMuZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoc2hhZGVyU2V0LmF0dHJpYnV0ZVRleENvb3JkTG9jYXRpb24pO1xuICAgICAgdGhpcy5nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNoYWRlclNldC5hdHRyaWJ1dGVUZXhDb29yZExvY2F0aW9uLCAyLCB0aGlzLmdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgICBpZiAoY2xpcHBpbmdDb250ZXh0QnVmZmVyRm9yRHJhdyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkUxKTtcbiAgICAgICAgY29uc3QgdGV4ID0gY2xpcHBpbmdDb250ZXh0QnVmZmVyRm9yRHJhdy5nZXRDbGlwcGluZ01hbmFnZXIoKS5nZXRDb2xvckJ1ZmZlcigpO1xuICAgICAgICB0aGlzLmdsLmJpbmRUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGV4KTtcbiAgICAgICAgdGhpcy5nbC51bmlmb3JtMWkoc2hhZGVyU2V0LnNhbXBsZXJUZXh0dXJlMUxvY2F0aW9uLCAxKTtcbiAgICAgICAgdGhpcy5nbC51bmlmb3JtTWF0cml4NGZ2KHNoYWRlclNldC51bmlmb3JtQ2xpcE1hdHJpeExvY2F0aW9uLCBmYWxzZSwgY2xpcHBpbmdDb250ZXh0QnVmZmVyRm9yRHJhdy5fbWF0cml4Rm9yRHJhdy5nZXRBcnJheSgpKTtcbiAgICAgICAgY29uc3QgY2hhbm5lbE5vID0gY2xpcHBpbmdDb250ZXh0QnVmZmVyRm9yRHJhdy5fbGF5b3V0Q2hhbm5lbE5vO1xuICAgICAgICBjb25zdCBjb2xvckNoYW5uZWwgPSBjbGlwcGluZ0NvbnRleHRCdWZmZXJGb3JEcmF3LmdldENsaXBwaW5nTWFuYWdlcigpLmdldENoYW5uZWxGbGFnQXNDb2xvcihjaGFubmVsTm8pO1xuICAgICAgICB0aGlzLmdsLnVuaWZvcm00ZihzaGFkZXJTZXQudW5pZm9ybUNoYW5uZWxGbGFnTG9jYXRpb24sIGNvbG9yQ2hhbm5lbC5SLCBjb2xvckNoYW5uZWwuRywgY29sb3JDaGFubmVsLkIsIGNvbG9yQ2hhbm5lbC5BKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkUwKTtcbiAgICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCB0ZXh0dXJlSWQpO1xuICAgICAgdGhpcy5nbC51bmlmb3JtMWkoc2hhZGVyU2V0LnNhbXBsZXJUZXh0dXJlMExvY2F0aW9uLCAwKTtcbiAgICAgIHRoaXMuZ2wudW5pZm9ybU1hdHJpeDRmdihzaGFkZXJTZXQudW5pZm9ybU1hdHJpeExvY2F0aW9uLCBmYWxzZSwgbWF0cml4NHg0LmdldEFycmF5KCkpO1xuICAgICAgdGhpcy5nbC51bmlmb3JtNGYoc2hhZGVyU2V0LnVuaWZvcm1CYXNlQ29sb3JMb2NhdGlvbiwgYmFzZUNvbG9yLlIsIGJhc2VDb2xvci5HLCBiYXNlQ29sb3IuQiwgYmFzZUNvbG9yLkEpO1xuICAgIH1cbiAgICBpZiAoYnVmZmVyRGF0YS5pbmRleCA9PSBudWxsKSB7XG4gICAgICBidWZmZXJEYXRhLmluZGV4ID0gdGhpcy5nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICB9XG4gICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGJ1ZmZlckRhdGEuaW5kZXgpO1xuICAgIHRoaXMuZ2wuYnVmZmVyRGF0YSh0aGlzLmdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpbmRleEFycmF5LCB0aGlzLmdsLkRZTkFNSUNfRFJBVyk7XG4gICAgdGhpcy5nbC5ibGVuZEZ1bmNTZXBhcmF0ZShTUkNfQ09MT1IsIERTVF9DT0xPUiwgU1JDX0FMUEhBLCBEU1RfQUxQSEEpO1xuICB9XG4gIHJlbGVhc2VTaGFkZXJQcm9ncmFtKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fc2hhZGVyU2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5nbC5kZWxldGVQcm9ncmFtKHRoaXMuX3NoYWRlclNldHNbaV0uc2hhZGVyUHJvZ3JhbSk7XG4gICAgICB0aGlzLl9zaGFkZXJTZXRzW2ldLnNoYWRlclByb2dyYW0gPSAwO1xuICAgIH1cbiAgICB0aGlzLl9zaGFkZXJTZXRzID0gW107XG4gIH1cbiAgZ2VuZXJhdGVTaGFkZXJzKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2hhZGVyQ291bnQ7IGkrKykge1xuICAgICAgdGhpcy5fc2hhZGVyU2V0cy5wdXNoKHt9KTtcbiAgICB9XG4gICAgdGhpcy5fc2hhZGVyU2V0c1swXS5zaGFkZXJQcm9ncmFtID0gdGhpcy5sb2FkU2hhZGVyUHJvZ3JhbSh2ZXJ0ZXhTaGFkZXJTcmNTZXR1cE1hc2ssIGZyYWdtZW50U2hhZGVyU3Jjc2V0dXBNYXNrKTtcbiAgICB0aGlzLl9zaGFkZXJTZXRzWzFdLnNoYWRlclByb2dyYW0gPSB0aGlzLmxvYWRTaGFkZXJQcm9ncmFtKHZlcnRleFNoYWRlclNyYywgZnJhZ21lbnRTaGFkZXJTcmNQcmVtdWx0aXBsaWVkQWxwaGEpO1xuICAgIHRoaXMuX3NoYWRlclNldHNbMl0uc2hhZGVyUHJvZ3JhbSA9IHRoaXMubG9hZFNoYWRlclByb2dyYW0odmVydGV4U2hhZGVyU3JjTWFza2VkLCBmcmFnbWVudFNoYWRlclNyY01hc2tQcmVtdWx0aXBsaWVkQWxwaGEpO1xuICAgIHRoaXMuX3NoYWRlclNldHNbM10uc2hhZGVyUHJvZ3JhbSA9IHRoaXMubG9hZFNoYWRlclByb2dyYW0odmVydGV4U2hhZGVyU3JjTWFza2VkLCBmcmFnbWVudFNoYWRlclNyY01hc2tJbnZlcnRlZFByZW11bHRpcGxpZWRBbHBoYSk7XG4gICAgdGhpcy5fc2hhZGVyU2V0c1s0XS5zaGFkZXJQcm9ncmFtID0gdGhpcy5fc2hhZGVyU2V0c1sxXS5zaGFkZXJQcm9ncmFtO1xuICAgIHRoaXMuX3NoYWRlclNldHNbNV0uc2hhZGVyUHJvZ3JhbSA9IHRoaXMuX3NoYWRlclNldHNbMl0uc2hhZGVyUHJvZ3JhbTtcbiAgICB0aGlzLl9zaGFkZXJTZXRzWzZdLnNoYWRlclByb2dyYW0gPSB0aGlzLl9zaGFkZXJTZXRzWzNdLnNoYWRlclByb2dyYW07XG4gICAgdGhpcy5fc2hhZGVyU2V0c1s3XS5zaGFkZXJQcm9ncmFtID0gdGhpcy5fc2hhZGVyU2V0c1sxXS5zaGFkZXJQcm9ncmFtO1xuICAgIHRoaXMuX3NoYWRlclNldHNbOF0uc2hhZGVyUHJvZ3JhbSA9IHRoaXMuX3NoYWRlclNldHNbMl0uc2hhZGVyUHJvZ3JhbTtcbiAgICB0aGlzLl9zaGFkZXJTZXRzWzldLnNoYWRlclByb2dyYW0gPSB0aGlzLl9zaGFkZXJTZXRzWzNdLnNoYWRlclByb2dyYW07XG4gICAgdGhpcy5fc2hhZGVyU2V0c1swXS5hdHRyaWJ1dGVQb3NpdGlvbkxvY2F0aW9uID0gdGhpcy5nbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl9zaGFkZXJTZXRzWzBdLnNoYWRlclByb2dyYW0sIFwiYV9wb3NpdGlvblwiKTtcbiAgICB0aGlzLl9zaGFkZXJTZXRzWzBdLmF0dHJpYnV0ZVRleENvb3JkTG9jYXRpb24gPSB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3NoYWRlclNldHNbMF0uc2hhZGVyUHJvZ3JhbSwgXCJhX3RleENvb3JkXCIpO1xuICAgIHRoaXMuX3NoYWRlclNldHNbMF0uc2FtcGxlclRleHR1cmUwTG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9zaGFkZXJTZXRzWzBdLnNoYWRlclByb2dyYW0sIFwic190ZXh0dXJlMFwiKTtcbiAgICB0aGlzLl9zaGFkZXJTZXRzWzBdLnVuaWZvcm1DbGlwTWF0cml4TG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9zaGFkZXJTZXRzWzBdLnNoYWRlclByb2dyYW0sIFwidV9jbGlwTWF0cml4XCIpO1xuICAgIHRoaXMuX3NoYWRlclNldHNbMF0udW5pZm9ybUNoYW5uZWxGbGFnTG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9zaGFkZXJTZXRzWzBdLnNoYWRlclByb2dyYW0sIFwidV9jaGFubmVsRmxhZ1wiKTtcbiAgICB0aGlzLl9zaGFkZXJTZXRzWzBdLnVuaWZvcm1CYXNlQ29sb3JMb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3NoYWRlclNldHNbMF0uc2hhZGVyUHJvZ3JhbSwgXCJ1X2Jhc2VDb2xvclwiKTtcbiAgICB0aGlzLl9zaGFkZXJTZXRzWzFdLmF0dHJpYnV0ZVBvc2l0aW9uTG9jYXRpb24gPSB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3NoYWRlclNldHNbMV0uc2hhZGVyUHJvZ3JhbSwgXCJhX3Bvc2l0aW9uXCIpO1xuICAgIHRoaXMuX3NoYWRlclNldHNbMV0uYXR0cmlidXRlVGV4Q29vcmRMb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fc2hhZGVyU2V0c1sxXS5zaGFkZXJQcm9ncmFtLCBcImFfdGV4Q29vcmRcIik7XG4gICAgdGhpcy5fc2hhZGVyU2V0c1sxXS5zYW1wbGVyVGV4dHVyZTBMb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3NoYWRlclNldHNbMV0uc2hhZGVyUHJvZ3JhbSwgXCJzX3RleHR1cmUwXCIpO1xuICAgIHRoaXMuX3NoYWRlclNldHNbMV0udW5pZm9ybU1hdHJpeExvY2F0aW9uID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fc2hhZGVyU2V0c1sxXS5zaGFkZXJQcm9ncmFtLCBcInVfbWF0cml4XCIpO1xuICAgIHRoaXMuX3NoYWRlclNldHNbMV0udW5pZm9ybUJhc2VDb2xvckxvY2F0aW9uID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fc2hhZGVyU2V0c1sxXS5zaGFkZXJQcm9ncmFtLCBcInVfYmFzZUNvbG9yXCIpO1xuICAgIHRoaXMuX3NoYWRlclNldHNbMl0uYXR0cmlidXRlUG9zaXRpb25Mb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fc2hhZGVyU2V0c1syXS5zaGFkZXJQcm9ncmFtLCBcImFfcG9zaXRpb25cIik7XG4gICAgdGhpcy5fc2hhZGVyU2V0c1syXS5hdHRyaWJ1dGVUZXhDb29yZExvY2F0aW9uID0gdGhpcy5nbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl9zaGFkZXJTZXRzWzJdLnNoYWRlclByb2dyYW0sIFwiYV90ZXhDb29yZFwiKTtcbiAgICB0aGlzLl9zaGFkZXJTZXRzWzJdLnNhbXBsZXJUZXh0dXJlMExvY2F0aW9uID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fc2hhZGVyU2V0c1syXS5zaGFkZXJQcm9ncmFtLCBcInNfdGV4dHVyZTBcIik7XG4gICAgdGhpcy5fc2hhZGVyU2V0c1syXS5zYW1wbGVyVGV4dHVyZTFMb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3NoYWRlclNldHNbMl0uc2hhZGVyUHJvZ3JhbSwgXCJzX3RleHR1cmUxXCIpO1xuICAgIHRoaXMuX3NoYWRlclNldHNbMl0udW5pZm9ybU1hdHJpeExvY2F0aW9uID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fc2hhZGVyU2V0c1syXS5zaGFkZXJQcm9ncmFtLCBcInVfbWF0cml4XCIpO1xuICAgIHRoaXMuX3NoYWRlclNldHNbMl0udW5pZm9ybUNsaXBNYXRyaXhMb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3NoYWRlclNldHNbMl0uc2hhZGVyUHJvZ3JhbSwgXCJ1X2NsaXBNYXRyaXhcIik7XG4gICAgdGhpcy5fc2hhZGVyU2V0c1syXS51bmlmb3JtQ2hhbm5lbEZsYWdMb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3NoYWRlclNldHNbMl0uc2hhZGVyUHJvZ3JhbSwgXCJ1X2NoYW5uZWxGbGFnXCIpO1xuICAgIHRoaXMuX3NoYWRlclNldHNbMl0udW5pZm9ybUJhc2VDb2xvckxvY2F0aW9uID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fc2hhZGVyU2V0c1syXS5zaGFkZXJQcm9ncmFtLCBcInVfYmFzZUNvbG9yXCIpO1xuICAgIHRoaXMuX3NoYWRlclNldHNbM10uYXR0cmlidXRlUG9zaXRpb25Mb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fc2hhZGVyU2V0c1szXS5zaGFkZXJQcm9ncmFtLCBcImFfcG9zaXRpb25cIik7XG4gICAgdGhpcy5fc2hhZGVyU2V0c1szXS5hdHRyaWJ1dGVUZXhDb29yZExvY2F0aW9uID0gdGhpcy5nbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl9zaGFkZXJTZXRzWzNdLnNoYWRlclByb2dyYW0sIFwiYV90ZXhDb29yZFwiKTtcbiAgICB0aGlzLl9zaGFkZXJTZXRzWzNdLnNhbXBsZXJUZXh0dXJlMExvY2F0aW9uID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fc2hhZGVyU2V0c1szXS5zaGFkZXJQcm9ncmFtLCBcInNfdGV4dHVyZTBcIik7XG4gICAgdGhpcy5fc2hhZGVyU2V0c1szXS5zYW1wbGVyVGV4dHVyZTFMb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3NoYWRlclNldHNbM10uc2hhZGVyUHJvZ3JhbSwgXCJzX3RleHR1cmUxXCIpO1xuICAgIHRoaXMuX3NoYWRlclNldHNbM10udW5pZm9ybU1hdHJpeExvY2F0aW9uID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fc2hhZGVyU2V0c1szXS5zaGFkZXJQcm9ncmFtLCBcInVfbWF0cml4XCIpO1xuICAgIHRoaXMuX3NoYWRlclNldHNbM10udW5pZm9ybUNsaXBNYXRyaXhMb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3NoYWRlclNldHNbM10uc2hhZGVyUHJvZ3JhbSwgXCJ1X2NsaXBNYXRyaXhcIik7XG4gICAgdGhpcy5fc2hhZGVyU2V0c1szXS51bmlmb3JtQ2hhbm5lbEZsYWdMb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3NoYWRlclNldHNbM10uc2hhZGVyUHJvZ3JhbSwgXCJ1X2NoYW5uZWxGbGFnXCIpO1xuICAgIHRoaXMuX3NoYWRlclNldHNbM10udW5pZm9ybUJhc2VDb2xvckxvY2F0aW9uID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fc2hhZGVyU2V0c1szXS5zaGFkZXJQcm9ncmFtLCBcInVfYmFzZUNvbG9yXCIpO1xuICAgIHRoaXMuX3NoYWRlclNldHNbNF0uYXR0cmlidXRlUG9zaXRpb25Mb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fc2hhZGVyU2V0c1s0XS5zaGFkZXJQcm9ncmFtLCBcImFfcG9zaXRpb25cIik7XG4gICAgdGhpcy5fc2hhZGVyU2V0c1s0XS5hdHRyaWJ1dGVUZXhDb29yZExvY2F0aW9uID0gdGhpcy5nbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl9zaGFkZXJTZXRzWzRdLnNoYWRlclByb2dyYW0sIFwiYV90ZXhDb29yZFwiKTtcbiAgICB0aGlzLl9zaGFkZXJTZXRzWzRdLnNhbXBsZXJUZXh0dXJlMExvY2F0aW9uID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fc2hhZGVyU2V0c1s0XS5zaGFkZXJQcm9ncmFtLCBcInNfdGV4dHVyZTBcIik7XG4gICAgdGhpcy5fc2hhZGVyU2V0c1s0XS51bmlmb3JtTWF0cml4TG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9zaGFkZXJTZXRzWzRdLnNoYWRlclByb2dyYW0sIFwidV9tYXRyaXhcIik7XG4gICAgdGhpcy5fc2hhZGVyU2V0c1s0XS51bmlmb3JtQmFzZUNvbG9yTG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9zaGFkZXJTZXRzWzRdLnNoYWRlclByb2dyYW0sIFwidV9iYXNlQ29sb3JcIik7XG4gICAgdGhpcy5fc2hhZGVyU2V0c1s1XS5hdHRyaWJ1dGVQb3NpdGlvbkxvY2F0aW9uID0gdGhpcy5nbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl9zaGFkZXJTZXRzWzVdLnNoYWRlclByb2dyYW0sIFwiYV9wb3NpdGlvblwiKTtcbiAgICB0aGlzLl9zaGFkZXJTZXRzWzVdLmF0dHJpYnV0ZVRleENvb3JkTG9jYXRpb24gPSB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3NoYWRlclNldHNbNV0uc2hhZGVyUHJvZ3JhbSwgXCJhX3RleENvb3JkXCIpO1xuICAgIHRoaXMuX3NoYWRlclNldHNbNV0uc2FtcGxlclRleHR1cmUwTG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9zaGFkZXJTZXRzWzVdLnNoYWRlclByb2dyYW0sIFwic190ZXh0dXJlMFwiKTtcbiAgICB0aGlzLl9zaGFkZXJTZXRzWzVdLnNhbXBsZXJUZXh0dXJlMUxvY2F0aW9uID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fc2hhZGVyU2V0c1s1XS5zaGFkZXJQcm9ncmFtLCBcInNfdGV4dHVyZTFcIik7XG4gICAgdGhpcy5fc2hhZGVyU2V0c1s1XS51bmlmb3JtTWF0cml4TG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9zaGFkZXJTZXRzWzVdLnNoYWRlclByb2dyYW0sIFwidV9tYXRyaXhcIik7XG4gICAgdGhpcy5fc2hhZGVyU2V0c1s1XS51bmlmb3JtQ2xpcE1hdHJpeExvY2F0aW9uID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fc2hhZGVyU2V0c1s1XS5zaGFkZXJQcm9ncmFtLCBcInVfY2xpcE1hdHJpeFwiKTtcbiAgICB0aGlzLl9zaGFkZXJTZXRzWzVdLnVuaWZvcm1DaGFubmVsRmxhZ0xvY2F0aW9uID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fc2hhZGVyU2V0c1s1XS5zaGFkZXJQcm9ncmFtLCBcInVfY2hhbm5lbEZsYWdcIik7XG4gICAgdGhpcy5fc2hhZGVyU2V0c1s1XS51bmlmb3JtQmFzZUNvbG9yTG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9zaGFkZXJTZXRzWzVdLnNoYWRlclByb2dyYW0sIFwidV9iYXNlQ29sb3JcIik7XG4gICAgdGhpcy5fc2hhZGVyU2V0c1s2XS5hdHRyaWJ1dGVQb3NpdGlvbkxvY2F0aW9uID0gdGhpcy5nbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl9zaGFkZXJTZXRzWzZdLnNoYWRlclByb2dyYW0sIFwiYV9wb3NpdGlvblwiKTtcbiAgICB0aGlzLl9zaGFkZXJTZXRzWzZdLmF0dHJpYnV0ZVRleENvb3JkTG9jYXRpb24gPSB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3NoYWRlclNldHNbNl0uc2hhZGVyUHJvZ3JhbSwgXCJhX3RleENvb3JkXCIpO1xuICAgIHRoaXMuX3NoYWRlclNldHNbNl0uc2FtcGxlclRleHR1cmUwTG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9zaGFkZXJTZXRzWzZdLnNoYWRlclByb2dyYW0sIFwic190ZXh0dXJlMFwiKTtcbiAgICB0aGlzLl9zaGFkZXJTZXRzWzZdLnNhbXBsZXJUZXh0dXJlMUxvY2F0aW9uID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fc2hhZGVyU2V0c1s2XS5zaGFkZXJQcm9ncmFtLCBcInNfdGV4dHVyZTFcIik7XG4gICAgdGhpcy5fc2hhZGVyU2V0c1s2XS51bmlmb3JtTWF0cml4TG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9zaGFkZXJTZXRzWzZdLnNoYWRlclByb2dyYW0sIFwidV9tYXRyaXhcIik7XG4gICAgdGhpcy5fc2hhZGVyU2V0c1s2XS51bmlmb3JtQ2xpcE1hdHJpeExvY2F0aW9uID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fc2hhZGVyU2V0c1s2XS5zaGFkZXJQcm9ncmFtLCBcInVfY2xpcE1hdHJpeFwiKTtcbiAgICB0aGlzLl9zaGFkZXJTZXRzWzZdLnVuaWZvcm1DaGFubmVsRmxhZ0xvY2F0aW9uID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fc2hhZGVyU2V0c1s2XS5zaGFkZXJQcm9ncmFtLCBcInVfY2hhbm5lbEZsYWdcIik7XG4gICAgdGhpcy5fc2hhZGVyU2V0c1s2XS51bmlmb3JtQmFzZUNvbG9yTG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9zaGFkZXJTZXRzWzZdLnNoYWRlclByb2dyYW0sIFwidV9iYXNlQ29sb3JcIik7XG4gICAgdGhpcy5fc2hhZGVyU2V0c1s3XS5hdHRyaWJ1dGVQb3NpdGlvbkxvY2F0aW9uID0gdGhpcy5nbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl9zaGFkZXJTZXRzWzddLnNoYWRlclByb2dyYW0sIFwiYV9wb3NpdGlvblwiKTtcbiAgICB0aGlzLl9zaGFkZXJTZXRzWzddLmF0dHJpYnV0ZVRleENvb3JkTG9jYXRpb24gPSB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3NoYWRlclNldHNbN10uc2hhZGVyUHJvZ3JhbSwgXCJhX3RleENvb3JkXCIpO1xuICAgIHRoaXMuX3NoYWRlclNldHNbN10uc2FtcGxlclRleHR1cmUwTG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9zaGFkZXJTZXRzWzddLnNoYWRlclByb2dyYW0sIFwic190ZXh0dXJlMFwiKTtcbiAgICB0aGlzLl9zaGFkZXJTZXRzWzddLnVuaWZvcm1NYXRyaXhMb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3NoYWRlclNldHNbN10uc2hhZGVyUHJvZ3JhbSwgXCJ1X21hdHJpeFwiKTtcbiAgICB0aGlzLl9zaGFkZXJTZXRzWzddLnVuaWZvcm1CYXNlQ29sb3JMb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3NoYWRlclNldHNbN10uc2hhZGVyUHJvZ3JhbSwgXCJ1X2Jhc2VDb2xvclwiKTtcbiAgICB0aGlzLl9zaGFkZXJTZXRzWzhdLmF0dHJpYnV0ZVBvc2l0aW9uTG9jYXRpb24gPSB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3NoYWRlclNldHNbOF0uc2hhZGVyUHJvZ3JhbSwgXCJhX3Bvc2l0aW9uXCIpO1xuICAgIHRoaXMuX3NoYWRlclNldHNbOF0uYXR0cmlidXRlVGV4Q29vcmRMb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fc2hhZGVyU2V0c1s4XS5zaGFkZXJQcm9ncmFtLCBcImFfdGV4Q29vcmRcIik7XG4gICAgdGhpcy5fc2hhZGVyU2V0c1s4XS5zYW1wbGVyVGV4dHVyZTBMb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3NoYWRlclNldHNbOF0uc2hhZGVyUHJvZ3JhbSwgXCJzX3RleHR1cmUwXCIpO1xuICAgIHRoaXMuX3NoYWRlclNldHNbOF0uc2FtcGxlclRleHR1cmUxTG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9zaGFkZXJTZXRzWzhdLnNoYWRlclByb2dyYW0sIFwic190ZXh0dXJlMVwiKTtcbiAgICB0aGlzLl9zaGFkZXJTZXRzWzhdLnVuaWZvcm1NYXRyaXhMb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3NoYWRlclNldHNbOF0uc2hhZGVyUHJvZ3JhbSwgXCJ1X21hdHJpeFwiKTtcbiAgICB0aGlzLl9zaGFkZXJTZXRzWzhdLnVuaWZvcm1DbGlwTWF0cml4TG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9zaGFkZXJTZXRzWzhdLnNoYWRlclByb2dyYW0sIFwidV9jbGlwTWF0cml4XCIpO1xuICAgIHRoaXMuX3NoYWRlclNldHNbOF0udW5pZm9ybUNoYW5uZWxGbGFnTG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9zaGFkZXJTZXRzWzhdLnNoYWRlclByb2dyYW0sIFwidV9jaGFubmVsRmxhZ1wiKTtcbiAgICB0aGlzLl9zaGFkZXJTZXRzWzhdLnVuaWZvcm1CYXNlQ29sb3JMb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3NoYWRlclNldHNbOF0uc2hhZGVyUHJvZ3JhbSwgXCJ1X2Jhc2VDb2xvclwiKTtcbiAgICB0aGlzLl9zaGFkZXJTZXRzWzldLmF0dHJpYnV0ZVBvc2l0aW9uTG9jYXRpb24gPSB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3NoYWRlclNldHNbOV0uc2hhZGVyUHJvZ3JhbSwgXCJhX3Bvc2l0aW9uXCIpO1xuICAgIHRoaXMuX3NoYWRlclNldHNbOV0uYXR0cmlidXRlVGV4Q29vcmRMb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fc2hhZGVyU2V0c1s5XS5zaGFkZXJQcm9ncmFtLCBcImFfdGV4Q29vcmRcIik7XG4gICAgdGhpcy5fc2hhZGVyU2V0c1s5XS5zYW1wbGVyVGV4dHVyZTBMb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3NoYWRlclNldHNbOV0uc2hhZGVyUHJvZ3JhbSwgXCJzX3RleHR1cmUwXCIpO1xuICAgIHRoaXMuX3NoYWRlclNldHNbOV0uc2FtcGxlclRleHR1cmUxTG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9zaGFkZXJTZXRzWzldLnNoYWRlclByb2dyYW0sIFwic190ZXh0dXJlMVwiKTtcbiAgICB0aGlzLl9zaGFkZXJTZXRzWzldLnVuaWZvcm1NYXRyaXhMb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3NoYWRlclNldHNbOV0uc2hhZGVyUHJvZ3JhbSwgXCJ1X21hdHJpeFwiKTtcbiAgICB0aGlzLl9zaGFkZXJTZXRzWzldLnVuaWZvcm1DbGlwTWF0cml4TG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9zaGFkZXJTZXRzWzldLnNoYWRlclByb2dyYW0sIFwidV9jbGlwTWF0cml4XCIpO1xuICAgIHRoaXMuX3NoYWRlclNldHNbOV0udW5pZm9ybUNoYW5uZWxGbGFnTG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9zaGFkZXJTZXRzWzldLnNoYWRlclByb2dyYW0sIFwidV9jaGFubmVsRmxhZ1wiKTtcbiAgICB0aGlzLl9zaGFkZXJTZXRzWzldLnVuaWZvcm1CYXNlQ29sb3JMb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3NoYWRlclNldHNbOV0uc2hhZGVyUHJvZ3JhbSwgXCJ1X2Jhc2VDb2xvclwiKTtcbiAgfVxuICBsb2FkU2hhZGVyUHJvZ3JhbSh2ZXJ0ZXhTaGFkZXJTb3VyY2UsIGZyYWdtZW50U2hhZGVyU291cmNlKSB7XG4gICAgbGV0IHNoYWRlclByb2dyYW0gPSB0aGlzLmdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICBsZXQgdmVydFNoYWRlciA9IHRoaXMuY29tcGlsZVNoYWRlclNvdXJjZSh0aGlzLmdsLlZFUlRFWF9TSEFERVIsIHZlcnRleFNoYWRlclNvdXJjZSk7XG4gICAgaWYgKCF2ZXJ0U2hhZGVyKSB7XG4gICAgICBDdWJpc21Mb2dFcnJvcihcIlZlcnRleCBzaGFkZXIgY29tcGlsZSBlcnJvciFcIik7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgbGV0IGZyYWdTaGFkZXIgPSB0aGlzLmNvbXBpbGVTaGFkZXJTb3VyY2UodGhpcy5nbC5GUkFHTUVOVF9TSEFERVIsIGZyYWdtZW50U2hhZGVyU291cmNlKTtcbiAgICBpZiAoIWZyYWdTaGFkZXIpIHtcbiAgICAgIEN1YmlzbUxvZ0Vycm9yKFwiVmVydGV4IHNoYWRlciBjb21waWxlIGVycm9yIVwiKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICB0aGlzLmdsLmF0dGFjaFNoYWRlcihzaGFkZXJQcm9ncmFtLCB2ZXJ0U2hhZGVyKTtcbiAgICB0aGlzLmdsLmF0dGFjaFNoYWRlcihzaGFkZXJQcm9ncmFtLCBmcmFnU2hhZGVyKTtcbiAgICB0aGlzLmdsLmxpbmtQcm9ncmFtKHNoYWRlclByb2dyYW0pO1xuICAgIGNvbnN0IGxpbmtTdGF0dXMgPSB0aGlzLmdsLmdldFByb2dyYW1QYXJhbWV0ZXIoc2hhZGVyUHJvZ3JhbSwgdGhpcy5nbC5MSU5LX1NUQVRVUyk7XG4gICAgaWYgKCFsaW5rU3RhdHVzKSB7XG4gICAgICBDdWJpc21Mb2dFcnJvcihcIkZhaWxlZCB0byBsaW5rIHByb2dyYW06IHswfVwiLCBzaGFkZXJQcm9ncmFtKTtcbiAgICAgIHRoaXMuZ2wuZGVsZXRlU2hhZGVyKHZlcnRTaGFkZXIpO1xuICAgICAgdGhpcy5nbC5kZWxldGVTaGFkZXIoZnJhZ1NoYWRlcik7XG4gICAgICBpZiAoc2hhZGVyUHJvZ3JhbSkge1xuICAgICAgICB0aGlzLmdsLmRlbGV0ZVByb2dyYW0oc2hhZGVyUHJvZ3JhbSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgdGhpcy5nbC5kZWxldGVTaGFkZXIodmVydFNoYWRlcik7XG4gICAgdGhpcy5nbC5kZWxldGVTaGFkZXIoZnJhZ1NoYWRlcik7XG4gICAgcmV0dXJuIHNoYWRlclByb2dyYW07XG4gIH1cbiAgY29tcGlsZVNoYWRlclNvdXJjZShzaGFkZXJUeXBlLCBzaGFkZXJTb3VyY2UpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBzaGFkZXJTb3VyY2U7XG4gICAgY29uc3Qgc2hhZGVyID0gdGhpcy5nbC5jcmVhdGVTaGFkZXIoc2hhZGVyVHlwZSk7XG4gICAgdGhpcy5nbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpO1xuICAgIHRoaXMuZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICAgIGlmICghc2hhZGVyKSB7XG4gICAgICBjb25zdCBsb2cgPSB0aGlzLmdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKTtcbiAgICAgIEN1YmlzbUxvZ0Vycm9yKFwiU2hhZGVyIGNvbXBpbGUgbG9nOiB7MH0gXCIsIGxvZyk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXR1cyA9IHRoaXMuZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgdGhpcy5nbC5DT01QSUxFX1NUQVRVUyk7XG4gICAgaWYgKCFzdGF0dXMpIHtcbiAgICAgIHRoaXMuZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWRlcjtcbiAgfVxuICBzZXRHbChnbCkge1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgfVxufVxudmFyIFNoYWRlck5hbWVzID0gLyogQF9fUFVSRV9fICovICgoU2hhZGVyTmFtZXMyKSA9PiB7XG4gIFNoYWRlck5hbWVzMltTaGFkZXJOYW1lczJbXCJTaGFkZXJOYW1lc19TZXR1cE1hc2tcIl0gPSAwXSA9IFwiU2hhZGVyTmFtZXNfU2V0dXBNYXNrXCI7XG4gIFNoYWRlck5hbWVzMltTaGFkZXJOYW1lczJbXCJTaGFkZXJOYW1lc19Ob3JtYWxQcmVtdWx0aXBsaWVkQWxwaGFcIl0gPSAxXSA9IFwiU2hhZGVyTmFtZXNfTm9ybWFsUHJlbXVsdGlwbGllZEFscGhhXCI7XG4gIFNoYWRlck5hbWVzMltTaGFkZXJOYW1lczJbXCJTaGFkZXJOYW1lc19Ob3JtYWxNYXNrZWRQcmVtdWx0aXBsaWVkQWxwaGFcIl0gPSAyXSA9IFwiU2hhZGVyTmFtZXNfTm9ybWFsTWFza2VkUHJlbXVsdGlwbGllZEFscGhhXCI7XG4gIFNoYWRlck5hbWVzMltTaGFkZXJOYW1lczJbXCJTaGFkZXJOYW1lc19Ob21yYWxNYXNrZWRJbnZlcnRlZFByZW11bHRpcGxpZWRBbHBoYVwiXSA9IDNdID0gXCJTaGFkZXJOYW1lc19Ob21yYWxNYXNrZWRJbnZlcnRlZFByZW11bHRpcGxpZWRBbHBoYVwiO1xuICBTaGFkZXJOYW1lczJbU2hhZGVyTmFtZXMyW1wiU2hhZGVyTmFtZXNfQWRkUHJlbXVsdGlwbGllZEFscGhhXCJdID0gNF0gPSBcIlNoYWRlck5hbWVzX0FkZFByZW11bHRpcGxpZWRBbHBoYVwiO1xuICBTaGFkZXJOYW1lczJbU2hhZGVyTmFtZXMyW1wiU2hhZGVyTmFtZXNfQWRkTWFza2VkUHJlbXVsdGlwbGllZEFscGhhXCJdID0gNV0gPSBcIlNoYWRlck5hbWVzX0FkZE1hc2tlZFByZW11bHRpcGxpZWRBbHBoYVwiO1xuICBTaGFkZXJOYW1lczJbU2hhZGVyTmFtZXMyW1wiU2hhZGVyTmFtZXNfQWRkTWFza2VkUHJlbXVsdGlwbGllZEFscGhhSW52ZXJ0ZWRcIl0gPSA2XSA9IFwiU2hhZGVyTmFtZXNfQWRkTWFza2VkUHJlbXVsdGlwbGllZEFscGhhSW52ZXJ0ZWRcIjtcbiAgU2hhZGVyTmFtZXMyW1NoYWRlck5hbWVzMltcIlNoYWRlck5hbWVzX011bHRQcmVtdWx0aXBsaWVkQWxwaGFcIl0gPSA3XSA9IFwiU2hhZGVyTmFtZXNfTXVsdFByZW11bHRpcGxpZWRBbHBoYVwiO1xuICBTaGFkZXJOYW1lczJbU2hhZGVyTmFtZXMyW1wiU2hhZGVyTmFtZXNfTXVsdE1hc2tlZFByZW11bHRpcGxpZWRBbHBoYVwiXSA9IDhdID0gXCJTaGFkZXJOYW1lc19NdWx0TWFza2VkUHJlbXVsdGlwbGllZEFscGhhXCI7XG4gIFNoYWRlck5hbWVzMltTaGFkZXJOYW1lczJbXCJTaGFkZXJOYW1lc19NdWx0TWFza2VkUHJlbXVsdGlwbGllZEFscGhhSW52ZXJ0ZWRcIl0gPSA5XSA9IFwiU2hhZGVyTmFtZXNfTXVsdE1hc2tlZFByZW11bHRpcGxpZWRBbHBoYUludmVydGVkXCI7XG4gIHJldHVybiBTaGFkZXJOYW1lczI7XG59KShTaGFkZXJOYW1lcyB8fCB7fSk7XG5jb25zdCB2ZXJ0ZXhTaGFkZXJTcmNTZXR1cE1hc2sgPSBcImF0dHJpYnV0ZSB2ZWM0ICAgICBhX3Bvc2l0aW9uO2F0dHJpYnV0ZSB2ZWMyICAgICBhX3RleENvb3JkO3ZhcnlpbmcgdmVjMiAgICAgICB2X3RleENvb3JkO3ZhcnlpbmcgdmVjNCAgICAgICB2X215UG9zO3VuaWZvcm0gbWF0NCAgICAgICB1X2NsaXBNYXRyaXg7dm9pZCBtYWluKCl7ICAgZ2xfUG9zaXRpb24gPSB1X2NsaXBNYXRyaXggKiBhX3Bvc2l0aW9uOyAgIHZfbXlQb3MgPSB1X2NsaXBNYXRyaXggKiBhX3Bvc2l0aW9uOyAgIHZfdGV4Q29vcmQgPSBhX3RleENvb3JkOyAgIHZfdGV4Q29vcmQueSA9IDEuMCAtIHZfdGV4Q29vcmQueTt9XCI7XG5jb25zdCBmcmFnbWVudFNoYWRlclNyY3NldHVwTWFzayA9IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7dmFyeWluZyB2ZWMyICAgICAgIHZfdGV4Q29vcmQ7dmFyeWluZyB2ZWM0ICAgICAgIHZfbXlQb3M7dW5pZm9ybSB2ZWM0ICAgICAgIHVfYmFzZUNvbG9yO3VuaWZvcm0gdmVjNCAgICAgICB1X2NoYW5uZWxGbGFnO3VuaWZvcm0gc2FtcGxlcjJEICBzX3RleHR1cmUwO3ZvaWQgbWFpbigpeyAgIGZsb2F0IGlzSW5zaWRlID0gICAgICAgIHN0ZXAodV9iYXNlQ29sb3IueCwgdl9teVBvcy54L3ZfbXlQb3MudykgICAgICAgKiBzdGVwKHVfYmFzZUNvbG9yLnksIHZfbXlQb3MueS92X215UG9zLncpICAgICAgICogc3RlcCh2X215UG9zLngvdl9teVBvcy53LCB1X2Jhc2VDb2xvci56KSAgICAgICAqIHN0ZXAodl9teVBvcy55L3ZfbXlQb3MudywgdV9iYXNlQ29sb3Iudyk7ICAgZ2xfRnJhZ0NvbG9yID0gdV9jaGFubmVsRmxhZyAqIHRleHR1cmUyRChzX3RleHR1cmUwLCB2X3RleENvb3JkKS5hICogaXNJbnNpZGU7fVwiO1xuY29uc3QgdmVydGV4U2hhZGVyU3JjID0gXCJhdHRyaWJ1dGUgdmVjNCAgICAgYV9wb3NpdGlvbjthdHRyaWJ1dGUgdmVjMiAgICAgYV90ZXhDb29yZDt2YXJ5aW5nIHZlYzIgICAgICAgdl90ZXhDb29yZDt1bmlmb3JtIG1hdDQgICAgICAgdV9tYXRyaXg7dm9pZCBtYWluKCl7ICAgZ2xfUG9zaXRpb24gPSB1X21hdHJpeCAqIGFfcG9zaXRpb247ICAgdl90ZXhDb29yZCA9IGFfdGV4Q29vcmQ7ICAgdl90ZXhDb29yZC55ID0gMS4wIC0gdl90ZXhDb29yZC55O31cIjtcbmNvbnN0IHZlcnRleFNoYWRlclNyY01hc2tlZCA9IFwiYXR0cmlidXRlIHZlYzQgICAgIGFfcG9zaXRpb247YXR0cmlidXRlIHZlYzIgICAgIGFfdGV4Q29vcmQ7dmFyeWluZyB2ZWMyICAgICAgIHZfdGV4Q29vcmQ7dmFyeWluZyB2ZWM0ICAgICAgIHZfY2xpcFBvczt1bmlmb3JtIG1hdDQgICAgICAgdV9tYXRyaXg7dW5pZm9ybSBtYXQ0ICAgICAgIHVfY2xpcE1hdHJpeDt2b2lkIG1haW4oKXsgICBnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogYV9wb3NpdGlvbjsgICB2X2NsaXBQb3MgPSB1X2NsaXBNYXRyaXggKiBhX3Bvc2l0aW9uOyAgIHZfdGV4Q29vcmQgPSBhX3RleENvb3JkOyAgIHZfdGV4Q29vcmQueSA9IDEuMCAtIHZfdGV4Q29vcmQueTt9XCI7XG5jb25zdCBmcmFnbWVudFNoYWRlclNyY1ByZW11bHRpcGxpZWRBbHBoYSA9IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7dmFyeWluZyB2ZWMyICAgICAgIHZfdGV4Q29vcmQ7dW5pZm9ybSB2ZWM0ICAgICAgIHVfYmFzZUNvbG9yO3VuaWZvcm0gc2FtcGxlcjJEICBzX3RleHR1cmUwO3ZvaWQgbWFpbigpeyAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRChzX3RleHR1cmUwICwgdl90ZXhDb29yZCkgKiB1X2Jhc2VDb2xvcjt9XCI7XG5jb25zdCBmcmFnbWVudFNoYWRlclNyY01hc2tQcmVtdWx0aXBsaWVkQWxwaGEgPSBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O3ZhcnlpbmcgdmVjMiAgICAgICB2X3RleENvb3JkO3ZhcnlpbmcgdmVjNCAgICAgICB2X2NsaXBQb3M7dW5pZm9ybSB2ZWM0ICAgICAgIHVfYmFzZUNvbG9yO3VuaWZvcm0gdmVjNCAgICAgICB1X2NoYW5uZWxGbGFnO3VuaWZvcm0gc2FtcGxlcjJEICBzX3RleHR1cmUwO3VuaWZvcm0gc2FtcGxlcjJEICBzX3RleHR1cmUxO3ZvaWQgbWFpbigpeyAgIHZlYzQgY29sX2Zvcm1hc2sgPSB0ZXh0dXJlMkQoc190ZXh0dXJlMCAsIHZfdGV4Q29vcmQpICogdV9iYXNlQ29sb3I7ICAgdmVjNCBjbGlwTWFzayA9ICgxLjAgLSB0ZXh0dXJlMkQoc190ZXh0dXJlMSwgdl9jbGlwUG9zLnh5IC8gdl9jbGlwUG9zLncpKSAqIHVfY2hhbm5lbEZsYWc7ICAgZmxvYXQgbWFza1ZhbCA9IGNsaXBNYXNrLnIgKyBjbGlwTWFzay5nICsgY2xpcE1hc2suYiArIGNsaXBNYXNrLmE7ICAgY29sX2Zvcm1hc2sgPSBjb2xfZm9ybWFzayAqIG1hc2tWYWw7ICAgZ2xfRnJhZ0NvbG9yID0gY29sX2Zvcm1hc2s7fVwiO1xuY29uc3QgZnJhZ21lbnRTaGFkZXJTcmNNYXNrSW52ZXJ0ZWRQcmVtdWx0aXBsaWVkQWxwaGEgPSBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O3ZhcnlpbmcgdmVjMiB2X3RleENvb3JkO3ZhcnlpbmcgdmVjNCB2X2NsaXBQb3M7dW5pZm9ybSBzYW1wbGVyMkQgc190ZXh0dXJlMDt1bmlmb3JtIHNhbXBsZXIyRCBzX3RleHR1cmUxO3VuaWZvcm0gdmVjNCB1X2NoYW5uZWxGbGFnO3VuaWZvcm0gdmVjNCB1X2Jhc2VDb2xvcjt2b2lkIG1haW4oKXt2ZWM0IGNvbF9mb3JtYXNrID0gdGV4dHVyZTJEKHNfdGV4dHVyZTAsIHZfdGV4Q29vcmQpICogdV9iYXNlQ29sb3I7dmVjNCBjbGlwTWFzayA9ICgxLjAgLSB0ZXh0dXJlMkQoc190ZXh0dXJlMSwgdl9jbGlwUG9zLnh5IC8gdl9jbGlwUG9zLncpKSAqIHVfY2hhbm5lbEZsYWc7ZmxvYXQgbWFza1ZhbCA9IGNsaXBNYXNrLnIgKyBjbGlwTWFzay5nICsgY2xpcE1hc2suYiArIGNsaXBNYXNrLmE7Y29sX2Zvcm1hc2sgPSBjb2xfZm9ybWFzayAqICgxLjAgLSBtYXNrVmFsKTtnbF9GcmFnQ29sb3IgPSBjb2xfZm9ybWFzazt9XCI7XG5jbGFzcyBDdWJpc21SZW5kZXJlcl9XZWJHTCBleHRlbmRzIEN1YmlzbVJlbmRlcmVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9jbGlwcGluZ0NvbnRleHRCdWZmZXJGb3JNYXNrID0gbnVsbDtcbiAgICB0aGlzLl9jbGlwcGluZ0NvbnRleHRCdWZmZXJGb3JEcmF3ID0gbnVsbDtcbiAgICB0aGlzLl9jbGlwcGluZ01hbmFnZXIgPSBuZXcgQ3ViaXNtQ2xpcHBpbmdNYW5hZ2VyX1dlYkdMKCk7XG4gICAgdGhpcy5maXJzdERyYXcgPSB0cnVlO1xuICAgIHRoaXMuX3RleHR1cmVzID0ge307XG4gICAgdGhpcy5fc29ydGVkRHJhd2FibGVJbmRleExpc3QgPSBbXTtcbiAgICB0aGlzLl9idWZmZXJEYXRhID0ge1xuICAgICAgdmVydGV4OiBudWxsLFxuICAgICAgdXY6IG51bGwsXG4gICAgICBpbmRleDogbnVsbFxuICAgIH07XG4gIH1cbiAgaW5pdGlhbGl6ZShtb2RlbCkge1xuICAgIGlmIChtb2RlbC5pc1VzaW5nTWFza2luZygpKSB7XG4gICAgICB0aGlzLl9jbGlwcGluZ01hbmFnZXIgPSBuZXcgQ3ViaXNtQ2xpcHBpbmdNYW5hZ2VyX1dlYkdMKCk7XG4gICAgICB0aGlzLl9jbGlwcGluZ01hbmFnZXIuaW5pdGlhbGl6ZShtb2RlbCwgbW9kZWwuZ2V0RHJhd2FibGVDb3VudCgpLCBtb2RlbC5nZXREcmF3YWJsZU1hc2tzKCksIG1vZGVsLmdldERyYXdhYmxlTWFza0NvdW50cygpKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IG1vZGVsLmdldERyYXdhYmxlQ291bnQoKSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0aGlzLl9zb3J0ZWREcmF3YWJsZUluZGV4TGlzdFtpXSA9IDA7XG4gICAgfVxuICAgIHN1cGVyLmluaXRpYWxpemUobW9kZWwpO1xuICB9XG4gIGJpbmRUZXh0dXJlKG1vZGVsVGV4dHVyZU5vLCBnbFRleHR1cmUpIHtcbiAgICB0aGlzLl90ZXh0dXJlc1ttb2RlbFRleHR1cmVOb10gPSBnbFRleHR1cmU7XG4gIH1cbiAgZ2V0QmluZGVkVGV4dHVyZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHR1cmVzO1xuICB9XG4gIHNldENsaXBwaW5nTWFza0J1ZmZlclNpemUoc2l6ZSkge1xuICAgIHRoaXMuX2NsaXBwaW5nTWFuYWdlci5yZWxlYXNlKCk7XG4gICAgdGhpcy5fY2xpcHBpbmdNYW5hZ2VyID0gbmV3IEN1YmlzbUNsaXBwaW5nTWFuYWdlcl9XZWJHTCgpO1xuICAgIHRoaXMuX2NsaXBwaW5nTWFuYWdlci5zZXRDbGlwcGluZ01hc2tCdWZmZXJTaXplKHNpemUpO1xuICAgIHRoaXMuX2NsaXBwaW5nTWFuYWdlci5pbml0aWFsaXplKHRoaXMuZ2V0TW9kZWwoKSwgdGhpcy5nZXRNb2RlbCgpLmdldERyYXdhYmxlQ291bnQoKSwgdGhpcy5nZXRNb2RlbCgpLmdldERyYXdhYmxlTWFza3MoKSwgdGhpcy5nZXRNb2RlbCgpLmdldERyYXdhYmxlTWFza0NvdW50cygpKTtcbiAgfVxuICBnZXRDbGlwcGluZ01hc2tCdWZmZXJTaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9jbGlwcGluZ01hbmFnZXIuZ2V0Q2xpcHBpbmdNYXNrQnVmZmVyU2l6ZSgpO1xuICB9XG4gIHJlbGVhc2UoKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fY2xpcHBpbmdNYW5hZ2VyLnJlbGVhc2UoKTtcbiAgICBzZWxmLl9jbGlwcGluZ01hbmFnZXIgPSB2b2lkIDA7XG4gICAgKF9hID0gdGhpcy5nbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRlbGV0ZUJ1ZmZlcih0aGlzLl9idWZmZXJEYXRhLnZlcnRleCk7XG4gICAgdGhpcy5fYnVmZmVyRGF0YS52ZXJ0ZXggPSBudWxsO1xuICAgIChfYiA9IHRoaXMuZ2wpID09IG51bGwgPyB2b2lkIDAgOiBfYi5kZWxldGVCdWZmZXIodGhpcy5fYnVmZmVyRGF0YS51dik7XG4gICAgdGhpcy5fYnVmZmVyRGF0YS51diA9IG51bGw7XG4gICAgKF9jID0gdGhpcy5nbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmRlbGV0ZUJ1ZmZlcih0aGlzLl9idWZmZXJEYXRhLmluZGV4KTtcbiAgICB0aGlzLl9idWZmZXJEYXRhLmluZGV4ID0gbnVsbDtcbiAgICBzZWxmLl9idWZmZXJEYXRhID0gdm9pZCAwO1xuICAgIHNlbGYuX3RleHR1cmVzID0gdm9pZCAwO1xuICB9XG4gIGRvRHJhd01vZGVsKCkge1xuICAgIHRoaXMucHJlRHJhdygpO1xuICAgIGlmICh0aGlzLl9jbGlwcGluZ01hbmFnZXIgIT0gbnVsbCkge1xuICAgICAgdGhpcy5fY2xpcHBpbmdNYW5hZ2VyLnNldHVwQ2xpcHBpbmdDb250ZXh0KHRoaXMuZ2V0TW9kZWwoKSwgdGhpcyk7XG4gICAgfVxuICAgIGNvbnN0IGRyYXdhYmxlQ291bnQgPSB0aGlzLmdldE1vZGVsKCkuZ2V0RHJhd2FibGVDb3VudCgpO1xuICAgIGNvbnN0IHJlbmRlck9yZGVyID0gdGhpcy5nZXRNb2RlbCgpLmdldERyYXdhYmxlUmVuZGVyT3JkZXJzKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkcmF3YWJsZUNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IG9yZGVyID0gcmVuZGVyT3JkZXJbaV07XG4gICAgICB0aGlzLl9zb3J0ZWREcmF3YWJsZUluZGV4TGlzdFtvcmRlcl0gPSBpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRyYXdhYmxlQ291bnQ7ICsraSkge1xuICAgICAgY29uc3QgZHJhd2FibGVJbmRleCA9IHRoaXMuX3NvcnRlZERyYXdhYmxlSW5kZXhMaXN0W2ldO1xuICAgICAgaWYgKCF0aGlzLmdldE1vZGVsKCkuZ2V0RHJhd2FibGVEeW5hbWljRmxhZ0lzVmlzaWJsZShkcmF3YWJsZUluZGV4KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0Q2xpcHBpbmdDb250ZXh0QnVmZmVyRm9yRHJhdyh0aGlzLl9jbGlwcGluZ01hbmFnZXIgIT0gbnVsbCA/IHRoaXMuX2NsaXBwaW5nTWFuYWdlci5nZXRDbGlwcGluZ0NvbnRleHRMaXN0Rm9yRHJhdygpW2RyYXdhYmxlSW5kZXhdIDogbnVsbCk7XG4gICAgICB0aGlzLnNldElzQ3VsbGluZyh0aGlzLmdldE1vZGVsKCkuZ2V0RHJhd2FibGVDdWxsaW5nKGRyYXdhYmxlSW5kZXgpKTtcbiAgICAgIHRoaXMuZHJhd01lc2godGhpcy5nZXRNb2RlbCgpLmdldERyYXdhYmxlVGV4dHVyZUluZGljZXMoZHJhd2FibGVJbmRleCksIHRoaXMuZ2V0TW9kZWwoKS5nZXREcmF3YWJsZVZlcnRleEluZGV4Q291bnQoZHJhd2FibGVJbmRleCksIHRoaXMuZ2V0TW9kZWwoKS5nZXREcmF3YWJsZVZlcnRleENvdW50KGRyYXdhYmxlSW5kZXgpLCB0aGlzLmdldE1vZGVsKCkuZ2V0RHJhd2FibGVWZXJ0ZXhJbmRpY2VzKGRyYXdhYmxlSW5kZXgpLCB0aGlzLmdldE1vZGVsKCkuZ2V0RHJhd2FibGVWZXJ0aWNlcyhkcmF3YWJsZUluZGV4KSwgdGhpcy5nZXRNb2RlbCgpLmdldERyYXdhYmxlVmVydGV4VXZzKGRyYXdhYmxlSW5kZXgpLCB0aGlzLmdldE1vZGVsKCkuZ2V0RHJhd2FibGVPcGFjaXR5KGRyYXdhYmxlSW5kZXgpLCB0aGlzLmdldE1vZGVsKCkuZ2V0RHJhd2FibGVCbGVuZE1vZGUoZHJhd2FibGVJbmRleCksIHRoaXMuZ2V0TW9kZWwoKS5nZXREcmF3YWJsZUludmVydGVkTWFza0JpdChkcmF3YWJsZUluZGV4KSk7XG4gICAgfVxuICB9XG4gIGRyYXdNZXNoKHRleHR1cmVObywgaW5kZXhDb3VudCwgdmVydGV4Q291bnQsIGluZGV4QXJyYXksIHZlcnRleEFycmF5LCB1dkFycmF5LCBvcGFjaXR5LCBjb2xvckJsZW5kTW9kZSwgaW52ZXJ0ZWRNYXNrKSB7XG4gICAgaWYgKHRoaXMuaXNDdWxsaW5nKCkpIHtcbiAgICAgIHRoaXMuZ2wuZW5hYmxlKHRoaXMuZ2wuQ1VMTF9GQUNFKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5nbC5kaXNhYmxlKHRoaXMuZ2wuQ1VMTF9GQUNFKTtcbiAgICB9XG4gICAgdGhpcy5nbC5mcm9udEZhY2UodGhpcy5nbC5DQ1cpO1xuICAgIGNvbnN0IG1vZGVsQ29sb3JSR0JBID0gdGhpcy5nZXRNb2RlbENvbG9yKCk7XG4gICAgaWYgKHRoaXMuZ2V0Q2xpcHBpbmdDb250ZXh0QnVmZmVyRm9yTWFzaygpID09IG51bGwpIHtcbiAgICAgIG1vZGVsQ29sb3JSR0JBLkEgKj0gb3BhY2l0eTtcbiAgICAgIGlmICh0aGlzLmlzUHJlbXVsdGlwbGllZEFscGhhKCkpIHtcbiAgICAgICAgbW9kZWxDb2xvclJHQkEuUiAqPSBtb2RlbENvbG9yUkdCQS5BO1xuICAgICAgICBtb2RlbENvbG9yUkdCQS5HICo9IG1vZGVsQ29sb3JSR0JBLkE7XG4gICAgICAgIG1vZGVsQ29sb3JSR0JBLkIgKj0gbW9kZWxDb2xvclJHQkEuQTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGRyYXd0ZXh0dXJlID0gbnVsbDtcbiAgICBpZiAodGhpcy5fdGV4dHVyZXNbdGV4dHVyZU5vXSAhPSBudWxsKSB7XG4gICAgICBkcmF3dGV4dHVyZSA9IHRoaXMuX3RleHR1cmVzW3RleHR1cmVOb107XG4gICAgfVxuICAgIEN1YmlzbVNoYWRlcl9XZWJHTC5nZXRJbnN0YW5jZSgpLnNldHVwU2hhZGVyUHJvZ3JhbSh0aGlzLCBkcmF3dGV4dHVyZSwgdmVydGV4Q291bnQsIHZlcnRleEFycmF5LCBpbmRleEFycmF5LCB1dkFycmF5LCB0aGlzLl9idWZmZXJEYXRhLCBvcGFjaXR5LCBjb2xvckJsZW5kTW9kZSwgbW9kZWxDb2xvclJHQkEsIHRoaXMuaXNQcmVtdWx0aXBsaWVkQWxwaGEoKSwgdGhpcy5nZXRNdnBNYXRyaXgoKSwgaW52ZXJ0ZWRNYXNrKTtcbiAgICB0aGlzLmdsLmRyYXdFbGVtZW50cyh0aGlzLmdsLlRSSUFOR0xFUywgaW5kZXhDb3VudCwgdGhpcy5nbC5VTlNJR05FRF9TSE9SVCwgMCk7XG4gICAgdGhpcy5nbC51c2VQcm9ncmFtKG51bGwpO1xuICAgIHRoaXMuc2V0Q2xpcHBpbmdDb250ZXh0QnVmZmVyRm9yRHJhdyhudWxsKTtcbiAgICB0aGlzLnNldENsaXBwaW5nQ29udGV4dEJ1ZmZlckZvck1hc2sobnVsbCk7XG4gIH1cbiAgc3RhdGljIGRvU3RhdGljUmVsZWFzZSgpIHtcbiAgICBDdWJpc21TaGFkZXJfV2ViR0wuZGVsZXRlSW5zdGFuY2UoKTtcbiAgfVxuICBzZXRSZW5kZXJTdGF0ZShmYm8sIHZpZXdwb3J0KSB7XG4gICAgc19mYm8gPSBmYm87XG4gICAgc192aWV3cG9ydCA9IHZpZXdwb3J0O1xuICB9XG4gIHByZURyYXcoKSB7XG4gICAgaWYgKHRoaXMuZmlyc3REcmF3KSB7XG4gICAgICB0aGlzLmZpcnN0RHJhdyA9IGZhbHNlO1xuICAgICAgdGhpcy5fYW5pc29ydG9weSA9IHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljXCIpIHx8IHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKFwiV0VCS0lUX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpY1wiKSB8fCB0aGlzLmdsLmdldEV4dGVuc2lvbihcIk1PWl9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWNcIik7XG4gICAgfVxuICAgIHRoaXMuZ2wuZGlzYWJsZSh0aGlzLmdsLlNDSVNTT1JfVEVTVCk7XG4gICAgdGhpcy5nbC5kaXNhYmxlKHRoaXMuZ2wuU1RFTkNJTF9URVNUKTtcbiAgICB0aGlzLmdsLmRpc2FibGUodGhpcy5nbC5ERVBUSF9URVNUKTtcbiAgICB0aGlzLmdsLmZyb250RmFjZSh0aGlzLmdsLkNXKTtcbiAgICB0aGlzLmdsLmVuYWJsZSh0aGlzLmdsLkJMRU5EKTtcbiAgICB0aGlzLmdsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcbiAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIG51bGwpO1xuICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKTtcbiAgfVxuICBzZXRDbGlwcGluZ0NvbnRleHRCdWZmZXJGb3JNYXNrKGNsaXApIHtcbiAgICB0aGlzLl9jbGlwcGluZ0NvbnRleHRCdWZmZXJGb3JNYXNrID0gY2xpcDtcbiAgfVxuICBnZXRDbGlwcGluZ0NvbnRleHRCdWZmZXJGb3JNYXNrKCkge1xuICAgIHJldHVybiB0aGlzLl9jbGlwcGluZ0NvbnRleHRCdWZmZXJGb3JNYXNrO1xuICB9XG4gIHNldENsaXBwaW5nQ29udGV4dEJ1ZmZlckZvckRyYXcoY2xpcCkge1xuICAgIHRoaXMuX2NsaXBwaW5nQ29udGV4dEJ1ZmZlckZvckRyYXcgPSBjbGlwO1xuICB9XG4gIGdldENsaXBwaW5nQ29udGV4dEJ1ZmZlckZvckRyYXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaXBwaW5nQ29udGV4dEJ1ZmZlckZvckRyYXc7XG4gIH1cbiAgc3RhcnRVcChnbCkge1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLl9jbGlwcGluZ01hbmFnZXIuc2V0R0woZ2wpO1xuICAgIEN1YmlzbVNoYWRlcl9XZWJHTC5nZXRJbnN0YW5jZSgpLnNldEdsKGdsKTtcbiAgfVxufVxuQ3ViaXNtUmVuZGVyZXIuc3RhdGljUmVsZWFzZSA9ICgpID0+IHtcbiAgQ3ViaXNtUmVuZGVyZXJfV2ViR0wuZG9TdGF0aWNSZWxlYXNlKCk7XG59O1xuY2xhc3MgQ3ViaXNtTW9kZWxTZXR0aW5nc0pzb24ge1xuICBjb25zdHJ1Y3Rvcihqc29uKSB7XG4gICAgdGhpcy5ncm91cHMgPSBqc29uLkdyb3VwcztcbiAgICB0aGlzLmhpdEFyZWFzID0ganNvbi5IaXRBcmVhcztcbiAgICB0aGlzLmxheW91dCA9IGpzb24uTGF5b3V0O1xuICAgIHRoaXMubW9jID0ganNvbi5GaWxlUmVmZXJlbmNlcy5Nb2M7XG4gICAgdGhpcy5leHByZXNzaW9ucyA9IGpzb24uRmlsZVJlZmVyZW5jZXMuRXhwcmVzc2lvbnM7XG4gICAgdGhpcy5tb3Rpb25zID0ganNvbi5GaWxlUmVmZXJlbmNlcy5Nb3Rpb25zO1xuICAgIHRoaXMudGV4dHVyZXMgPSBqc29uLkZpbGVSZWZlcmVuY2VzLlRleHR1cmVzO1xuICAgIHRoaXMucGh5c2ljcyA9IGpzb24uRmlsZVJlZmVyZW5jZXMuUGh5c2ljcztcbiAgICB0aGlzLnBvc2UgPSBqc29uLkZpbGVSZWZlcmVuY2VzLlBvc2U7XG4gIH1cbiAgZ2V0RXllQmxpbmtQYXJhbWV0ZXJzKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuZ3JvdXBzKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZmluZCgoZ3JvdXApID0+IGdyb3VwLk5hbWUgPT09IFwiRXllQmxpbmtcIikpID09IG51bGwgPyB2b2lkIDAgOiBfYi5JZHM7XG4gIH1cbiAgZ2V0TGlwU3luY1BhcmFtZXRlcnMoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5ncm91cHMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5maW5kKChncm91cCkgPT4gZ3JvdXAuTmFtZSA9PT0gXCJMaXBTeW5jXCIpKSA9PSBudWxsID8gdm9pZCAwIDogX2IuSWRzO1xuICB9XG59XG5jb25zdCBIaXRBcmVhUHJlZml4ID0gXCJIaXRBcmVhXCI7XG5jb25zdCBIaXRBcmVhSGVhZCA9IFwiSGVhZFwiO1xuY29uc3QgSGl0QXJlYUJvZHkgPSBcIkJvZHlcIjtcbmNvbnN0IFBhcnRzSWRDb3JlID0gXCJQYXJ0czAxQ29yZVwiO1xuY29uc3QgUGFydHNBcm1QcmVmaXggPSBcIlBhcnRzMDFBcm1fXCI7XG5jb25zdCBQYXJ0c0FybUxQcmVmaXggPSBcIlBhcnRzMDFBcm1MX1wiO1xuY29uc3QgUGFydHNBcm1SUHJlZml4ID0gXCJQYXJ0czAxQXJtUl9cIjtcbmNvbnN0IFBhcmFtQW5nbGVYID0gXCJQYXJhbUFuZ2xlWFwiO1xuY29uc3QgUGFyYW1BbmdsZVkgPSBcIlBhcmFtQW5nbGVZXCI7XG5jb25zdCBQYXJhbUFuZ2xlWiA9IFwiUGFyYW1BbmdsZVpcIjtcbmNvbnN0IFBhcmFtRXllTE9wZW4gPSBcIlBhcmFtRXllTE9wZW5cIjtcbmNvbnN0IFBhcmFtRXllTFNtaWxlID0gXCJQYXJhbUV5ZUxTbWlsZVwiO1xuY29uc3QgUGFyYW1FeWVST3BlbiA9IFwiUGFyYW1FeWVST3BlblwiO1xuY29uc3QgUGFyYW1FeWVSU21pbGUgPSBcIlBhcmFtRXllUlNtaWxlXCI7XG5jb25zdCBQYXJhbUV5ZUJhbGxYID0gXCJQYXJhbUV5ZUJhbGxYXCI7XG5jb25zdCBQYXJhbUV5ZUJhbGxZID0gXCJQYXJhbUV5ZUJhbGxZXCI7XG5jb25zdCBQYXJhbUV5ZUJhbGxGb3JtID0gXCJQYXJhbUV5ZUJhbGxGb3JtXCI7XG5jb25zdCBQYXJhbUJyb3dMWSA9IFwiUGFyYW1Ccm93TFlcIjtcbmNvbnN0IFBhcmFtQnJvd1JZID0gXCJQYXJhbUJyb3dSWVwiO1xuY29uc3QgUGFyYW1Ccm93TFggPSBcIlBhcmFtQnJvd0xYXCI7XG5jb25zdCBQYXJhbUJyb3dSWCA9IFwiUGFyYW1Ccm93UlhcIjtcbmNvbnN0IFBhcmFtQnJvd0xBbmdsZSA9IFwiUGFyYW1Ccm93TEFuZ2xlXCI7XG5jb25zdCBQYXJhbUJyb3dSQW5nbGUgPSBcIlBhcmFtQnJvd1JBbmdsZVwiO1xuY29uc3QgUGFyYW1Ccm93TEZvcm0gPSBcIlBhcmFtQnJvd0xGb3JtXCI7XG5jb25zdCBQYXJhbUJyb3dSRm9ybSA9IFwiUGFyYW1Ccm93UkZvcm1cIjtcbmNvbnN0IFBhcmFtTW91dGhGb3JtID0gXCJQYXJhbU1vdXRoRm9ybVwiO1xuY29uc3QgUGFyYW1Nb3V0aE9wZW5ZID0gXCJQYXJhbU1vdXRoT3BlbllcIjtcbmNvbnN0IFBhcmFtQ2hlZWsgPSBcIlBhcmFtQ2hlZWtcIjtcbmNvbnN0IFBhcmFtQm9keUFuZ2xlWCA9IFwiUGFyYW1Cb2R5QW5nbGVYXCI7XG5jb25zdCBQYXJhbUJvZHlBbmdsZVkgPSBcIlBhcmFtQm9keUFuZ2xlWVwiO1xuY29uc3QgUGFyYW1Cb2R5QW5nbGVaID0gXCJQYXJhbUJvZHlBbmdsZVpcIjtcbmNvbnN0IFBhcmFtQnJlYXRoID0gXCJQYXJhbUJyZWF0aFwiO1xuY29uc3QgUGFyYW1Bcm1MQSA9IFwiUGFyYW1Bcm1MQVwiO1xuY29uc3QgUGFyYW1Bcm1SQSA9IFwiUGFyYW1Bcm1SQVwiO1xuY29uc3QgUGFyYW1Bcm1MQiA9IFwiUGFyYW1Bcm1MQlwiO1xuY29uc3QgUGFyYW1Bcm1SQiA9IFwiUGFyYW1Bcm1SQlwiO1xuY29uc3QgUGFyYW1IYW5kTCA9IFwiUGFyYW1IYW5kTFwiO1xuY29uc3QgUGFyYW1IYW5kUiA9IFwiUGFyYW1IYW5kUlwiO1xuY29uc3QgUGFyYW1IYWlyRnJvbnQgPSBcIlBhcmFtSGFpckZyb250XCI7XG5jb25zdCBQYXJhbUhhaXJTaWRlID0gXCJQYXJhbUhhaXJTaWRlXCI7XG5jb25zdCBQYXJhbUhhaXJCYWNrID0gXCJQYXJhbUhhaXJCYWNrXCI7XG5jb25zdCBQYXJhbUhhaXJGbHVmZnkgPSBcIlBhcmFtSGFpckZsdWZmeVwiO1xuY29uc3QgUGFyYW1TaG91bGRlclkgPSBcIlBhcmFtU2hvdWxkZXJZXCI7XG5jb25zdCBQYXJhbUJ1c3RYID0gXCJQYXJhbUJ1c3RYXCI7XG5jb25zdCBQYXJhbUJ1c3RZID0gXCJQYXJhbUJ1c3RZXCI7XG5jb25zdCBQYXJhbUJhc2VYID0gXCJQYXJhbUJhc2VYXCI7XG5jb25zdCBQYXJhbUJhc2VZID0gXCJQYXJhbUJhc2VZXCI7XG5jb25zdCBQYXJhbU5PTkUgPSBcIk5PTkU6XCI7XG5jb25zdCBMT0dJQ0FMX1dJRFRIID0gMjtcbmNvbnN0IExPR0lDQUxfSEVJR0hUID0gMjtcbnZhciBjb25maWc7XG4oKGNvbmZpZzIpID0+IHtcbiAgY29uZmlnMi5MT0dfTEVWRUxfVkVSQk9TRSA9IDA7XG4gIGNvbmZpZzIuTE9HX0xFVkVMX1dBUk5JTkcgPSAxO1xuICBjb25maWcyLkxPR19MRVZFTF9FUlJPUiA9IDI7XG4gIGNvbmZpZzIuTE9HX0xFVkVMX05PTkUgPSA5OTk7XG4gIGNvbmZpZzIubG9nTGV2ZWwgPSBjb25maWcyLkxPR19MRVZFTF9XQVJOSU5HO1xuICBjb25maWcyLnNvdW5kID0gdHJ1ZTtcbiAgY29uZmlnMi5tb3Rpb25TeW5jID0gdHJ1ZTtcbiAgY29uZmlnMi5tb3Rpb25GYWRpbmdEdXJhdGlvbiA9IDUwMDtcbiAgY29uZmlnMi5pZGxlTW90aW9uRmFkaW5nRHVyYXRpb24gPSAyZTM7XG4gIGNvbmZpZzIuZXhwcmVzc2lvbkZhZGluZ0R1cmF0aW9uID0gNTAwO1xuICBjb25maWcyLnByZXNlcnZlRXhwcmVzc2lvbk9uTW90aW9uID0gdHJ1ZTtcbiAgY29uZmlnMi5jdWJpc200ID0gQ3ViaXNtQ29uZmlnO1xufSkoY29uZmlnIHx8IChjb25maWcgPSB7fSkpO1xuY29uc3QgVkVSU0lPTiA9IFwiMC40LjBcIjtcbmNvbnN0IGxvZ2dlciA9IHtcbiAgbG9nKHRhZywgLi4ubWVzc2FnZXMpIHtcbiAgICBpZiAoY29uZmlnLmxvZ0xldmVsIDw9IGNvbmZpZy5MT0dfTEVWRUxfVkVSQk9TRSkge1xuICAgICAgY29uc29sZS5sb2coYFske3RhZ31dYCwgLi4ubWVzc2FnZXMpO1xuICAgIH1cbiAgfSxcbiAgd2Fybih0YWcsIC4uLm1lc3NhZ2VzKSB7XG4gICAgaWYgKGNvbmZpZy5sb2dMZXZlbCA8PSBjb25maWcuTE9HX0xFVkVMX1dBUk5JTkcpIHtcbiAgICAgIGNvbnNvbGUud2FybihgWyR7dGFnfV1gLCAuLi5tZXNzYWdlcyk7XG4gICAgfVxuICB9LFxuICBlcnJvcih0YWcsIC4uLm1lc3NhZ2VzKSB7XG4gICAgaWYgKGNvbmZpZy5sb2dMZXZlbCA8PSBjb25maWcuTE9HX0xFVkVMX0VSUk9SKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBbJHt0YWd9XWAsIC4uLm1lc3NhZ2VzKTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBjbGFtcChudW0sIGxvd2VyLCB1cHBlcikge1xuICByZXR1cm4gbnVtIDwgbG93ZXIgPyBsb3dlciA6IG51bSA+IHVwcGVyID8gdXBwZXIgOiBudW07XG59XG5mdW5jdGlvbiByYW5kKG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW47XG59XG5mdW5jdGlvbiBjb3B5UHJvcGVydHkodHlwZSwgZnJvbSwgdG8sIGZyb21LZXksIHRvS2V5KSB7XG4gIGNvbnN0IHZhbHVlID0gZnJvbVtmcm9tS2V5XTtcbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gdHlwZSkge1xuICAgIHRvW3RvS2V5XSA9IHZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBjb3B5QXJyYXkodHlwZSwgZnJvbSwgdG8sIGZyb21LZXksIHRvS2V5KSB7XG4gIGNvbnN0IGFycmF5ID0gZnJvbVtmcm9tS2V5XTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgdG9bdG9LZXldID0gYXJyYXkuZmlsdGVyKChpdGVtKSA9PiBpdGVtICE9PSBudWxsICYmIHR5cGVvZiBpdGVtID09PSB0eXBlKTtcbiAgfVxufVxuZnVuY3Rpb24gYXBwbHlNaXhpbnMoZGVyaXZlZEN0b3IsIGJhc2VDdG9ycykge1xuICBiYXNlQ3RvcnMuZm9yRWFjaCgoYmFzZUN0b3IpID0+IHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhiYXNlQ3Rvci5wcm90b3R5cGUpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgIGlmIChuYW1lICE9PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlcml2ZWRDdG9yLnByb3RvdHlwZSwgbmFtZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlQ3Rvci5wcm90b3R5cGUsIG5hbWUpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBmb2xkZXJOYW1lKHVybDIpIHtcbiAgbGV0IGxhc3RTbGFzaEluZGV4ID0gdXJsMi5sYXN0SW5kZXhPZihcIi9cIik7XG4gIGlmIChsYXN0U2xhc2hJbmRleCAhPSAtMSkge1xuICAgIHVybDIgPSB1cmwyLnNsaWNlKDAsIGxhc3RTbGFzaEluZGV4KTtcbiAgfVxuICBsYXN0U2xhc2hJbmRleCA9IHVybDIubGFzdEluZGV4T2YoXCIvXCIpO1xuICBpZiAobGFzdFNsYXNoSW5kZXggIT09IC0xKSB7XG4gICAgdXJsMiA9IHVybDIuc2xpY2UobGFzdFNsYXNoSW5kZXggKyAxKTtcbiAgfVxuICByZXR1cm4gdXJsMjtcbn1cbmZ1bmN0aW9uIHJlbW92ZShhcnJheSwgaXRlbSkge1xuICBjb25zdCBpbmRleCA9IGFycmF5LmluZGV4T2YoaXRlbSk7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICBhcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG59XG5jbGFzcyBFeHByZXNzaW9uTWFuYWdlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmV4cHJlc3Npb25zID0gW107XG4gICAgdGhpcy5yZXNlcnZlRXhwcmVzc2lvbkluZGV4ID0gLTE7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy50YWcgPSBgRXhwcmVzc2lvbk1hbmFnZXIoJHtzZXR0aW5ncy5uYW1lfSlgO1xuICB9XG4gIGluaXQoKSB7XG4gICAgdGhpcy5kZWZhdWx0RXhwcmVzc2lvbiA9IHRoaXMuY3JlYXRlRXhwcmVzc2lvbih7fSwgdm9pZCAwKTtcbiAgICB0aGlzLmN1cnJlbnRFeHByZXNzaW9uID0gdGhpcy5kZWZhdWx0RXhwcmVzc2lvbjtcbiAgICB0aGlzLnN0b3BBbGxFeHByZXNzaW9ucygpO1xuICB9XG4gIGxvYWRFeHByZXNzaW9uKGluZGV4KSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5kZWZpbml0aW9uc1tpbmRleF0pIHtcbiAgICAgICAgbG9nZ2VyLndhcm4odGhpcy50YWcsIGBVbmRlZmluZWQgZXhwcmVzc2lvbiBhdCBbJHtpbmRleH1dYCk7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5leHByZXNzaW9uc1tpbmRleF0gPT09IG51bGwpIHtcbiAgICAgICAgbG9nZ2VyLndhcm4odGhpcy50YWcsIGBDYW5ub3Qgc2V0IGV4cHJlc3Npb24gYXQgWyR7aW5kZXh9XSBiZWNhdXNlIGl0J3MgYWxyZWFkeSBmYWlsZWQgaW4gbG9hZGluZy5gKTtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmV4cHJlc3Npb25zW2luZGV4XSkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uc1tpbmRleF07XG4gICAgICB9XG4gICAgICBjb25zdCBleHByZXNzaW9uID0geWllbGQgdGhpcy5fbG9hZEV4cHJlc3Npb24oaW5kZXgpO1xuICAgICAgdGhpcy5leHByZXNzaW9uc1tpbmRleF0gPSBleHByZXNzaW9uO1xuICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgfSk7XG4gIH1cbiAgX2xvYWRFeHByZXNzaW9uKGluZGV4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkLlwiKTtcbiAgfVxuICBzZXRSYW5kb21FeHByZXNzaW9uKCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5kZWZpbml0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlSW5kaWNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGVmaW5pdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5leHByZXNzaW9uc1tpXSAhPT0gbnVsbCAmJiB0aGlzLmV4cHJlc3Npb25zW2ldICE9PSB0aGlzLmN1cnJlbnRFeHByZXNzaW9uICYmIGkgIT09IHRoaXMucmVzZXJ2ZUV4cHJlc3Npb25JbmRleCkge1xuICAgICAgICAgICAgYXZhaWxhYmxlSW5kaWNlcy5wdXNoKGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXZhaWxhYmxlSW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGF2YWlsYWJsZUluZGljZXMubGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXRFeHByZXNzaW9uKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICB9XG4gIHJlc2V0RXhwcmVzc2lvbigpIHtcbiAgICB0aGlzLl9zZXRFeHByZXNzaW9uKHRoaXMuZGVmYXVsdEV4cHJlc3Npb24pO1xuICB9XG4gIHJlc3RvcmVFeHByZXNzaW9uKCkge1xuICAgIHRoaXMuX3NldEV4cHJlc3Npb24odGhpcy5jdXJyZW50RXhwcmVzc2lvbik7XG4gIH1cbiAgc2V0RXhwcmVzc2lvbihpbmRleCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodHlwZW9mIGluZGV4ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGluZGV4ID0gdGhpcy5nZXRFeHByZXNzaW9uSW5kZXgoaW5kZXgpO1xuICAgICAgfVxuICAgICAgaWYgKCEoaW5kZXggPiAtMSAmJiBpbmRleCA8IHRoaXMuZGVmaW5pdGlvbnMubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoaW5kZXggPT09IHRoaXMuZXhwcmVzc2lvbnMuaW5kZXhPZih0aGlzLmN1cnJlbnRFeHByZXNzaW9uKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLnJlc2VydmVFeHByZXNzaW9uSW5kZXggPSBpbmRleDtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSB5aWVsZCB0aGlzLmxvYWRFeHByZXNzaW9uKGluZGV4KTtcbiAgICAgIGlmICghZXhwcmVzc2lvbiB8fCB0aGlzLnJlc2VydmVFeHByZXNzaW9uSW5kZXggIT09IGluZGV4KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzZXJ2ZUV4cHJlc3Npb25JbmRleCA9IC0xO1xuICAgICAgdGhpcy5jdXJyZW50RXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICB0aGlzLl9zZXRFeHByZXNzaW9uKGV4cHJlc3Npb24pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlKG1vZGVsLCBub3cpIHtcbiAgICBpZiAoIXRoaXMuaXNGaW5pc2hlZCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy51cGRhdGVQYXJhbWV0ZXJzKG1vZGVsLCBub3cpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgdGhpcy5lbWl0KFwiZGVzdHJveVwiKTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBzZWxmLmRlZmluaXRpb25zID0gdm9pZCAwO1xuICAgIHNlbGYuZXhwcmVzc2lvbnMgPSB2b2lkIDA7XG4gIH1cbn1cbmNvbnN0IEVQU0lMT04gPSAwLjAxO1xuY29uc3QgTUFYX1NQRUVEID0gNDAgLyA3LjU7XG5jb25zdCBBQ0NFTEVSQVRJT05fVElNRSA9IDEgLyAoMC4xNSAqIDFlMyk7XG5jbGFzcyBGb2N1c0NvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnRhcmdldFggPSAwO1xuICAgIHRoaXMudGFyZ2V0WSA9IDA7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMudnggPSAwO1xuICAgIHRoaXMudnkgPSAwO1xuICB9XG4gIGZvY3VzKHgsIHksIGluc3RhbnQgPSBmYWxzZSkge1xuICAgIHRoaXMudGFyZ2V0WCA9IGNsYW1wKHgsIC0xLCAxKTtcbiAgICB0aGlzLnRhcmdldFkgPSBjbGFtcCh5LCAtMSwgMSk7XG4gICAgaWYgKGluc3RhbnQpIHtcbiAgICAgIHRoaXMueCA9IHRoaXMudGFyZ2V0WDtcbiAgICAgIHRoaXMueSA9IHRoaXMudGFyZ2V0WTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlKGR0KSB7XG4gICAgY29uc3QgZHggPSB0aGlzLnRhcmdldFggLSB0aGlzLng7XG4gICAgY29uc3QgZHkgPSB0aGlzLnRhcmdldFkgLSB0aGlzLnk7XG4gICAgaWYgKE1hdGguYWJzKGR4KSA8IEVQU0lMT04gJiYgTWF0aC5hYnMoZHkpIDwgRVBTSUxPTilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBkID0gTWF0aC5zcXJ0KF9fcG93KGR4LCAyKSArIF9fcG93KGR5LCAyKSk7XG4gICAgY29uc3QgbWF4U3BlZWQgPSBNQVhfU1BFRUQgLyAoMWUzIC8gZHQpO1xuICAgIGxldCBheCA9IG1heFNwZWVkICogKGR4IC8gZCkgLSB0aGlzLnZ4O1xuICAgIGxldCBheSA9IG1heFNwZWVkICogKGR5IC8gZCkgLSB0aGlzLnZ5O1xuICAgIGNvbnN0IGEgPSBNYXRoLnNxcnQoX19wb3coYXgsIDIpICsgX19wb3coYXksIDIpKTtcbiAgICBjb25zdCBtYXhBID0gbWF4U3BlZWQgKiBBQ0NFTEVSQVRJT05fVElNRSAqIGR0O1xuICAgIGlmIChhID4gbWF4QSkge1xuICAgICAgYXggKj0gbWF4QSAvIGE7XG4gICAgICBheSAqPSBtYXhBIC8gYTtcbiAgICB9XG4gICAgdGhpcy52eCArPSBheDtcbiAgICB0aGlzLnZ5ICs9IGF5O1xuICAgIGNvbnN0IHYgPSBNYXRoLnNxcnQoX19wb3codGhpcy52eCwgMikgKyBfX3Bvdyh0aGlzLnZ5LCAyKSk7XG4gICAgY29uc3QgbWF4ViA9IDAuNSAqIChNYXRoLnNxcnQoX19wb3cobWF4QSwgMikgKyA4ICogbWF4QSAqIGQpIC0gbWF4QSk7XG4gICAgaWYgKHYgPiBtYXhWKSB7XG4gICAgICB0aGlzLnZ4ICo9IG1heFYgLyB2O1xuICAgICAgdGhpcy52eSAqPSBtYXhWIC8gdjtcbiAgICB9XG4gICAgdGhpcy54ICs9IHRoaXMudng7XG4gICAgdGhpcy55ICs9IHRoaXMudnk7XG4gIH1cbn1cbmNsYXNzIE1vZGVsU2V0dGluZ3Mge1xuICBjb25zdHJ1Y3Rvcihqc29uKSB7XG4gICAgdGhpcy5qc29uID0ganNvbjtcbiAgICBsZXQgdXJsMiA9IGpzb24udXJsO1xuICAgIGlmICh0eXBlb2YgdXJsMiAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBgdXJsYCBmaWVsZCBpbiBzZXR0aW5ncyBKU09OIG11c3QgYmUgZGVmaW5lZCBhcyBhIHN0cmluZy5cIik7XG4gICAgfVxuICAgIHRoaXMudXJsID0gdXJsMjtcbiAgICB0aGlzLm5hbWUgPSBmb2xkZXJOYW1lKHRoaXMudXJsKTtcbiAgfVxuICByZXNvbHZlVVJMKHBhdGgpIHtcbiAgICByZXR1cm4gdXJsLnJlc29sdmUodGhpcy51cmwsIHBhdGgpO1xuICB9XG4gIHJlcGxhY2VGaWxlcyhyZXBsYWNlcikge1xuICAgIHRoaXMubW9jID0gcmVwbGFjZXIodGhpcy5tb2MsIFwibW9jXCIpO1xuICAgIGlmICh0aGlzLnBvc2UgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5wb3NlID0gcmVwbGFjZXIodGhpcy5wb3NlLCBcInBvc2VcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLnBoeXNpY3MgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5waHlzaWNzID0gcmVwbGFjZXIodGhpcy5waHlzaWNzLCBcInBoeXNpY3NcIik7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50ZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy50ZXh0dXJlc1tpXSA9IHJlcGxhY2VyKHRoaXMudGV4dHVyZXNbaV0sIGB0ZXh0dXJlc1ske2l9XWApO1xuICAgIH1cbiAgfVxuICBnZXREZWZpbmVkRmlsZXMoKSB7XG4gICAgY29uc3QgZmlsZXMgPSBbXTtcbiAgICB0aGlzLnJlcGxhY2VGaWxlcygoZmlsZSkgPT4ge1xuICAgICAgZmlsZXMucHVzaChmaWxlKTtcbiAgICAgIHJldHVybiBmaWxlO1xuICAgIH0pO1xuICAgIHJldHVybiBmaWxlcztcbiAgfVxuICB2YWxpZGF0ZUZpbGVzKGZpbGVzKSB7XG4gICAgY29uc3QgYXNzZXJ0RmlsZUV4aXN0cyA9IChleHBlY3RlZEZpbGUsIHNob3VsZFRocm93KSA9PiB7XG4gICAgICBjb25zdCBhY3R1YWxQYXRoID0gdGhpcy5yZXNvbHZlVVJMKGV4cGVjdGVkRmlsZSk7XG4gICAgICBpZiAoIWZpbGVzLmluY2x1ZGVzKGFjdHVhbFBhdGgpKSB7XG4gICAgICAgIGlmIChzaG91bGRUaHJvdykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmlsZSBcIiR7ZXhwZWN0ZWRGaWxlfVwiIGlzIGRlZmluZWQgaW4gc2V0dGluZ3MsIGJ1dCBkb2Vzbid0IGV4aXN0IGluIGdpdmVuIGZpbGVzYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBlc3NlbnRpYWxGaWxlcyA9IFt0aGlzLm1vYywgLi4udGhpcy50ZXh0dXJlc107XG4gICAgZXNzZW50aWFsRmlsZXMuZm9yRWFjaCgodGV4dHVyZSkgPT4gYXNzZXJ0RmlsZUV4aXN0cyh0ZXh0dXJlLCB0cnVlKSk7XG4gICAgY29uc3QgZGVmaW5lZEZpbGVzID0gdGhpcy5nZXREZWZpbmVkRmlsZXMoKTtcbiAgICByZXR1cm4gZGVmaW5lZEZpbGVzLmZpbHRlcigoZmlsZSkgPT4gYXNzZXJ0RmlsZUV4aXN0cyhmaWxlLCBmYWxzZSkpO1xuICB9XG59XG52YXIgTW90aW9uUHJpb3JpdHkgPSAvKiBAX19QVVJFX18gKi8gKChNb3Rpb25Qcmlvcml0eTIpID0+IHtcbiAgTW90aW9uUHJpb3JpdHkyW01vdGlvblByaW9yaXR5MltcIk5PTkVcIl0gPSAwXSA9IFwiTk9ORVwiO1xuICBNb3Rpb25Qcmlvcml0eTJbTW90aW9uUHJpb3JpdHkyW1wiSURMRVwiXSA9IDFdID0gXCJJRExFXCI7XG4gIE1vdGlvblByaW9yaXR5MltNb3Rpb25Qcmlvcml0eTJbXCJOT1JNQUxcIl0gPSAyXSA9IFwiTk9STUFMXCI7XG4gIE1vdGlvblByaW9yaXR5MltNb3Rpb25Qcmlvcml0eTJbXCJGT1JDRVwiXSA9IDNdID0gXCJGT1JDRVwiO1xuICByZXR1cm4gTW90aW9uUHJpb3JpdHkyO1xufSkoTW90aW9uUHJpb3JpdHkgfHwge30pO1xuY2xhc3MgTW90aW9uU3RhdGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmRlYnVnID0gZmFsc2U7XG4gICAgdGhpcy5jdXJyZW50UHJpb3JpdHkgPSAwO1xuICAgIHRoaXMucmVzZXJ2ZVByaW9yaXR5ID0gMDtcbiAgfVxuICByZXNlcnZlKGdyb3VwLCBpbmRleCwgcHJpb3JpdHkpIHtcbiAgICBpZiAocHJpb3JpdHkgPD0gMCkge1xuICAgICAgbG9nZ2VyLmxvZyh0aGlzLnRhZywgYENhbm5vdCBzdGFydCBhIG1vdGlvbiB3aXRoIE1vdGlvblByaW9yaXR5Lk5PTkUuYCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChncm91cCA9PT0gdGhpcy5jdXJyZW50R3JvdXAgJiYgaW5kZXggPT09IHRoaXMuY3VycmVudEluZGV4KSB7XG4gICAgICBsb2dnZXIubG9nKHRoaXMudGFnLCBgTW90aW9uIGlzIGFscmVhZHkgcGxheWluZy5gLCB0aGlzLmR1bXAoZ3JvdXAsIGluZGV4KSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChncm91cCA9PT0gdGhpcy5yZXNlcnZlZEdyb3VwICYmIGluZGV4ID09PSB0aGlzLnJlc2VydmVkSW5kZXggfHwgZ3JvdXAgPT09IHRoaXMucmVzZXJ2ZWRJZGxlR3JvdXAgJiYgaW5kZXggPT09IHRoaXMucmVzZXJ2ZWRJZGxlSW5kZXgpIHtcbiAgICAgIGxvZ2dlci5sb2codGhpcy50YWcsIGBNb3Rpb24gaXMgYWxyZWFkeSByZXNlcnZlZC5gLCB0aGlzLmR1bXAoZ3JvdXAsIGluZGV4KSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwcmlvcml0eSA9PT0gMSkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudFByaW9yaXR5ICE9PSAwKSB7XG4gICAgICAgIGxvZ2dlci5sb2codGhpcy50YWcsIGBDYW5ub3Qgc3RhcnQgaWRsZSBtb3Rpb24gYmVjYXVzZSBhbm90aGVyIG1vdGlvbiBpcyBwbGF5aW5nLmAsIHRoaXMuZHVtcChncm91cCwgaW5kZXgpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucmVzZXJ2ZWRJZGxlR3JvdXAgIT09IHZvaWQgMCkge1xuICAgICAgICBsb2dnZXIubG9nKHRoaXMudGFnLCBgQ2Fubm90IHN0YXJ0IGlkbGUgbW90aW9uIGJlY2F1c2UgYW5vdGhlciBpZGxlIG1vdGlvbiBoYXMgcmVzZXJ2ZWQuYCwgdGhpcy5kdW1wKGdyb3VwLCBpbmRleCkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFJlc2VydmVkSWRsZShncm91cCwgaW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJpb3JpdHkgPCAzKSB7XG4gICAgICAgIGlmIChwcmlvcml0eSA8PSB0aGlzLmN1cnJlbnRQcmlvcml0eSkge1xuICAgICAgICAgIGxvZ2dlci5sb2codGhpcy50YWcsIFwiQ2Fubm90IHN0YXJ0IG1vdGlvbiBiZWNhdXNlIGFub3RoZXIgbW90aW9uIGlzIHBsYXlpbmcgYXMgYW4gZXF1aXZhbGVudCBvciBoaWdoZXIgcHJpb3JpdHkuXCIsIHRoaXMuZHVtcChncm91cCwgaW5kZXgpKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByaW9yaXR5IDw9IHRoaXMucmVzZXJ2ZVByaW9yaXR5KSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyh0aGlzLnRhZywgXCJDYW5ub3Qgc3RhcnQgbW90aW9uIGJlY2F1c2UgYW5vdGhlciBtb3Rpb24gaGFzIHJlc2VydmVkIGFzIGFuIGVxdWl2YWxlbnQgb3IgaGlnaGVyIHByaW9yaXR5LlwiLCB0aGlzLmR1bXAoZ3JvdXAsIGluZGV4KSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnNldFJlc2VydmVkKGdyb3VwLCBpbmRleCwgcHJpb3JpdHkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzdGFydChtb3Rpb24sIGdyb3VwLCBpbmRleCwgcHJpb3JpdHkpIHtcbiAgICBpZiAocHJpb3JpdHkgPT09IDEpIHtcbiAgICAgIHRoaXMuc2V0UmVzZXJ2ZWRJZGxlKHZvaWQgMCwgdm9pZCAwKTtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRQcmlvcml0eSAhPT0gMCkge1xuICAgICAgICBsb2dnZXIubG9nKHRoaXMudGFnLCBcIkNhbm5vdCBzdGFydCBpZGxlIG1vdGlvbiBiZWNhdXNlIGFub3RoZXIgbW90aW9uIGlzIHBsYXlpbmcuXCIsIHRoaXMuZHVtcChncm91cCwgaW5kZXgpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZ3JvdXAgIT09IHRoaXMucmVzZXJ2ZWRHcm91cCB8fCBpbmRleCAhPT0gdGhpcy5yZXNlcnZlZEluZGV4KSB7XG4gICAgICAgIGxvZ2dlci5sb2codGhpcy50YWcsIFwiQ2Fubm90IHN0YXJ0IG1vdGlvbiBiZWNhdXNlIGFub3RoZXIgbW90aW9uIGhhcyB0YWtlbiB0aGUgcGxhY2UuXCIsIHRoaXMuZHVtcChncm91cCwgaW5kZXgpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRSZXNlcnZlZCh2b2lkIDAsIHZvaWQgMCwgMCk7XG4gICAgfVxuICAgIGlmICghbW90aW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuc2V0Q3VycmVudChncm91cCwgaW5kZXgsIHByaW9yaXR5KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb21wbGV0ZSgpIHtcbiAgICB0aGlzLnNldEN1cnJlbnQodm9pZCAwLCB2b2lkIDAsIDApO1xuICB9XG4gIHNldEN1cnJlbnQoZ3JvdXAsIGluZGV4LCBwcmlvcml0eSkge1xuICAgIHRoaXMuY3VycmVudFByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgdGhpcy5jdXJyZW50R3JvdXAgPSBncm91cDtcbiAgICB0aGlzLmN1cnJlbnRJbmRleCA9IGluZGV4O1xuICB9XG4gIHNldFJlc2VydmVkKGdyb3VwLCBpbmRleCwgcHJpb3JpdHkpIHtcbiAgICB0aGlzLnJlc2VydmVQcmlvcml0eSA9IHByaW9yaXR5O1xuICAgIHRoaXMucmVzZXJ2ZWRHcm91cCA9IGdyb3VwO1xuICAgIHRoaXMucmVzZXJ2ZWRJbmRleCA9IGluZGV4O1xuICB9XG4gIHNldFJlc2VydmVkSWRsZShncm91cCwgaW5kZXgpIHtcbiAgICB0aGlzLnJlc2VydmVkSWRsZUdyb3VwID0gZ3JvdXA7XG4gICAgdGhpcy5yZXNlcnZlZElkbGVJbmRleCA9IGluZGV4O1xuICB9XG4gIGlzQWN0aXZlKGdyb3VwLCBpbmRleCkge1xuICAgIHJldHVybiBncm91cCA9PT0gdGhpcy5jdXJyZW50R3JvdXAgJiYgaW5kZXggPT09IHRoaXMuY3VycmVudEluZGV4IHx8IGdyb3VwID09PSB0aGlzLnJlc2VydmVkR3JvdXAgJiYgaW5kZXggPT09IHRoaXMucmVzZXJ2ZWRJbmRleCB8fCBncm91cCA9PT0gdGhpcy5yZXNlcnZlZElkbGVHcm91cCAmJiBpbmRleCA9PT0gdGhpcy5yZXNlcnZlZElkbGVJbmRleDtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLnNldEN1cnJlbnQodm9pZCAwLCB2b2lkIDAsIDApO1xuICAgIHRoaXMuc2V0UmVzZXJ2ZWQodm9pZCAwLCB2b2lkIDAsIDApO1xuICAgIHRoaXMuc2V0UmVzZXJ2ZWRJZGxlKHZvaWQgMCwgdm9pZCAwKTtcbiAgfVxuICBzaG91bGRSZXF1ZXN0SWRsZU1vdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50R3JvdXAgPT09IHZvaWQgMCAmJiB0aGlzLnJlc2VydmVkSWRsZUdyb3VwID09PSB2b2lkIDA7XG4gIH1cbiAgc2hvdWxkT3ZlcnJpZGVFeHByZXNzaW9uKCkge1xuICAgIHJldHVybiAhY29uZmlnLnByZXNlcnZlRXhwcmVzc2lvbk9uTW90aW9uICYmIHRoaXMuY3VycmVudFByaW9yaXR5ID4gMTtcbiAgfVxuICBkdW1wKHJlcXVlc3RlZEdyb3VwLCByZXF1ZXN0ZWRJbmRleCkge1xuICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICBcImN1cnJlbnRQcmlvcml0eVwiLFxuICAgICAgICBcInJlc2VydmVQcmlvcml0eVwiLFxuICAgICAgICBcImN1cnJlbnRHcm91cFwiLFxuICAgICAgICBcImN1cnJlbnRJbmRleFwiLFxuICAgICAgICBcInJlc2VydmVkR3JvdXBcIixcbiAgICAgICAgXCJyZXNlcnZlZEluZGV4XCIsXG4gICAgICAgIFwicmVzZXJ2ZWRJZGxlR3JvdXBcIixcbiAgICAgICAgXCJyZXNlcnZlZElkbGVJbmRleFwiXG4gICAgICBdO1xuICAgICAgcmV0dXJuIGBcbjxSZXF1ZXN0ZWQ+IGdyb3VwID0gXCIke3JlcXVlc3RlZEdyb3VwfVwiLCBpbmRleCA9ICR7cmVxdWVzdGVkSW5kZXh9XG5gICsga2V5cy5tYXAoKGtleSkgPT4gXCJbXCIgKyBrZXkgKyBcIl0gXCIgKyB0aGlzW2tleV0pLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuICAgIHJldHVybiBcIlwiO1xuICB9XG59XG5jb25zdCBUQUckMiA9IFwiU291bmRNYW5hZ2VyXCI7XG5jb25zdCBWT0xVTUUgPSAwLjU7XG5jbGFzcyBTb3VuZE1hbmFnZXIge1xuICBzdGF0aWMgZ2V0IHZvbHVtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdm9sdW1lO1xuICB9XG4gIHN0YXRpYyBzZXQgdm9sdW1lKHZhbHVlKSB7XG4gICAgdGhpcy5fdm9sdW1lID0gKHZhbHVlID4gMSA/IDEgOiB2YWx1ZSA8IDAgPyAwIDogdmFsdWUpIHx8IDA7XG4gICAgdGhpcy5hdWRpb3MuZm9yRWFjaCgoYXVkaW8pID0+IGF1ZGlvLnZvbHVtZSA9IHRoaXMuX3ZvbHVtZSk7XG4gIH1cbiAgc3RhdGljIGFkZChmaWxlLCBvbkZpbmlzaCwgb25FcnJvcikge1xuICAgIGNvbnN0IGF1ZGlvID0gbmV3IEF1ZGlvKGZpbGUpO1xuICAgIGF1ZGlvLnZvbHVtZSA9IHRoaXMuX3ZvbHVtZTtcbiAgICBhdWRpby5wcmVsb2FkID0gXCJhdXRvXCI7XG4gICAgYXVkaW8uYWRkRXZlbnRMaXN0ZW5lcihcImVuZGVkXCIsICgpID0+IHtcbiAgICAgIHRoaXMuZGlzcG9zZShhdWRpbyk7XG4gICAgICBvbkZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25GaW5pc2goKTtcbiAgICB9KTtcbiAgICBhdWRpby5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKGUpID0+IHtcbiAgICAgIHRoaXMuZGlzcG9zZShhdWRpbyk7XG4gICAgICBsb2dnZXIud2FybihUQUckMiwgYEVycm9yIG9jY3VycmVkIG9uIFwiJHtmaWxlfVwiYCwgZS5lcnJvcik7XG4gICAgICBvbkVycm9yID09IG51bGwgPyB2b2lkIDAgOiBvbkVycm9yKGUuZXJyb3IpO1xuICAgIH0pO1xuICAgIHRoaXMuYXVkaW9zLnB1c2goYXVkaW8pO1xuICAgIHJldHVybiBhdWRpbztcbiAgfVxuICBzdGF0aWMgcGxheShhdWRpbykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSBhdWRpby5wbGF5KCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICBhdWRpby5kaXNwYXRjaEV2ZW50KG5ldyBFcnJvckV2ZW50KFwiZXJyb3JcIiwgeyBlcnJvcjogZSB9KSk7XG4gICAgICAgIHJlamVjdChlKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGF1ZGlvLnJlYWR5U3RhdGUgPT09IGF1ZGlvLkhBVkVfRU5PVUdIX0RBVEEpIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXVkaW8uYWRkRXZlbnRMaXN0ZW5lcihcImNhbnBsYXl0aHJvdWdoXCIsIHJlc29sdmUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBkaXNwb3NlKGF1ZGlvKSB7XG4gICAgYXVkaW8ucGF1c2UoKTtcbiAgICBhdWRpby5yZW1vdmVBdHRyaWJ1dGUoXCJzcmNcIik7XG4gICAgcmVtb3ZlKHRoaXMuYXVkaW9zLCBhdWRpbyk7XG4gIH1cbiAgc3RhdGljIGRlc3Ryb3koKSB7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMuYXVkaW9zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0aGlzLmRpc3Bvc2UodGhpcy5hdWRpb3NbaV0pO1xuICAgIH1cbiAgfVxufVxuU291bmRNYW5hZ2VyLmF1ZGlvcyA9IFtdO1xuU291bmRNYW5hZ2VyLl92b2x1bWUgPSBWT0xVTUU7XG52YXIgTW90aW9uUHJlbG9hZFN0cmF0ZWd5ID0gLyogQF9fUFVSRV9fICovICgoTW90aW9uUHJlbG9hZFN0cmF0ZWd5MikgPT4ge1xuICBNb3Rpb25QcmVsb2FkU3RyYXRlZ3kyW1wiQUxMXCJdID0gXCJBTExcIjtcbiAgTW90aW9uUHJlbG9hZFN0cmF0ZWd5MltcIklETEVcIl0gPSBcIklETEVcIjtcbiAgTW90aW9uUHJlbG9hZFN0cmF0ZWd5MltcIk5PTkVcIl0gPSBcIk5PTkVcIjtcbiAgcmV0dXJuIE1vdGlvblByZWxvYWRTdHJhdGVneTI7XG59KShNb3Rpb25QcmVsb2FkU3RyYXRlZ3kgfHwge30pO1xuY2xhc3MgTW90aW9uTWFuYWdlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm1vdGlvbkdyb3VwcyA9IHt9O1xuICAgIHRoaXMuc3RhdGUgPSBuZXcgTW90aW9uU3RhdGUoKTtcbiAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB0aGlzLnRhZyA9IGBNb3Rpb25NYW5hZ2VyKCR7c2V0dGluZ3MubmFtZX0pYDtcbiAgICB0aGlzLnN0YXRlLnRhZyA9IHRoaXMudGFnO1xuICB9XG4gIGluaXQob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmlkbGVNb3Rpb25Hcm91cCkge1xuICAgICAgdGhpcy5ncm91cHMuaWRsZSA9IG9wdGlvbnMuaWRsZU1vdGlvbkdyb3VwO1xuICAgIH1cbiAgICB0aGlzLnNldHVwTW90aW9ucyhvcHRpb25zKTtcbiAgICB0aGlzLnN0b3BBbGxNb3Rpb25zKCk7XG4gIH1cbiAgc2V0dXBNb3Rpb25zKG9wdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIE9iamVjdC5rZXlzKHRoaXMuZGVmaW5pdGlvbnMpKSB7XG4gICAgICB0aGlzLm1vdGlvbkdyb3Vwc1tncm91cF0gPSBbXTtcbiAgICB9XG4gICAgbGV0IGdyb3VwcztcbiAgICBzd2l0Y2ggKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubW90aW9uUHJlbG9hZCkge1xuICAgICAgY2FzZSBcIk5PTkVcIjpcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIkFMTFwiOlxuICAgICAgICBncm91cHMgPSBPYmplY3Qua2V5cyh0aGlzLmRlZmluaXRpb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiSURMRVwiOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZ3JvdXBzID0gW3RoaXMuZ3JvdXBzLmlkbGVdO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yIChjb25zdCBncm91cCBvZiBncm91cHMpIHtcbiAgICAgIGlmICh0aGlzLmRlZmluaXRpb25zW2dyb3VwXSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGVmaW5pdGlvbnNbZ3JvdXBdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5sb2FkTW90aW9uKGdyb3VwLCBpKS50aGVuKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbG9hZE1vdGlvbihncm91cCwgaW5kZXgpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKCEoKF9hID0gdGhpcy5kZWZpbml0aW9uc1tncm91cF0pID09IG51bGwgPyB2b2lkIDAgOiBfYVtpbmRleF0pKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKHRoaXMudGFnLCBgVW5kZWZpbmVkIG1vdGlvbiBhdCBcIiR7Z3JvdXB9XCJbJHtpbmRleH1dYCk7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tb3Rpb25Hcm91cHNbZ3JvdXBdW2luZGV4XSA9PT0gbnVsbCkge1xuICAgICAgICBsb2dnZXIud2Fybih0aGlzLnRhZywgYENhbm5vdCBzdGFydCBtb3Rpb24gYXQgXCIke2dyb3VwfVwiWyR7aW5kZXh9XSBiZWNhdXNlIGl0J3MgYWxyZWFkeSBmYWlsZWQgaW4gbG9hZGluZy5gKTtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1vdGlvbkdyb3Vwc1tncm91cF1baW5kZXhdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vdGlvbkdyb3Vwc1tncm91cF1baW5kZXhdO1xuICAgICAgfVxuICAgICAgY29uc3QgbW90aW9uID0geWllbGQgdGhpcy5fbG9hZE1vdGlvbihncm91cCwgaW5kZXgpO1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubW90aW9uR3JvdXBzW2dyb3VwXVtpbmRleF0gPSBtb3Rpb24gIT0gbnVsbCA/IG1vdGlvbiA6IG51bGw7XG4gICAgICByZXR1cm4gbW90aW9uO1xuICAgIH0pO1xuICB9XG4gIF9sb2FkTW90aW9uKGdyb3VwLCBpbmRleCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZC5cIik7XG4gIH1cbiAgc3RhcnRNb3Rpb24oXzAsIF8xKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKGdyb3VwLCBpbmRleCwgcHJpb3JpdHkgPSBNb3Rpb25Qcmlvcml0eS5OT1JNQUwpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICghdGhpcy5zdGF0ZS5yZXNlcnZlKGdyb3VwLCBpbmRleCwgcHJpb3JpdHkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlZmluaXRpb24gPSAoX2EgPSB0aGlzLmRlZmluaXRpb25zW2dyb3VwXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hW2luZGV4XTtcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jdXJyZW50QXVkaW8pIHtcbiAgICAgICAgU291bmRNYW5hZ2VyLmRpc3Bvc2UodGhpcy5jdXJyZW50QXVkaW8pO1xuICAgICAgfVxuICAgICAgbGV0IGF1ZGlvO1xuICAgICAgaWYgKGNvbmZpZy5zb3VuZCkge1xuICAgICAgICBjb25zdCBzb3VuZFVSTCA9IHRoaXMuZ2V0U291bmRGaWxlKGRlZmluaXRpb24pO1xuICAgICAgICBpZiAoc291bmRVUkwpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXVkaW8gPSBTb3VuZE1hbmFnZXIuYWRkKHRoaXMuc2V0dGluZ3MucmVzb2x2ZVVSTChzb3VuZFVSTCksICgpID0+IHRoaXMuY3VycmVudEF1ZGlvID0gdm9pZCAwLCAoKSA9PiB0aGlzLmN1cnJlbnRBdWRpbyA9IHZvaWQgMCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRBdWRpbyA9IGF1ZGlvO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKHRoaXMudGFnLCBcIkZhaWxlZCB0byBjcmVhdGUgYXVkaW9cIiwgc291bmRVUkwsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgbW90aW9uID0geWllbGQgdGhpcy5sb2FkTW90aW9uKGdyb3VwLCBpbmRleCk7XG4gICAgICBpZiAoYXVkaW8pIHtcbiAgICAgICAgY29uc3QgcmVhZHlUb1BsYXkgPSBTb3VuZE1hbmFnZXIucGxheShhdWRpbykuY2F0Y2goKGUpID0+IGxvZ2dlci53YXJuKHRoaXMudGFnLCBcIkZhaWxlZCB0byBwbGF5IGF1ZGlvXCIsIGF1ZGlvLnNyYywgZSkpO1xuICAgICAgICBpZiAoY29uZmlnLm1vdGlvblN5bmMpIHtcbiAgICAgICAgICB5aWVsZCByZWFkeVRvUGxheTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnN0YXRlLnN0YXJ0KG1vdGlvbiwgZ3JvdXAsIGluZGV4LCBwcmlvcml0eSkpIHtcbiAgICAgICAgaWYgKGF1ZGlvKSB7XG4gICAgICAgICAgU291bmRNYW5hZ2VyLmRpc3Bvc2UoYXVkaW8pO1xuICAgICAgICAgIHRoaXMuY3VycmVudEF1ZGlvID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGxvZ2dlci5sb2codGhpcy50YWcsIFwiU3RhcnQgbW90aW9uOlwiLCB0aGlzLmdldE1vdGlvbk5hbWUoZGVmaW5pdGlvbikpO1xuICAgICAgdGhpcy5lbWl0KFwibW90aW9uU3RhcnRcIiwgZ3JvdXAsIGluZGV4LCBhdWRpbyk7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5zaG91bGRPdmVycmlkZUV4cHJlc3Npb24oKSkge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25NYW5hZ2VyICYmIHRoaXMuZXhwcmVzc2lvbk1hbmFnZXIucmVzZXRFeHByZXNzaW9uKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnBsYXlpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5fc3RhcnRNb3Rpb24obW90aW9uKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG4gIHN0YXJ0UmFuZG9tTW90aW9uKGdyb3VwLCBwcmlvcml0eSkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBncm91cERlZnMgPSB0aGlzLmRlZmluaXRpb25zW2dyb3VwXTtcbiAgICAgIGlmIChncm91cERlZnMgPT0gbnVsbCA/IHZvaWQgMCA6IGdyb3VwRGVmcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlSW5kaWNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwRGVmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh0aGlzLm1vdGlvbkdyb3Vwc1tncm91cF1baV0gIT09IG51bGwgJiYgIXRoaXMuc3RhdGUuaXNBY3RpdmUoZ3JvdXAsIGkpKSB7XG4gICAgICAgICAgICBhdmFpbGFibGVJbmRpY2VzLnB1c2goaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhdmFpbGFibGVJbmRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXZhaWxhYmxlSW5kaWNlcy5sZW5ndGgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0TW90aW9uKGdyb3VwLCBhdmFpbGFibGVJbmRpY2VzW2luZGV4XSwgcHJpb3JpdHkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gIH1cbiAgc3RvcEFsbE1vdGlvbnMoKSB7XG4gICAgdGhpcy5fc3RvcEFsbE1vdGlvbnMoKTtcbiAgICB0aGlzLnN0YXRlLnJlc2V0KCk7XG4gICAgaWYgKHRoaXMuY3VycmVudEF1ZGlvKSB7XG4gICAgICBTb3VuZE1hbmFnZXIuZGlzcG9zZSh0aGlzLmN1cnJlbnRBdWRpbyk7XG4gICAgICB0aGlzLmN1cnJlbnRBdWRpbyA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgdXBkYXRlKG1vZGVsLCBub3cpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHRoaXMuaXNGaW5pc2hlZCgpKSB7XG4gICAgICBpZiAodGhpcy5wbGF5aW5nKSB7XG4gICAgICAgIHRoaXMucGxheWluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXQoXCJtb3Rpb25GaW5pc2hcIik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGF0ZS5zaG91bGRPdmVycmlkZUV4cHJlc3Npb24oKSkge1xuICAgICAgICAoX2EgPSB0aGlzLmV4cHJlc3Npb25NYW5hZ2VyKSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVzdG9yZUV4cHJlc3Npb24oKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhdGUuY29tcGxldGUoKTtcbiAgICAgIGlmICh0aGlzLnN0YXRlLnNob3VsZFJlcXVlc3RJZGxlTW90aW9uKCkpIHtcbiAgICAgICAgdGhpcy5zdGFydFJhbmRvbU1vdGlvbih0aGlzLmdyb3Vwcy5pZGxlLCBNb3Rpb25Qcmlvcml0eS5JRExFKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlUGFyYW1ldGVycyhtb2RlbCwgbm93KTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHZhciBfYTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgdGhpcy5lbWl0KFwiZGVzdHJveVwiKTtcbiAgICB0aGlzLnN0b3BBbGxNb3Rpb25zKCk7XG4gICAgKF9hID0gdGhpcy5leHByZXNzaW9uTWFuYWdlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRlc3Ryb3koKTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBzZWxmLmRlZmluaXRpb25zID0gdm9pZCAwO1xuICAgIHNlbGYubW90aW9uR3JvdXBzID0gdm9pZCAwO1xuICB9XG59XG5jb25zdCB0ZW1wQm91bmRzID0geyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG5jbGFzcyBJbnRlcm5hbE1vZGVsIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmZvY3VzQ29udHJvbGxlciA9IG5ldyBGb2N1c0NvbnRyb2xsZXIoKTtcbiAgICB0aGlzLm9yaWdpbmFsV2lkdGggPSAwO1xuICAgIHRoaXMub3JpZ2luYWxIZWlnaHQgPSAwO1xuICAgIHRoaXMud2lkdGggPSAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICB0aGlzLmxvY2FsVHJhbnNmb3JtID0gbmV3IE1hdHJpeCgpO1xuICAgIHRoaXMuZHJhd2luZ01hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICB0aGlzLmhpdEFyZWFzID0ge307XG4gICAgdGhpcy50ZXh0dXJlRmxpcFkgPSBmYWxzZTtcbiAgICB0aGlzLnZpZXdwb3J0ID0gWzAsIDAsIDAsIDBdO1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICB0aGlzLnNldHVwTGF5b3V0KCk7XG4gICAgdGhpcy5zZXR1cEhpdEFyZWFzKCk7XG4gIH1cbiAgc2V0dXBMYXlvdXQoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xuICAgIHNlbGYub3JpZ2luYWxXaWR0aCA9IHNpemVbMF07XG4gICAgc2VsZi5vcmlnaW5hbEhlaWdodCA9IHNpemVbMV07XG4gICAgY29uc3QgbGF5b3V0ID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICB3aWR0aDogTE9HSUNBTF9XSURUSCxcbiAgICAgIGhlaWdodDogTE9HSUNBTF9IRUlHSFRcbiAgICB9LCB0aGlzLmdldExheW91dCgpKTtcbiAgICB0aGlzLmxvY2FsVHJhbnNmb3JtLnNjYWxlKGxheW91dC53aWR0aCAvIExPR0lDQUxfV0lEVEgsIGxheW91dC5oZWlnaHQgLyBMT0dJQ0FMX0hFSUdIVCk7XG4gICAgc2VsZi53aWR0aCA9IHRoaXMub3JpZ2luYWxXaWR0aCAqIHRoaXMubG9jYWxUcmFuc2Zvcm0uYTtcbiAgICBzZWxmLmhlaWdodCA9IHRoaXMub3JpZ2luYWxIZWlnaHQgKiB0aGlzLmxvY2FsVHJhbnNmb3JtLmQ7XG4gICAgY29uc3Qgb2Zmc2V0WCA9IGxheW91dC54ICE9PSB2b2lkIDAgJiYgbGF5b3V0LnggLSBsYXlvdXQud2lkdGggLyAyIHx8IGxheW91dC5jZW50ZXJYICE9PSB2b2lkIDAgJiYgbGF5b3V0LmNlbnRlclggfHwgbGF5b3V0LmxlZnQgIT09IHZvaWQgMCAmJiBsYXlvdXQubGVmdCAtIGxheW91dC53aWR0aCAvIDIgfHwgbGF5b3V0LnJpZ2h0ICE9PSB2b2lkIDAgJiYgbGF5b3V0LnJpZ2h0ICsgbGF5b3V0LndpZHRoIC8gMiB8fCAwO1xuICAgIGNvbnN0IG9mZnNldFkgPSBsYXlvdXQueSAhPT0gdm9pZCAwICYmIGxheW91dC55IC0gbGF5b3V0LmhlaWdodCAvIDIgfHwgbGF5b3V0LmNlbnRlclkgIT09IHZvaWQgMCAmJiBsYXlvdXQuY2VudGVyWSB8fCBsYXlvdXQudG9wICE9PSB2b2lkIDAgJiYgbGF5b3V0LnRvcCAtIGxheW91dC5oZWlnaHQgLyAyIHx8IGxheW91dC5ib3R0b20gIT09IHZvaWQgMCAmJiBsYXlvdXQuYm90dG9tICsgbGF5b3V0LmhlaWdodCAvIDIgfHwgMDtcbiAgICB0aGlzLmxvY2FsVHJhbnNmb3JtLnRyYW5zbGF0ZSh0aGlzLndpZHRoICogb2Zmc2V0WCwgLXRoaXMuaGVpZ2h0ICogb2Zmc2V0WSk7XG4gIH1cbiAgc2V0dXBIaXRBcmVhcygpIHtcbiAgICBjb25zdCBkZWZpbml0aW9ucyA9IHRoaXMuZ2V0SGl0QXJlYURlZnMoKS5maWx0ZXIoKGhpdEFyZWEpID0+IGhpdEFyZWEuaW5kZXggPj0gMCk7XG4gICAgZm9yIChjb25zdCBkZWYgb2YgZGVmaW5pdGlvbnMpIHtcbiAgICAgIHRoaXMuaGl0QXJlYXNbZGVmLm5hbWVdID0gZGVmO1xuICAgIH1cbiAgfVxuICBoaXRUZXN0KHgsIHkpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5oaXRBcmVhcykuZmlsdGVyKChoaXRBcmVhTmFtZSkgPT4gdGhpcy5pc0hpdChoaXRBcmVhTmFtZSwgeCwgeSkpO1xuICB9XG4gIGlzSGl0KGhpdEFyZWFOYW1lLCB4LCB5KSB7XG4gICAgaWYgKCF0aGlzLmhpdEFyZWFzW2hpdEFyZWFOYW1lXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBkcmF3SW5kZXggPSB0aGlzLmhpdEFyZWFzW2hpdEFyZWFOYW1lXS5pbmRleDtcbiAgICBjb25zdCBib3VuZHMgPSB0aGlzLmdldERyYXdhYmxlQm91bmRzKGRyYXdJbmRleCwgdGVtcEJvdW5kcyk7XG4gICAgcmV0dXJuIGJvdW5kcy54IDw9IHggJiYgeCA8PSBib3VuZHMueCArIGJvdW5kcy53aWR0aCAmJiBib3VuZHMueSA8PSB5ICYmIHkgPD0gYm91bmRzLnkgKyBib3VuZHMuaGVpZ2h0O1xuICB9XG4gIGdldERyYXdhYmxlQm91bmRzKGluZGV4LCBib3VuZHMpIHtcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IHRoaXMuZ2V0RHJhd2FibGVWZXJ0aWNlcyhpbmRleCk7XG4gICAgbGV0IGxlZnQgPSB2ZXJ0aWNlc1swXTtcbiAgICBsZXQgcmlnaHQgPSB2ZXJ0aWNlc1swXTtcbiAgICBsZXQgdG9wID0gdmVydGljZXNbMV07XG4gICAgbGV0IGJvdHRvbSA9IHZlcnRpY2VzWzFdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHZ4ID0gdmVydGljZXNbaV07XG4gICAgICBjb25zdCB2eSA9IHZlcnRpY2VzW2kgKyAxXTtcbiAgICAgIGxlZnQgPSBNYXRoLm1pbih2eCwgbGVmdCk7XG4gICAgICByaWdodCA9IE1hdGgubWF4KHZ4LCByaWdodCk7XG4gICAgICB0b3AgPSBNYXRoLm1pbih2eSwgdG9wKTtcbiAgICAgIGJvdHRvbSA9IE1hdGgubWF4KHZ5LCBib3R0b20pO1xuICAgIH1cbiAgICBib3VuZHMgIT0gbnVsbCA/IGJvdW5kcyA6IGJvdW5kcyA9IHt9O1xuICAgIGJvdW5kcy54ID0gbGVmdDtcbiAgICBib3VuZHMueSA9IHRvcDtcbiAgICBib3VuZHMud2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgYm91bmRzLmhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgICByZXR1cm4gYm91bmRzO1xuICB9XG4gIHVwZGF0ZVRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgICB0aGlzLmRyYXdpbmdNYXRyaXguY29weUZyb20odHJhbnNmb3JtKS5hcHBlbmQodGhpcy5sb2NhbFRyYW5zZm9ybSk7XG4gIH1cbiAgdXBkYXRlKGR0LCBub3cpIHtcbiAgICB0aGlzLmZvY3VzQ29udHJvbGxlci51cGRhdGUoZHQpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRoaXMuZW1pdChcImRlc3Ryb3lcIik7XG4gICAgdGhpcy5tb3Rpb25NYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLm1vdGlvbk1hbmFnZXIgPSB2b2lkIDA7XG4gIH1cbn1cbmNvbnN0IFRBRyQxID0gXCJYSFJMb2FkZXJcIjtcbmNsYXNzIE5ldHdvcmtFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgdXJsMiwgc3RhdHVzLCBhYm9ydGVkID0gZmFsc2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLnVybCA9IHVybDI7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5hYm9ydGVkID0gYWJvcnRlZDtcbiAgfVxufVxuY29uc3QgX1hIUkxvYWRlciA9IGNsYXNzIHtcbiAgc3RhdGljIGNyZWF0ZVhIUih0YXJnZXQsIHVybDIsIHR5cGUsIG9ubG9hZCwgb25lcnJvcikge1xuICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIF9YSFJMb2FkZXIuYWxsWGhyU2V0LmFkZCh4aHIpO1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIGxldCB4aHJTZXQgPSBfWEhSTG9hZGVyLnhock1hcC5nZXQodGFyZ2V0KTtcbiAgICAgIGlmICgheGhyU2V0KSB7XG4gICAgICAgIHhoclNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFt4aHJdKTtcbiAgICAgICAgX1hIUkxvYWRlci54aHJNYXAuc2V0KHRhcmdldCwgeGhyU2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHhoclNldC5hZGQoeGhyKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGFyZ2V0Lmxpc3RlbmVycyhcImRlc3Ryb3lcIikuaW5jbHVkZXMoX1hIUkxvYWRlci5jYW5jZWxYSFJzKSkge1xuICAgICAgICB0YXJnZXQub25jZShcImRlc3Ryb3lcIiwgX1hIUkxvYWRlci5jYW5jZWxYSFJzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgeGhyLm9wZW4oXCJHRVRcIiwgdXJsMik7XG4gICAgeGhyLnJlc3BvbnNlVHlwZSA9IHR5cGU7XG4gICAgeGhyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIGlmICgoeGhyLnN0YXR1cyA9PT0gMjAwIHx8IHhoci5zdGF0dXMgPT09IDApICYmIHhoci5yZXNwb25zZSkge1xuICAgICAgICBvbmxvYWQoeGhyLnJlc3BvbnNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHhoci5vbmVycm9yKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB4aHIub25lcnJvciA9ICgpID0+IHtcbiAgICAgIGxvZ2dlci53YXJuKFRBRyQxLCBgRmFpbGVkIHRvIGxvYWQgcmVzb3VyY2UgYXMgJHt4aHIucmVzcG9uc2VUeXBlfSAoU3RhdHVzICR7eGhyLnN0YXR1c30pOiAke3VybDJ9YCk7XG4gICAgICBvbmVycm9yKG5ldyBOZXR3b3JrRXJyb3IoXCJOZXR3b3JrIGVycm9yLlwiLCB1cmwyLCB4aHIuc3RhdHVzKSk7XG4gICAgfTtcbiAgICB4aHIub25hYm9ydCA9ICgpID0+IG9uZXJyb3IobmV3IE5ldHdvcmtFcnJvcihcIkFib3J0ZWQuXCIsIHVybDIsIHhoci5zdGF0dXMsIHRydWUpKTtcbiAgICB4aHIub25sb2FkZW5kID0gKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgX1hIUkxvYWRlci5hbGxYaHJTZXQuZGVsZXRlKHhocik7XG4gICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgIChfYSA9IF9YSFJMb2FkZXIueGhyTWFwLmdldCh0YXJnZXQpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZGVsZXRlKHhocik7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4geGhyO1xuICB9XG4gIHN0YXRpYyBjYW5jZWxYSFJzKCkge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSBfWEhSTG9hZGVyLnhock1hcC5nZXQodGhpcykpID09IG51bGwgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKCh4aHIpID0+IHtcbiAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgX1hIUkxvYWRlci5hbGxYaHJTZXQuZGVsZXRlKHhocik7XG4gICAgfSk7XG4gICAgX1hIUkxvYWRlci54aHJNYXAuZGVsZXRlKHRoaXMpO1xuICB9XG4gIHN0YXRpYyByZWxlYXNlKCkge1xuICAgIF9YSFJMb2FkZXIuYWxsWGhyU2V0LmZvckVhY2goKHhocikgPT4geGhyLmFib3J0KCkpO1xuICAgIF9YSFJMb2FkZXIuYWxsWGhyU2V0LmNsZWFyKCk7XG4gICAgX1hIUkxvYWRlci54aHJNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgfVxufTtcbmxldCBYSFJMb2FkZXIgPSBfWEhSTG9hZGVyO1xuWEhSTG9hZGVyLnhock1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuWEhSTG9hZGVyLmFsbFhoclNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG5YSFJMb2FkZXIubG9hZGVyID0gKGNvbnRleHQsIG5leHQpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCB4aHIgPSBfWEhSTG9hZGVyLmNyZWF0ZVhIUihjb250ZXh0LnRhcmdldCwgY29udGV4dC5zZXR0aW5ncyA/IGNvbnRleHQuc2V0dGluZ3MucmVzb2x2ZVVSTChjb250ZXh0LnVybCkgOiBjb250ZXh0LnVybCwgY29udGV4dC50eXBlLCAoZGF0YSkgPT4ge1xuICAgICAgY29udGV4dC5yZXN1bHQgPSBkYXRhO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0sIHJlamVjdCk7XG4gICAgeGhyLnNlbmQoKTtcbiAgfSk7XG59O1xuZnVuY3Rpb24gcnVuTWlkZGxld2FyZXMobWlkZGxld2FyZSwgY29udGV4dCkge1xuICBsZXQgaW5kZXggPSAtMTtcbiAgcmV0dXJuIGRpc3BhdGNoKDApO1xuICBmdW5jdGlvbiBkaXNwYXRjaChpLCBlcnIpIHtcbiAgICBpZiAoZXJyKVxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgaWYgKGkgPD0gaW5kZXgpXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwibmV4dCgpIGNhbGxlZCBtdWx0aXBsZSB0aW1lc1wiKSk7XG4gICAgaW5kZXggPSBpO1xuICAgIGNvbnN0IGZuID0gbWlkZGxld2FyZVtpXTtcbiAgICBpZiAoIWZuKVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZuKGNvbnRleHQsIGRpc3BhdGNoLmJpbmQobnVsbCwgaSArIDEpKSk7XG4gICAgfSBjYXRjaCAoZXJyMikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycjIpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgTGl2ZTJETG9hZGVyIHtcbiAgc3RhdGljIGxvYWQoY29udGV4dCkge1xuICAgIHJldHVybiBydW5NaWRkbGV3YXJlcyh0aGlzLm1pZGRsZXdhcmVzLCBjb250ZXh0KS50aGVuKCgpID0+IGNvbnRleHQucmVzdWx0KTtcbiAgfVxufVxuTGl2ZTJETG9hZGVyLm1pZGRsZXdhcmVzID0gW1hIUkxvYWRlci5sb2FkZXJdO1xuZnVuY3Rpb24gY3JlYXRlVGV4dHVyZSh1cmwyLCBvcHRpb25zID0ge30pIHtcbiAgdmFyIF9hO1xuICBjb25zdCB0ZXh0dXJlT3B0aW9ucyA9IHsgcmVzb3VyY2VPcHRpb25zOiB7IGNyb3Nzb3JpZ2luOiBvcHRpb25zLmNyb3NzT3JpZ2luIH0gfTtcbiAgaWYgKFRleHR1cmUuZnJvbVVSTCkge1xuICAgIHJldHVybiBUZXh0dXJlLmZyb21VUkwodXJsMiwgdGV4dHVyZU9wdGlvbnMpLmNhdGNoKChlKSA9PiB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXCJUZXh0dXJlIGxvYWRpbmcgZXJyb3JcIik7XG4gICAgICBlcnIuZXZlbnQgPSBlO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xuICB9XG4gIHRleHR1cmVPcHRpb25zLnJlc291cmNlT3B0aW9ucy5hdXRvTG9hZCA9IGZhbHNlO1xuICBjb25zdCB0ZXh0dXJlID0gVGV4dHVyZS5mcm9tKHVybDIsIHRleHR1cmVPcHRpb25zKTtcbiAgaWYgKHRleHR1cmUuYmFzZVRleHR1cmUudmFsaWQpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRleHR1cmUpO1xuICB9XG4gIGNvbnN0IHJlc291cmNlID0gdGV4dHVyZS5iYXNlVGV4dHVyZS5yZXNvdXJjZTtcbiAgKF9hID0gcmVzb3VyY2UuX2xpdmUyZF9sb2FkKSAhPSBudWxsID8gX2EgOiByZXNvdXJjZS5fbGl2ZTJkX2xvYWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgZXJyb3JIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICByZXNvdXJjZS5zb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGVycm9ySGFuZGxlcik7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXCJUZXh0dXJlIGxvYWRpbmcgZXJyb3JcIik7XG4gICAgICBlcnIuZXZlbnQgPSBldmVudDtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH07XG4gICAgcmVzb3VyY2Uuc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBlcnJvckhhbmRsZXIpO1xuICAgIHJlc291cmNlLmxvYWQoKS50aGVuKCgpID0+IHJlc29sdmUodGV4dHVyZSkpLmNhdGNoKGVycm9ySGFuZGxlcik7XG4gIH0pO1xuICByZXR1cm4gcmVzb3VyY2UuX2xpdmUyZF9sb2FkO1xufVxuY29uc3QgVEFHID0gXCJMaXZlMkRGYWN0b3J5XCI7XG5jb25zdCB1cmxUb0pTT04gPSAoY29udGV4dCwgbmV4dCkgPT4gX19hc3luYyh2b2lkIDAsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gIGlmICh0eXBlb2YgY29udGV4dC5zb3VyY2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCBkYXRhID0geWllbGQgTGl2ZTJETG9hZGVyLmxvYWQoe1xuICAgICAgdXJsOiBjb250ZXh0LnNvdXJjZSxcbiAgICAgIHR5cGU6IFwianNvblwiLFxuICAgICAgdGFyZ2V0OiBjb250ZXh0LmxpdmUyZE1vZGVsXG4gICAgfSk7XG4gICAgZGF0YS51cmwgPSBjb250ZXh0LnNvdXJjZTtcbiAgICBjb250ZXh0LnNvdXJjZSA9IGRhdGE7XG4gICAgY29udGV4dC5saXZlMmRNb2RlbC5lbWl0KFwic2V0dGluZ3NKU09OTG9hZGVkXCIsIGRhdGEpO1xuICB9XG4gIHJldHVybiBuZXh0KCk7XG59KTtcbmNvbnN0IGpzb25Ub1NldHRpbmdzID0gKGNvbnRleHQsIG5leHQpID0+IF9fYXN5bmModm9pZCAwLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICBpZiAoY29udGV4dC5zb3VyY2UgaW5zdGFuY2VvZiBNb2RlbFNldHRpbmdzKSB7XG4gICAgY29udGV4dC5zZXR0aW5ncyA9IGNvbnRleHQuc291cmNlO1xuICAgIHJldHVybiBuZXh0KCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNvbnRleHQuc291cmNlID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29uc3QgcnVudGltZSA9IExpdmUyREZhY3RvcnkuZmluZFJ1bnRpbWUoY29udGV4dC5zb3VyY2UpO1xuICAgIGlmIChydW50aW1lKSB7XG4gICAgICBjb25zdCBzZXR0aW5ncyA9IHJ1bnRpbWUuY3JlYXRlTW9kZWxTZXR0aW5ncyhjb250ZXh0LnNvdXJjZSk7XG4gICAgICBjb250ZXh0LnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgICBjb250ZXh0LmxpdmUyZE1vZGVsLmVtaXQoXCJzZXR0aW5nc0xvYWRlZFwiLCBzZXR0aW5ncyk7XG4gICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBzZXR0aW5ncyBmb3JtYXQuXCIpO1xufSk7XG5jb25zdCB3YWl0VW50aWxSZWFkeSA9IChjb250ZXh0LCBuZXh0KSA9PiB7XG4gIGlmIChjb250ZXh0LnNldHRpbmdzKSB7XG4gICAgY29uc3QgcnVudGltZSA9IExpdmUyREZhY3RvcnkuZmluZFJ1bnRpbWUoY29udGV4dC5zZXR0aW5ncyk7XG4gICAgaWYgKHJ1bnRpbWUpIHtcbiAgICAgIHJldHVybiBydW50aW1lLnJlYWR5KCkudGhlbihuZXh0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5leHQoKTtcbn07XG5jb25zdCBzZXR1cE9wdGlvbmFscyA9IChjb250ZXh0LCBuZXh0KSA9PiBfX2FzeW5jKHZvaWQgMCwgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgeWllbGQgbmV4dCgpO1xuICBjb25zdCBpbnRlcm5hbE1vZGVsID0gY29udGV4dC5pbnRlcm5hbE1vZGVsO1xuICBpZiAoaW50ZXJuYWxNb2RlbCkge1xuICAgIGNvbnN0IHNldHRpbmdzID0gY29udGV4dC5zZXR0aW5ncztcbiAgICBjb25zdCBydW50aW1lID0gTGl2ZTJERmFjdG9yeS5maW5kUnVudGltZShzZXR0aW5ncyk7XG4gICAgaWYgKHJ1bnRpbWUpIHtcbiAgICAgIGNvbnN0IHRhc2tzID0gW107XG4gICAgICBpZiAoc2V0dGluZ3MucG9zZSkge1xuICAgICAgICB0YXNrcy5wdXNoKExpdmUyRExvYWRlci5sb2FkKHtcbiAgICAgICAgICBzZXR0aW5ncyxcbiAgICAgICAgICB1cmw6IHNldHRpbmdzLnBvc2UsXG4gICAgICAgICAgdHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgdGFyZ2V0OiBpbnRlcm5hbE1vZGVsXG4gICAgICAgIH0pLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICBpbnRlcm5hbE1vZGVsLnBvc2UgPSBydW50aW1lLmNyZWF0ZVBvc2UoaW50ZXJuYWxNb2RlbC5jb3JlTW9kZWwsIGRhdGEpO1xuICAgICAgICAgIGNvbnRleHQubGl2ZTJkTW9kZWwuZW1pdChcInBvc2VMb2FkZWRcIiwgaW50ZXJuYWxNb2RlbC5wb3NlKTtcbiAgICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICBjb250ZXh0LmxpdmUyZE1vZGVsLmVtaXQoXCJwb3NlTG9hZEVycm9yXCIsIGUpO1xuICAgICAgICAgIGxvZ2dlci53YXJuKFRBRywgXCJGYWlsZWQgdG8gbG9hZCBwb3NlLlwiLCBlKTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRpbmdzLnBoeXNpY3MpIHtcbiAgICAgICAgdGFza3MucHVzaChMaXZlMkRMb2FkZXIubG9hZCh7XG4gICAgICAgICAgc2V0dGluZ3MsXG4gICAgICAgICAgdXJsOiBzZXR0aW5ncy5waHlzaWNzLFxuICAgICAgICAgIHR5cGU6IFwianNvblwiLFxuICAgICAgICAgIHRhcmdldDogaW50ZXJuYWxNb2RlbFxuICAgICAgICB9KS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgaW50ZXJuYWxNb2RlbC5waHlzaWNzID0gcnVudGltZS5jcmVhdGVQaHlzaWNzKGludGVybmFsTW9kZWwuY29yZU1vZGVsLCBkYXRhKTtcbiAgICAgICAgICBjb250ZXh0LmxpdmUyZE1vZGVsLmVtaXQoXCJwaHlzaWNzTG9hZGVkXCIsIGludGVybmFsTW9kZWwucGh5c2ljcyk7XG4gICAgICAgIH0pLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgY29udGV4dC5saXZlMmRNb2RlbC5lbWl0KFwicGh5c2ljc0xvYWRFcnJvclwiLCBlKTtcbiAgICAgICAgICBsb2dnZXIud2FybihUQUcsIFwiRmFpbGVkIHRvIGxvYWQgcGh5c2ljcy5cIiwgZSk7XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIGlmICh0YXNrcy5sZW5ndGgpIHtcbiAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwodGFza3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5jb25zdCBzZXR1cEVzc2VudGlhbHMgPSAoY29udGV4dCwgbmV4dCkgPT4gX19hc3luYyh2b2lkIDAsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gIGlmIChjb250ZXh0LnNldHRpbmdzKSB7XG4gICAgY29uc3QgbGl2ZTJETW9kZWwgPSBjb250ZXh0LmxpdmUyZE1vZGVsO1xuICAgIGNvbnN0IHRleHR1cmVMb2FkaW5ncyA9IGNvbnRleHQuc2V0dGluZ3MudGV4dHVyZXMubWFwKCh0ZXgpID0+IHtcbiAgICAgIGNvbnN0IHVybDIgPSBjb250ZXh0LnNldHRpbmdzLnJlc29sdmVVUkwodGV4KTtcbiAgICAgIHJldHVybiBjcmVhdGVUZXh0dXJlKHVybDIsIHsgY3Jvc3NPcmlnaW46IGNvbnRleHQub3B0aW9ucy5jcm9zc09yaWdpbiB9KTtcbiAgICB9KTtcbiAgICB5aWVsZCBuZXh0KCk7XG4gICAgaWYgKGNvbnRleHQuaW50ZXJuYWxNb2RlbCkge1xuICAgICAgbGl2ZTJETW9kZWwuaW50ZXJuYWxNb2RlbCA9IGNvbnRleHQuaW50ZXJuYWxNb2RlbDtcbiAgICAgIGxpdmUyRE1vZGVsLmVtaXQoXCJtb2RlbExvYWRlZFwiLCBjb250ZXh0LmludGVybmFsTW9kZWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWlzc2luZyBpbnRlcm5hbCBtb2RlbC5cIik7XG4gICAgfVxuICAgIGxpdmUyRE1vZGVsLnRleHR1cmVzID0geWllbGQgUHJvbWlzZS5hbGwodGV4dHVyZUxvYWRpbmdzKTtcbiAgICBsaXZlMkRNb2RlbC5lbWl0KFwidGV4dHVyZUxvYWRlZFwiLCBsaXZlMkRNb2RlbC50ZXh0dXJlcyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk1pc3Npbmcgc2V0dGluZ3MuXCIpO1xuICB9XG59KTtcbmNvbnN0IGNyZWF0ZUludGVybmFsTW9kZWwgPSAoY29udGV4dCwgbmV4dCkgPT4gX19hc3luYyh2b2lkIDAsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gIGNvbnN0IHNldHRpbmdzID0gY29udGV4dC5zZXR0aW5ncztcbiAgaWYgKHNldHRpbmdzIGluc3RhbmNlb2YgTW9kZWxTZXR0aW5ncykge1xuICAgIGNvbnN0IHJ1bnRpbWUgPSBMaXZlMkRGYWN0b3J5LmZpbmRSdW50aW1lKHNldHRpbmdzKTtcbiAgICBpZiAoIXJ1bnRpbWUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIG1vZGVsIHNldHRpbmdzLlwiKTtcbiAgICB9XG4gICAgY29uc3QgbW9kZWxEYXRhID0geWllbGQgTGl2ZTJETG9hZGVyLmxvYWQoe1xuICAgICAgc2V0dGluZ3MsXG4gICAgICB1cmw6IHNldHRpbmdzLm1vYyxcbiAgICAgIHR5cGU6IFwiYXJyYXlidWZmZXJcIixcbiAgICAgIHRhcmdldDogY29udGV4dC5saXZlMmRNb2RlbFxuICAgIH0pO1xuICAgIGlmICghcnVudGltZS5pc1ZhbGlkTW9jKG1vZGVsRGF0YSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbW9jIGRhdGFcIik7XG4gICAgfVxuICAgIGNvbnN0IGNvcmVNb2RlbCA9IHJ1bnRpbWUuY3JlYXRlQ29yZU1vZGVsKG1vZGVsRGF0YSk7XG4gICAgY29udGV4dC5pbnRlcm5hbE1vZGVsID0gcnVudGltZS5jcmVhdGVJbnRlcm5hbE1vZGVsKGNvcmVNb2RlbCwgc2V0dGluZ3MsIGNvbnRleHQub3B0aW9ucyk7XG4gICAgcmV0dXJuIG5leHQoKTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWlzc2luZyBzZXR0aW5ncy5cIik7XG59KTtcbmNvbnN0IF9MaXZlMkRGYWN0b3J5ID0gY2xhc3Mge1xuICBzdGF0aWMgcmVnaXN0ZXJSdW50aW1lKHJ1bnRpbWUpIHtcbiAgICBfTGl2ZTJERmFjdG9yeS5ydW50aW1lcy5wdXNoKHJ1bnRpbWUpO1xuICAgIF9MaXZlMkRGYWN0b3J5LnJ1bnRpbWVzLnNvcnQoKGEsIGIpID0+IGIudmVyc2lvbiAtIGEudmVyc2lvbik7XG4gIH1cbiAgc3RhdGljIGZpbmRSdW50aW1lKHNvdXJjZSkge1xuICAgIGZvciAoY29uc3QgcnVudGltZSBvZiBfTGl2ZTJERmFjdG9yeS5ydW50aW1lcykge1xuICAgICAgaWYgKHJ1bnRpbWUudGVzdChzb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiBydW50aW1lO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdGF0aWMgc2V0dXBMaXZlMkRNb2RlbChsaXZlMmRNb2RlbCwgc291cmNlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHRleHR1cmVMb2FkZWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gbGl2ZTJkTW9kZWwub25jZShcInRleHR1cmVMb2FkZWRcIiwgcmVzb2x2ZSkpO1xuICAgICAgY29uc3QgbW9kZWxMb2FkZWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gbGl2ZTJkTW9kZWwub25jZShcIm1vZGVsTG9hZGVkXCIsIHJlc29sdmUpKTtcbiAgICAgIGNvbnN0IHJlYWR5RXZlbnRFbWl0dGVkID0gUHJvbWlzZS5hbGwoW3RleHR1cmVMb2FkZWQsIG1vZGVsTG9hZGVkXSkudGhlbigoKSA9PiBsaXZlMmRNb2RlbC5lbWl0KFwicmVhZHlcIikpO1xuICAgICAgeWllbGQgcnVuTWlkZGxld2FyZXMoX0xpdmUyREZhY3RvcnkubGl2ZTJETW9kZWxNaWRkbGV3YXJlcywge1xuICAgICAgICBsaXZlMmRNb2RlbCxcbiAgICAgICAgc291cmNlLFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zIHx8IHt9XG4gICAgICB9KTtcbiAgICAgIHlpZWxkIHJlYWR5RXZlbnRFbWl0dGVkO1xuICAgICAgbGl2ZTJkTW9kZWwuZW1pdChcImxvYWRcIik7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGxvYWRNb3Rpb24obW90aW9uTWFuYWdlciwgZ3JvdXAsIGluZGV4KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBoYW5kbGVFcnJvciA9IChlKSA9PiBtb3Rpb25NYW5hZ2VyLmVtaXQoXCJtb3Rpb25Mb2FkRXJyb3JcIiwgZ3JvdXAsIGluZGV4LCBlKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IChfYSA9IG1vdGlvbk1hbmFnZXIuZGVmaW5pdGlvbnNbZ3JvdXBdKSA9PSBudWxsID8gdm9pZCAwIDogX2FbaW5kZXhdO1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodm9pZCAwKTtcbiAgICAgIH1cbiAgICAgIGlmICghbW90aW9uTWFuYWdlci5saXN0ZW5lcnMoXCJkZXN0cm95XCIpLmluY2x1ZGVzKF9MaXZlMkRGYWN0b3J5LnJlbGVhc2VUYXNrcykpIHtcbiAgICAgICAgbW90aW9uTWFuYWdlci5vbmNlKFwiZGVzdHJveVwiLCBfTGl2ZTJERmFjdG9yeS5yZWxlYXNlVGFza3MpO1xuICAgICAgfVxuICAgICAgbGV0IHRhc2tzID0gX0xpdmUyREZhY3RvcnkubW90aW9uVGFza3NNYXAuZ2V0KG1vdGlvbk1hbmFnZXIpO1xuICAgICAgaWYgKCF0YXNrcykge1xuICAgICAgICB0YXNrcyA9IHt9O1xuICAgICAgICBfTGl2ZTJERmFjdG9yeS5tb3Rpb25UYXNrc01hcC5zZXQobW90aW9uTWFuYWdlciwgdGFza3MpO1xuICAgICAgfVxuICAgICAgbGV0IHRhc2tHcm91cCA9IHRhc2tzW2dyb3VwXTtcbiAgICAgIGlmICghdGFza0dyb3VwKSB7XG4gICAgICAgIHRhc2tHcm91cCA9IFtdO1xuICAgICAgICB0YXNrc1tncm91cF0gPSB0YXNrR3JvdXA7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXRoID0gbW90aW9uTWFuYWdlci5nZXRNb3Rpb25GaWxlKGRlZmluaXRpb24pO1xuICAgICAgKF9iID0gdGFza0dyb3VwW2luZGV4XSkgIT0gbnVsbCA/IF9iIDogdGFza0dyb3VwW2luZGV4XSA9IExpdmUyRExvYWRlci5sb2FkKHtcbiAgICAgICAgdXJsOiBwYXRoLFxuICAgICAgICBzZXR0aW5nczogbW90aW9uTWFuYWdlci5zZXR0aW5ncyxcbiAgICAgICAgdHlwZTogbW90aW9uTWFuYWdlci5tb3Rpb25EYXRhVHlwZSxcbiAgICAgICAgdGFyZ2V0OiBtb3Rpb25NYW5hZ2VyXG4gICAgICB9KS50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIGNvbnN0IHRhc2tHcm91cDIgPSAoX2EyID0gX0xpdmUyREZhY3RvcnkubW90aW9uVGFza3NNYXAuZ2V0KG1vdGlvbk1hbmFnZXIpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyW2dyb3VwXTtcbiAgICAgICAgaWYgKHRhc2tHcm91cDIpIHtcbiAgICAgICAgICBkZWxldGUgdGFza0dyb3VwMltpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW90aW9uID0gbW90aW9uTWFuYWdlci5jcmVhdGVNb3Rpb24oZGF0YSwgZ3JvdXAsIGRlZmluaXRpb24pO1xuICAgICAgICBtb3Rpb25NYW5hZ2VyLmVtaXQoXCJtb3Rpb25Mb2FkZWRcIiwgZ3JvdXAsIGluZGV4LCBtb3Rpb24pO1xuICAgICAgICByZXR1cm4gbW90aW9uO1xuICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgbG9nZ2VyLndhcm4obW90aW9uTWFuYWdlci50YWcsIGBGYWlsZWQgdG8gbG9hZCBtb3Rpb246ICR7cGF0aH1cbmAsIGUpO1xuICAgICAgICBoYW5kbGVFcnJvcihlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRhc2tHcm91cFtpbmRleF07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgbG9nZ2VyLndhcm4obW90aW9uTWFuYWdlci50YWcsIGBGYWlsZWQgdG8gbG9hZCBtb3Rpb24gYXQgXCIke2dyb3VwfVwiWyR7aW5kZXh9XVxuYCwgZSk7XG4gICAgICBoYW5kbGVFcnJvcihlKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2b2lkIDApO1xuICB9XG4gIHN0YXRpYyBsb2FkRXhwcmVzc2lvbihleHByZXNzaW9uTWFuYWdlciwgaW5kZXgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgaGFuZGxlRXJyb3IgPSAoZSkgPT4gZXhwcmVzc2lvbk1hbmFnZXIuZW1pdChcImV4cHJlc3Npb25Mb2FkRXJyb3JcIiwgaW5kZXgsIGUpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkZWZpbml0aW9uID0gZXhwcmVzc2lvbk1hbmFnZXIuZGVmaW5pdGlvbnNbaW5kZXhdO1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodm9pZCAwKTtcbiAgICAgIH1cbiAgICAgIGlmICghZXhwcmVzc2lvbk1hbmFnZXIubGlzdGVuZXJzKFwiZGVzdHJveVwiKS5pbmNsdWRlcyhfTGl2ZTJERmFjdG9yeS5yZWxlYXNlVGFza3MpKSB7XG4gICAgICAgIGV4cHJlc3Npb25NYW5hZ2VyLm9uY2UoXCJkZXN0cm95XCIsIF9MaXZlMkRGYWN0b3J5LnJlbGVhc2VUYXNrcyk7XG4gICAgICB9XG4gICAgICBsZXQgdGFza3MgPSBfTGl2ZTJERmFjdG9yeS5leHByZXNzaW9uVGFza3NNYXAuZ2V0KGV4cHJlc3Npb25NYW5hZ2VyKTtcbiAgICAgIGlmICghdGFza3MpIHtcbiAgICAgICAgdGFza3MgPSBbXTtcbiAgICAgICAgX0xpdmUyREZhY3RvcnkuZXhwcmVzc2lvblRhc2tzTWFwLnNldChleHByZXNzaW9uTWFuYWdlciwgdGFza3MpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGF0aCA9IGV4cHJlc3Npb25NYW5hZ2VyLmdldEV4cHJlc3Npb25GaWxlKGRlZmluaXRpb24pO1xuICAgICAgKF9hID0gdGFza3NbaW5kZXhdKSAhPSBudWxsID8gX2EgOiB0YXNrc1tpbmRleF0gPSBMaXZlMkRMb2FkZXIubG9hZCh7XG4gICAgICAgIHVybDogcGF0aCxcbiAgICAgICAgc2V0dGluZ3M6IGV4cHJlc3Npb25NYW5hZ2VyLnNldHRpbmdzLFxuICAgICAgICB0eXBlOiBcImpzb25cIixcbiAgICAgICAgdGFyZ2V0OiBleHByZXNzaW9uTWFuYWdlclxuICAgICAgfSkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICBjb25zdCB0YXNrczIgPSBfTGl2ZTJERmFjdG9yeS5leHByZXNzaW9uVGFza3NNYXAuZ2V0KGV4cHJlc3Npb25NYW5hZ2VyKTtcbiAgICAgICAgaWYgKHRhc2tzMikge1xuICAgICAgICAgIGRlbGV0ZSB0YXNrczJbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBleHByZXNzaW9uTWFuYWdlci5jcmVhdGVFeHByZXNzaW9uKGRhdGEsIGRlZmluaXRpb24pO1xuICAgICAgICBleHByZXNzaW9uTWFuYWdlci5lbWl0KFwiZXhwcmVzc2lvbkxvYWRlZFwiLCBpbmRleCwgZXhwcmVzc2lvbik7XG4gICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgbG9nZ2VyLndhcm4oZXhwcmVzc2lvbk1hbmFnZXIudGFnLCBgRmFpbGVkIHRvIGxvYWQgZXhwcmVzc2lvbjogJHtwYXRofVxuYCwgZSk7XG4gICAgICAgIGhhbmRsZUVycm9yKGUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGFza3NbaW5kZXhdO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGxvZ2dlci53YXJuKGV4cHJlc3Npb25NYW5hZ2VyLnRhZywgYEZhaWxlZCB0byBsb2FkIGV4cHJlc3Npb24gYXQgWyR7aW5kZXh9XVxuYCwgZSk7XG4gICAgICBoYW5kbGVFcnJvcihlKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2b2lkIDApO1xuICB9XG4gIHN0YXRpYyByZWxlYXNlVGFza3MoKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBNb3Rpb25NYW5hZ2VyKSB7XG4gICAgICBfTGl2ZTJERmFjdG9yeS5tb3Rpb25UYXNrc01hcC5kZWxldGUodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9MaXZlMkRGYWN0b3J5LmV4cHJlc3Npb25UYXNrc01hcC5kZWxldGUodGhpcyk7XG4gICAgfVxuICB9XG59O1xubGV0IExpdmUyREZhY3RvcnkgPSBfTGl2ZTJERmFjdG9yeTtcbkxpdmUyREZhY3RvcnkucnVudGltZXMgPSBbXTtcbkxpdmUyREZhY3RvcnkudXJsVG9KU09OID0gdXJsVG9KU09OO1xuTGl2ZTJERmFjdG9yeS5qc29uVG9TZXR0aW5ncyA9IGpzb25Ub1NldHRpbmdzO1xuTGl2ZTJERmFjdG9yeS53YWl0VW50aWxSZWFkeSA9IHdhaXRVbnRpbFJlYWR5O1xuTGl2ZTJERmFjdG9yeS5zZXR1cE9wdGlvbmFscyA9IHNldHVwT3B0aW9uYWxzO1xuTGl2ZTJERmFjdG9yeS5zZXR1cEVzc2VudGlhbHMgPSBzZXR1cEVzc2VudGlhbHM7XG5MaXZlMkRGYWN0b3J5LmNyZWF0ZUludGVybmFsTW9kZWwgPSBjcmVhdGVJbnRlcm5hbE1vZGVsO1xuTGl2ZTJERmFjdG9yeS5saXZlMkRNb2RlbE1pZGRsZXdhcmVzID0gW1xuICB1cmxUb0pTT04sXG4gIGpzb25Ub1NldHRpbmdzLFxuICB3YWl0VW50aWxSZWFkeSxcbiAgc2V0dXBPcHRpb25hbHMsXG4gIHNldHVwRXNzZW50aWFscyxcbiAgY3JlYXRlSW50ZXJuYWxNb2RlbFxuXTtcbkxpdmUyREZhY3RvcnkubW90aW9uVGFza3NNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbkxpdmUyREZhY3RvcnkuZXhwcmVzc2lvblRhc2tzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5Nb3Rpb25NYW5hZ2VyLnByb3RvdHlwZVtcIl9sb2FkTW90aW9uXCJdID0gZnVuY3Rpb24oZ3JvdXAsIGluZGV4KSB7XG4gIHJldHVybiBMaXZlMkRGYWN0b3J5LmxvYWRNb3Rpb24odGhpcywgZ3JvdXAsIGluZGV4KTtcbn07XG5FeHByZXNzaW9uTWFuYWdlci5wcm90b3R5cGVbXCJfbG9hZEV4cHJlc3Npb25cIl0gPSBmdW5jdGlvbihpbmRleCkge1xuICByZXR1cm4gTGl2ZTJERmFjdG9yeS5sb2FkRXhwcmVzc2lvbih0aGlzLCBpbmRleCk7XG59O1xuY2xhc3MgSW50ZXJhY3Rpb25NaXhpbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2F1dG9JbnRlcmFjdCA9IGZhbHNlO1xuICB9XG4gIGdldCBhdXRvSW50ZXJhY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1dG9JbnRlcmFjdDtcbiAgfVxuICBzZXQgYXV0b0ludGVyYWN0KGF1dG9JbnRlcmFjdCkge1xuICAgIGlmIChhdXRvSW50ZXJhY3QgIT09IHRoaXMuX2F1dG9JbnRlcmFjdCkge1xuICAgICAgaWYgKGF1dG9JbnRlcmFjdCkge1xuICAgICAgICB0aGlzLm9uKFwicG9pbnRlcnRhcFwiLCBvblRhcCwgdGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9mZihcInBvaW50ZXJ0YXBcIiwgb25UYXAsIHRoaXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYXV0b0ludGVyYWN0ID0gYXV0b0ludGVyYWN0O1xuICAgIH1cbiAgfVxuICByZWdpc3RlckludGVyYWN0aW9uKG1hbmFnZXIpIHtcbiAgICBpZiAobWFuYWdlciAhPT0gdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIpIHtcbiAgICAgIHRoaXMudW5yZWdpc3RlckludGVyYWN0aW9uKCk7XG4gICAgICBpZiAodGhpcy5fYXV0b0ludGVyYWN0ICYmIG1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgICAgICBtYW5hZ2VyLm9uKFwicG9pbnRlcm1vdmVcIiwgb25Qb2ludGVyTW92ZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHVucmVnaXN0ZXJJbnRlcmFjdGlvbigpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyKSB7XG4gICAgICAoX2EgPSB0aGlzLmludGVyYWN0aW9uTWFuYWdlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm9mZihcInBvaW50ZXJtb3ZlXCIsIG9uUG9pbnRlck1vdmUsIHRoaXMpO1xuICAgICAgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIgPSB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBvblRhcChldmVudCkge1xuICB0aGlzLnRhcChldmVudC5kYXRhLmdsb2JhbC54LCBldmVudC5kYXRhLmdsb2JhbC55KTtcbn1cbmZ1bmN0aW9uIG9uUG9pbnRlck1vdmUoZXZlbnQpIHtcbiAgdGhpcy5mb2N1cyhldmVudC5kYXRhLmdsb2JhbC54LCBldmVudC5kYXRhLmdsb2JhbC55KTtcbn1cbmNsYXNzIExpdmUyRFRyYW5zZm9ybSBleHRlbmRzIFRyYW5zZm9ybSB7XG59XG5jb25zdCB0ZW1wUG9pbnQgPSBuZXcgUG9pbnQoKTtcbmNvbnN0IHRlbXBNYXRyaXgkMSA9IG5ldyBNYXRyaXgoKTtcbmxldCB0aWNrZXJSZWY7XG5jbGFzcyBMaXZlMkRNb2RlbCBleHRlbmRzIENvbnRhaW5lciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudGFnID0gXCJMaXZlMkRNb2RlbCh1bmluaXRpYWxpemVkKVwiO1xuICAgIHRoaXMudGV4dHVyZXMgPSBbXTtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IG5ldyBMaXZlMkRUcmFuc2Zvcm0oKTtcbiAgICB0aGlzLmFuY2hvciA9IG5ldyBPYnNlcnZhYmxlUG9pbnQodGhpcy5vbkFuY2hvckNoYW5nZSwgdGhpcywgMCwgMCk7XG4gICAgdGhpcy5nbENvbnRleHRJRCA9IC0xO1xuICAgIHRoaXMuZWxhcHNlZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB0aGlzLmRlbHRhVGltZSA9IDA7XG4gICAgdGhpcy5fYXV0b1VwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMub25jZShcIm1vZGVsTG9hZGVkXCIsICgpID0+IHRoaXMuaW5pdChvcHRpb25zKSk7XG4gIH1cbiAgc3RhdGljIGZyb20oc291cmNlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbW9kZWwgPSBuZXcgdGhpcyhvcHRpb25zKTtcbiAgICByZXR1cm4gTGl2ZTJERmFjdG9yeS5zZXR1cExpdmUyRE1vZGVsKG1vZGVsLCBzb3VyY2UsIG9wdGlvbnMpLnRoZW4oKCkgPT4gbW9kZWwpO1xuICB9XG4gIHN0YXRpYyBmcm9tU3luYyhzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBtb2RlbCA9IG5ldyB0aGlzKG9wdGlvbnMpO1xuICAgIExpdmUyREZhY3Rvcnkuc2V0dXBMaXZlMkRNb2RlbChtb2RlbCwgc291cmNlLCBvcHRpb25zKS50aGVuKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMub25Mb2FkKS5jYXRjaChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm9uRXJyb3IpO1xuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuICBzdGF0aWMgcmVnaXN0ZXJUaWNrZXIodGlja2VyQ2xhc3MpIHtcbiAgICB0aWNrZXJSZWYgPSB0aWNrZXJDbGFzcztcbiAgfVxuICBnZXQgYXV0b1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0b1VwZGF0ZTtcbiAgfVxuICBzZXQgYXV0b1VwZGF0ZShhdXRvVXBkYXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIHRpY2tlclJlZiB8fCAodGlja2VyUmVmID0gKF9hID0gd2luZG93LlBJWEkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5UaWNrZXIpO1xuICAgIGlmIChhdXRvVXBkYXRlKSB7XG4gICAgICBpZiAoIXRoaXMuX2Rlc3Ryb3llZCkge1xuICAgICAgICBpZiAodGlja2VyUmVmKSB7XG4gICAgICAgICAgdGlja2VyUmVmLnNoYXJlZC5hZGQodGhpcy5vblRpY2tlclVwZGF0ZSwgdGhpcyk7XG4gICAgICAgICAgdGhpcy5fYXV0b1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLndhcm4odGhpcy50YWcsIFwiTm8gVGlja2VyIHJlZ2lzdGVyZWQsIHBsZWFzZSBjYWxsIExpdmUyRE1vZGVsLnJlZ2lzdGVyVGlja2VyKFRpY2tlcikuXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpY2tlclJlZiA9PSBudWxsID8gdm9pZCAwIDogdGlja2VyUmVmLnNoYXJlZC5yZW1vdmUodGhpcy5vblRpY2tlclVwZGF0ZSwgdGhpcyk7XG4gICAgICB0aGlzLl9hdXRvVXBkYXRlID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGluaXQob3B0aW9ucykge1xuICAgIHRoaXMudGFnID0gYExpdmUyRE1vZGVsKCR7dGhpcy5pbnRlcm5hbE1vZGVsLnNldHRpbmdzLm5hbWV9KWA7XG4gICAgY29uc3QgX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGF1dG9VcGRhdGU6IHRydWUsXG4gICAgICBhdXRvSW50ZXJhY3Q6IHRydWVcbiAgICB9LCBvcHRpb25zKTtcbiAgICBpZiAoX29wdGlvbnMuYXV0b0ludGVyYWN0KSB7XG4gICAgICB0aGlzLmludGVyYWN0aXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5hdXRvSW50ZXJhY3QgPSBfb3B0aW9ucy5hdXRvSW50ZXJhY3Q7XG4gICAgdGhpcy5hdXRvVXBkYXRlID0gX29wdGlvbnMuYXV0b1VwZGF0ZTtcbiAgfVxuICBvbkFuY2hvckNoYW5nZSgpIHtcbiAgICB0aGlzLnBpdm90LnNldCh0aGlzLmFuY2hvci54ICogdGhpcy5pbnRlcm5hbE1vZGVsLndpZHRoLCB0aGlzLmFuY2hvci55ICogdGhpcy5pbnRlcm5hbE1vZGVsLmhlaWdodCk7XG4gIH1cbiAgbW90aW9uKGdyb3VwLCBpbmRleCwgcHJpb3JpdHkpIHtcbiAgICByZXR1cm4gaW5kZXggPT09IHZvaWQgMCA/IHRoaXMuaW50ZXJuYWxNb2RlbC5tb3Rpb25NYW5hZ2VyLnN0YXJ0UmFuZG9tTW90aW9uKGdyb3VwLCBwcmlvcml0eSkgOiB0aGlzLmludGVybmFsTW9kZWwubW90aW9uTWFuYWdlci5zdGFydE1vdGlvbihncm91cCwgaW5kZXgsIHByaW9yaXR5KTtcbiAgfVxuICBleHByZXNzaW9uKGlkKSB7XG4gICAgaWYgKHRoaXMuaW50ZXJuYWxNb2RlbC5tb3Rpb25NYW5hZ2VyLmV4cHJlc3Npb25NYW5hZ2VyKSB7XG4gICAgICByZXR1cm4gaWQgPT09IHZvaWQgMCA/IHRoaXMuaW50ZXJuYWxNb2RlbC5tb3Rpb25NYW5hZ2VyLmV4cHJlc3Npb25NYW5hZ2VyLnNldFJhbmRvbUV4cHJlc3Npb24oKSA6IHRoaXMuaW50ZXJuYWxNb2RlbC5tb3Rpb25NYW5hZ2VyLmV4cHJlc3Npb25NYW5hZ2VyLnNldEV4cHJlc3Npb24oaWQpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgfVxuICBmb2N1cyh4LCB5LCBpbnN0YW50ID0gZmFsc2UpIHtcbiAgICB0ZW1wUG9pbnQueCA9IHg7XG4gICAgdGVtcFBvaW50LnkgPSB5O1xuICAgIHRoaXMudG9Nb2RlbFBvc2l0aW9uKHRlbXBQb2ludCwgdGVtcFBvaW50LCB0cnVlKTtcbiAgICBsZXQgdHggPSB0ZW1wUG9pbnQueCAvIHRoaXMuaW50ZXJuYWxNb2RlbC5vcmlnaW5hbFdpZHRoICogMiAtIDE7XG4gICAgbGV0IHR5ID0gdGVtcFBvaW50LnkgLyB0aGlzLmludGVybmFsTW9kZWwub3JpZ2luYWxIZWlnaHQgKiAyIC0gMTtcbiAgICBsZXQgcmFkaWFuID0gTWF0aC5hdGFuMih0eSwgdHgpO1xuICAgIHRoaXMuaW50ZXJuYWxNb2RlbC5mb2N1c0NvbnRyb2xsZXIuZm9jdXMoTWF0aC5jb3MocmFkaWFuKSwgLU1hdGguc2luKHJhZGlhbiksIGluc3RhbnQpO1xuICB9XG4gIHRhcCh4LCB5KSB7XG4gICAgY29uc3QgaGl0QXJlYU5hbWVzID0gdGhpcy5oaXRUZXN0KHgsIHkpO1xuICAgIGlmIChoaXRBcmVhTmFtZXMubGVuZ3RoKSB7XG4gICAgICBsb2dnZXIubG9nKHRoaXMudGFnLCBgSGl0YCwgaGl0QXJlYU5hbWVzKTtcbiAgICAgIHRoaXMuZW1pdChcImhpdFwiLCBoaXRBcmVhTmFtZXMpO1xuICAgIH1cbiAgfVxuICBoaXRUZXN0KHgsIHkpIHtcbiAgICB0ZW1wUG9pbnQueCA9IHg7XG4gICAgdGVtcFBvaW50LnkgPSB5O1xuICAgIHRoaXMudG9Nb2RlbFBvc2l0aW9uKHRlbXBQb2ludCwgdGVtcFBvaW50KTtcbiAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vZGVsLmhpdFRlc3QodGVtcFBvaW50LngsIHRlbXBQb2ludC55KTtcbiAgfVxuICB0b01vZGVsUG9zaXRpb24ocG9zaXRpb24sIHJlc3VsdCA9IHBvc2l0aW9uLmNsb25lKCksIHNraXBVcGRhdGUpIHtcbiAgICBpZiAoIXNraXBVcGRhdGUpIHtcbiAgICAgIHRoaXMuX3JlY3Vyc2l2ZVBvc3RVcGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudDtcbiAgICAgICAgdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybS5hcHBseUludmVyc2UocG9zaXRpb24sIHJlc3VsdCk7XG4gICAgdGhpcy5pbnRlcm5hbE1vZGVsLmxvY2FsVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShyZXN1bHQsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBjb250YWluc1BvaW50KHBvaW50KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Qm91bmRzKHRydWUpLmNvbnRhaW5zKHBvaW50LngsIHBvaW50LnkpO1xuICB9XG4gIF9jYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgdGhpcy5fYm91bmRzLmFkZEZyYW1lKHRoaXMudHJhbnNmb3JtLCAwLCAwLCB0aGlzLmludGVybmFsTW9kZWwud2lkdGgsIHRoaXMuaW50ZXJuYWxNb2RlbC5oZWlnaHQpO1xuICB9XG4gIG9uVGlja2VyVXBkYXRlKCkge1xuICAgIHRoaXMudXBkYXRlKHRpY2tlclJlZi5zaGFyZWQuZGVsdGFNUyk7XG4gIH1cbiAgdXBkYXRlKGR0KSB7XG4gICAgdGhpcy5kZWx0YVRpbWUgKz0gZHQ7XG4gICAgdGhpcy5lbGFwc2VkVGltZSArPSBkdDtcbiAgfVxuICBfcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZWdpc3RlckludGVyYWN0aW9uKHJlbmRlcmVyLnBsdWdpbnMuaW50ZXJhY3Rpb24pO1xuICAgIHJlbmRlcmVyLmJhdGNoLnJlc2V0KCk7XG4gICAgcmVuZGVyZXIuZ2VvbWV0cnkucmVzZXQoKTtcbiAgICByZW5kZXJlci5zaGFkZXIucmVzZXQoKTtcbiAgICByZW5kZXJlci5zdGF0ZS5yZXNldCgpO1xuICAgIGxldCBzaG91bGRVcGRhdGVUZXh0dXJlID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuZ2xDb250ZXh0SUQgIT09IHJlbmRlcmVyLkNPTlRFWFRfVUlEKSB7XG4gICAgICB0aGlzLmdsQ29udGV4dElEID0gcmVuZGVyZXIuQ09OVEVYVF9VSUQ7XG4gICAgICB0aGlzLmludGVybmFsTW9kZWwudXBkYXRlV2ViR0xDb250ZXh0KHJlbmRlcmVyLmdsLCB0aGlzLmdsQ29udGV4dElEKTtcbiAgICAgIHNob3VsZFVwZGF0ZVRleHR1cmUgPSB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLnRleHR1cmVzW2ldO1xuICAgICAgaWYgKCF0ZXh0dXJlLnZhbGlkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFVwZGF0ZVRleHR1cmUgfHwgIXRleHR1cmUuYmFzZVRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5nbENvbnRleHRJRF0pIHtcbiAgICAgICAgcmVuZGVyZXIuZ2wucGl4ZWxTdG9yZWkoV2ViR0xSZW5kZXJpbmdDb250ZXh0LlVOUEFDS19GTElQX1lfV0VCR0wsIHRoaXMuaW50ZXJuYWxNb2RlbC50ZXh0dXJlRmxpcFkpO1xuICAgICAgICByZW5kZXJlci50ZXh0dXJlLmJpbmQodGV4dHVyZS5iYXNlVGV4dHVyZSwgMCk7XG4gICAgICB9XG4gICAgICB0aGlzLmludGVybmFsTW9kZWwuYmluZFRleHR1cmUoaSwgdGV4dHVyZS5iYXNlVGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLmdsQ29udGV4dElEXS50ZXh0dXJlKTtcbiAgICAgIHRleHR1cmUuYmFzZVRleHR1cmUudG91Y2hlZCA9IHJlbmRlcmVyLnRleHR1cmVHQy5jb3VudDtcbiAgICB9XG4gICAgY29uc3Qgdmlld3BvcnQgPSByZW5kZXJlci5mcmFtZWJ1ZmZlci52aWV3cG9ydDtcbiAgICB0aGlzLmludGVybmFsTW9kZWwudmlld3BvcnQgPSBbdmlld3BvcnQueCwgdmlld3BvcnQueSwgdmlld3BvcnQud2lkdGgsIHZpZXdwb3J0LmhlaWdodF07XG4gICAgaWYgKHRoaXMuZGVsdGFUaW1lKSB7XG4gICAgICB0aGlzLmludGVybmFsTW9kZWwudXBkYXRlKHRoaXMuZGVsdGFUaW1lLCB0aGlzLmVsYXBzZWRUaW1lKTtcbiAgICAgIHRoaXMuZGVsdGFUaW1lID0gMDtcbiAgICB9XG4gICAgY29uc3QgaW50ZXJuYWxUcmFuc2Zvcm0gPSB0ZW1wTWF0cml4JDEuY29weUZyb20ocmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXMudW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCkuYXBwZW5kKHRoaXMud29ybGRUcmFuc2Zvcm0pO1xuICAgIHRoaXMuaW50ZXJuYWxNb2RlbC51cGRhdGVUcmFuc2Zvcm0oaW50ZXJuYWxUcmFuc2Zvcm0pO1xuICAgIHRoaXMuaW50ZXJuYWxNb2RlbC5kcmF3KHJlbmRlcmVyLmdsKTtcbiAgICByZW5kZXJlci5zdGF0ZS5yZXNldCgpO1xuICAgIHJlbmRlcmVyLnRleHR1cmUucmVzZXQoKTtcbiAgfVxuICBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICB0aGlzLmVtaXQoXCJkZXN0cm95XCIpO1xuICAgIHRoaXMuYXV0b1VwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMudW5yZWdpc3RlckludGVyYWN0aW9uKCk7XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudGV4dHVyZSkge1xuICAgICAgdGhpcy50ZXh0dXJlcy5mb3JFYWNoKCh0ZXh0dXJlKSA9PiB0ZXh0dXJlLmRlc3Ryb3kob3B0aW9ucy5iYXNlVGV4dHVyZSkpO1xuICAgIH1cbiAgICB0aGlzLmludGVybmFsTW9kZWwuZGVzdHJveSgpO1xuICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyk7XG4gIH1cbn1cbmFwcGx5TWl4aW5zKExpdmUyRE1vZGVsLCBbSW50ZXJhY3Rpb25NaXhpbl0pO1xuY29uc3QgX0ZpbGVMb2FkZXIgPSBjbGFzcyB7XG4gIHN0YXRpYyByZXNvbHZlVVJMKHNldHRpbmdzVVJMLCBmaWxlUGF0aCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCByZXNvbHZlZCA9IChfYSA9IF9GaWxlTG9hZGVyLmZpbGVzTWFwW3NldHRpbmdzVVJMXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hW2ZpbGVQYXRoXTtcbiAgICBpZiAocmVzb2x2ZWQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgdGhpcyBmaWxlIGZyb20gdXBsb2FkZWQgZmlsZXM6IFwiICsgZmlsZVBhdGgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gIH1cbiAgc3RhdGljIHVwbG9hZChmaWxlcywgc2V0dGluZ3MpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgZmlsZU1hcCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBkZWZpbmVkRmlsZSBvZiBzZXR0aW5ncy5nZXREZWZpbmVkRmlsZXMoKSkge1xuICAgICAgICBjb25zdCBhY3R1YWxQYXRoID0gZGVjb2RlVVJJKHVybC5yZXNvbHZlKHNldHRpbmdzLnVybCwgZGVmaW5lZEZpbGUpKTtcbiAgICAgICAgY29uc3QgYWN0dWFsRmlsZSA9IGZpbGVzLmZpbmQoKGZpbGUpID0+IGZpbGUud2Via2l0UmVsYXRpdmVQYXRoID09PSBhY3R1YWxQYXRoKTtcbiAgICAgICAgaWYgKGFjdHVhbEZpbGUpIHtcbiAgICAgICAgICBmaWxlTWFwW2RlZmluZWRGaWxlXSA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYWN0dWFsRmlsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIF9GaWxlTG9hZGVyLmZpbGVzTWFwW3NldHRpbmdzLl9vYmplY3RVUkxdID0gZmlsZU1hcDtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlU2V0dGluZ3MoZmlsZXMpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3Qgc2V0dGluZ3NGaWxlID0gZmlsZXMuZmluZCgoZmlsZSkgPT4gZmlsZS5uYW1lLmVuZHNXaXRoKFwibW9kZWwuanNvblwiKSB8fCBmaWxlLm5hbWUuZW5kc1dpdGgoXCJtb2RlbDMuanNvblwiKSk7XG4gICAgICBpZiAoIXNldHRpbmdzRmlsZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU2V0dGluZ3MgZmlsZSBub3QgZm91bmRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBzZXR0aW5nc1RleHQgPSB5aWVsZCBfRmlsZUxvYWRlci5yZWFkVGV4dChzZXR0aW5nc0ZpbGUpO1xuICAgICAgY29uc3Qgc2V0dGluZ3NKU09OID0gSlNPTi5wYXJzZShzZXR0aW5nc1RleHQpO1xuICAgICAgc2V0dGluZ3NKU09OLnVybCA9IHNldHRpbmdzRmlsZS53ZWJraXRSZWxhdGl2ZVBhdGg7XG4gICAgICBjb25zdCBydW50aW1lID0gTGl2ZTJERmFjdG9yeS5maW5kUnVudGltZShzZXR0aW5nc0pTT04pO1xuICAgICAgaWYgKCFydW50aW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gc2V0dGluZ3MgSlNPTlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNldHRpbmdzID0gcnVudGltZS5jcmVhdGVNb2RlbFNldHRpbmdzKHNldHRpbmdzSlNPTik7XG4gICAgICBzZXR0aW5ncy5fb2JqZWN0VVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTChzZXR0aW5nc0ZpbGUpO1xuICAgICAgcmV0dXJuIHNldHRpbmdzO1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyByZWFkVGV4dChmaWxlKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgICByZWFkZXIub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSwgXCJ1dGY4XCIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn07XG5sZXQgRmlsZUxvYWRlciA9IF9GaWxlTG9hZGVyO1xuRmlsZUxvYWRlci5maWxlc01hcCA9IHt9O1xuRmlsZUxvYWRlci5mYWN0b3J5ID0gKGNvbnRleHQsIG5leHQpID0+IF9fYXN5bmModm9pZCAwLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShjb250ZXh0LnNvdXJjZSkgJiYgY29udGV4dC5zb3VyY2VbMF0gaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgY29uc3QgZmlsZXMgPSBjb250ZXh0LnNvdXJjZTtcbiAgICBsZXQgc2V0dGluZ3MgPSBmaWxlcy5zZXR0aW5ncztcbiAgICBpZiAoIXNldHRpbmdzKSB7XG4gICAgICBzZXR0aW5ncyA9IHlpZWxkIF9GaWxlTG9hZGVyLmNyZWF0ZVNldHRpbmdzKGZpbGVzKTtcbiAgICB9IGVsc2UgaWYgKCFzZXR0aW5ncy5fb2JqZWN0VVJMKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiX29iamVjdFVSTFwiIG11c3QgYmUgc3BlY2lmaWVkIGluIE1vZGVsU2V0dGluZ3MnKTtcbiAgICB9XG4gICAgc2V0dGluZ3MudmFsaWRhdGVGaWxlcyhmaWxlcy5tYXAoKGZpbGUpID0+IGVuY29kZVVSSShmaWxlLndlYmtpdFJlbGF0aXZlUGF0aCkpKTtcbiAgICB5aWVsZCBfRmlsZUxvYWRlci51cGxvYWQoZmlsZXMsIHNldHRpbmdzKTtcbiAgICBzZXR0aW5ncy5yZXNvbHZlVVJMID0gZnVuY3Rpb24odXJsMikge1xuICAgICAgcmV0dXJuIF9GaWxlTG9hZGVyLnJlc29sdmVVUkwodGhpcy5fb2JqZWN0VVJMLCB1cmwyKTtcbiAgICB9O1xuICAgIGNvbnRleHQuc291cmNlID0gc2V0dGluZ3M7XG4gICAgY29udGV4dC5saXZlMmRNb2RlbC5vbmNlKFwibW9kZWxMb2FkZWRcIiwgKGludGVybmFsTW9kZWwpID0+IHtcbiAgICAgIGludGVybmFsTW9kZWwub25jZShcImRlc3Ryb3lcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IG9iamVjdFVSTCA9IHRoaXMuc2V0dGluZ3MuX29iamVjdFVSTDtcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChvYmplY3RVUkwpO1xuICAgICAgICBpZiAoX0ZpbGVMb2FkZXIuZmlsZXNNYXBbb2JqZWN0VVJMXSkge1xuICAgICAgICAgIGZvciAoY29uc3QgcmVzb3VyY2VPYmplY3RVUkwgb2YgT2JqZWN0LnZhbHVlcyhfRmlsZUxvYWRlci5maWxlc01hcFtvYmplY3RVUkxdKSkge1xuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChyZXNvdXJjZU9iamVjdFVSTCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBfRmlsZUxvYWRlci5maWxlc01hcFtvYmplY3RVUkxdO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5leHQoKTtcbn0pO1xuTGl2ZTJERmFjdG9yeS5saXZlMkRNb2RlbE1pZGRsZXdhcmVzLnVuc2hpZnQoRmlsZUxvYWRlci5mYWN0b3J5KTtcbmNvbnN0IF9aaXBMb2FkZXIgPSBjbGFzcyB7XG4gIHN0YXRpYyB1bnppcChyZWFkZXIsIHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGZpbGVQYXRocyA9IHlpZWxkIF9aaXBMb2FkZXIuZ2V0RmlsZVBhdGhzKHJlYWRlcik7XG4gICAgICBjb25zdCByZXF1aXJlZEZpbGVQYXRocyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBkZWZpbmVkRmlsZSBvZiBzZXR0aW5ncy5nZXREZWZpbmVkRmlsZXMoKSkge1xuICAgICAgICBjb25zdCBhY3R1YWxQYXRoID0gZGVjb2RlVVJJKHVybC5yZXNvbHZlKHNldHRpbmdzLnVybCwgZGVmaW5lZEZpbGUpKTtcbiAgICAgICAgaWYgKGZpbGVQYXRocy5pbmNsdWRlcyhhY3R1YWxQYXRoKSkge1xuICAgICAgICAgIHJlcXVpcmVkRmlsZVBhdGhzLnB1c2goYWN0dWFsUGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpbGVzID0geWllbGQgX1ppcExvYWRlci5nZXRGaWxlcyhyZWFkZXIsIHJlcXVpcmVkRmlsZVBhdGhzKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IHJlcXVpcmVkRmlsZVBhdGhzW2ldO1xuICAgICAgICBjb25zdCBmaWxlID0gZmlsZXNbaV07XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmaWxlLCBcIndlYmtpdFJlbGF0aXZlUGF0aFwiLCB7XG4gICAgICAgICAgdmFsdWU6IHBhdGhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmlsZXM7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZVNldHRpbmdzKHJlYWRlcikge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBmaWxlUGF0aHMgPSB5aWVsZCBfWmlwTG9hZGVyLmdldEZpbGVQYXRocyhyZWFkZXIpO1xuICAgICAgY29uc3Qgc2V0dGluZ3NGaWxlUGF0aCA9IGZpbGVQYXRocy5maW5kKChwYXRoKSA9PiBwYXRoLmVuZHNXaXRoKFwibW9kZWwuanNvblwiKSB8fCBwYXRoLmVuZHNXaXRoKFwibW9kZWwzLmpzb25cIikpO1xuICAgICAgaWYgKCFzZXR0aW5nc0ZpbGVQYXRoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNldHRpbmdzIGZpbGUgbm90IGZvdW5kXCIpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2V0dGluZ3NUZXh0ID0geWllbGQgX1ppcExvYWRlci5yZWFkVGV4dChyZWFkZXIsIHNldHRpbmdzRmlsZVBhdGgpO1xuICAgICAgaWYgKCFzZXR0aW5nc1RleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW1wdHkgc2V0dGluZ3MgZmlsZTogXCIgKyBzZXR0aW5nc0ZpbGVQYXRoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNldHRpbmdzSlNPTiA9IEpTT04ucGFyc2Uoc2V0dGluZ3NUZXh0KTtcbiAgICAgIHNldHRpbmdzSlNPTi51cmwgPSBzZXR0aW5nc0ZpbGVQYXRoO1xuICAgICAgY29uc3QgcnVudGltZSA9IExpdmUyREZhY3RvcnkuZmluZFJ1bnRpbWUoc2V0dGluZ3NKU09OKTtcbiAgICAgIGlmICghcnVudGltZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHNldHRpbmdzIEpTT05cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcnVudGltZS5jcmVhdGVNb2RlbFNldHRpbmdzKHNldHRpbmdzSlNPTik7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIHppcFJlYWRlcihkYXRhLCB1cmwyKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0RmlsZVBhdGhzKHJlYWRlcikge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEZpbGVzKHJlYWRlciwgcGF0aHMpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyByZWFkVGV4dChyZWFkZXIsIHBhdGgpIHtcbiAgICByZXR1cm4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyByZWxlYXNlUmVhZGVyKHJlYWRlcikge1xuICB9XG59O1xubGV0IFppcExvYWRlciA9IF9aaXBMb2FkZXI7XG5aaXBMb2FkZXIuWklQX1BST1RPQ09MID0gXCJ6aXA6Ly9cIjtcblppcExvYWRlci51aWQgPSAwO1xuWmlwTG9hZGVyLmZhY3RvcnkgPSAoY29udGV4dCwgbmV4dCkgPT4gX19hc3luYyh2b2lkIDAsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gIGNvbnN0IHNvdXJjZSA9IGNvbnRleHQuc291cmNlO1xuICBsZXQgc291cmNlVVJMO1xuICBsZXQgemlwQmxvYjtcbiAgbGV0IHNldHRpbmdzO1xuICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gXCJzdHJpbmdcIiAmJiAoc291cmNlLmVuZHNXaXRoKFwiLnppcFwiKSB8fCBzb3VyY2Uuc3RhcnRzV2l0aChfWmlwTG9hZGVyLlpJUF9QUk9UT0NPTCkpKSB7XG4gICAgaWYgKHNvdXJjZS5zdGFydHNXaXRoKF9aaXBMb2FkZXIuWklQX1BST1RPQ09MKSkge1xuICAgICAgc291cmNlVVJMID0gc291cmNlLnNsaWNlKF9aaXBMb2FkZXIuWklQX1BST1RPQ09MLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvdXJjZVVSTCA9IHNvdXJjZTtcbiAgICB9XG4gICAgemlwQmxvYiA9IHlpZWxkIExpdmUyRExvYWRlci5sb2FkKHtcbiAgICAgIHVybDogc291cmNlVVJMLFxuICAgICAgdHlwZTogXCJibG9iXCIsXG4gICAgICB0YXJnZXQ6IGNvbnRleHQubGl2ZTJkTW9kZWxcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkgJiYgc291cmNlLmxlbmd0aCA9PT0gMSAmJiBzb3VyY2VbMF0gaW5zdGFuY2VvZiBGaWxlICYmIHNvdXJjZVswXS5uYW1lLmVuZHNXaXRoKFwiLnppcFwiKSkge1xuICAgIHppcEJsb2IgPSBzb3VyY2VbMF07XG4gICAgc291cmNlVVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTCh6aXBCbG9iKTtcbiAgICBzZXR0aW5ncyA9IHNvdXJjZS5zZXR0aW5ncztcbiAgfVxuICBpZiAoemlwQmxvYikge1xuICAgIGlmICghemlwQmxvYi5zaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbXB0eSB6aXAgZmlsZVwiKTtcbiAgICB9XG4gICAgY29uc3QgcmVhZGVyID0geWllbGQgX1ppcExvYWRlci56aXBSZWFkZXIoemlwQmxvYiwgc291cmNlVVJMKTtcbiAgICBpZiAoIXNldHRpbmdzKSB7XG4gICAgICBzZXR0aW5ncyA9IHlpZWxkIF9aaXBMb2FkZXIuY3JlYXRlU2V0dGluZ3MocmVhZGVyKTtcbiAgICB9XG4gICAgc2V0dGluZ3MuX29iamVjdFVSTCA9IF9aaXBMb2FkZXIuWklQX1BST1RPQ09MICsgX1ppcExvYWRlci51aWQgKyBcIi9cIiArIHNldHRpbmdzLnVybDtcbiAgICBjb25zdCBmaWxlcyA9IHlpZWxkIF9aaXBMb2FkZXIudW56aXAocmVhZGVyLCBzZXR0aW5ncyk7XG4gICAgZmlsZXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICBjb250ZXh0LnNvdXJjZSA9IGZpbGVzO1xuICAgIGlmIChzb3VyY2VVUkwuc3RhcnRzV2l0aChcImJsb2I6XCIpKSB7XG4gICAgICBjb250ZXh0LmxpdmUyZE1vZGVsLm9uY2UoXCJtb2RlbExvYWRlZFwiLCAoaW50ZXJuYWxNb2RlbCkgPT4ge1xuICAgICAgICBpbnRlcm5hbE1vZGVsLm9uY2UoXCJkZXN0cm95XCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoc291cmNlVVJMKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgX1ppcExvYWRlci5yZWxlYXNlUmVhZGVyKHJlYWRlcik7XG4gIH1cbiAgcmV0dXJuIG5leHQoKTtcbn0pO1xuTGl2ZTJERmFjdG9yeS5saXZlMkRNb2RlbE1pZGRsZXdhcmVzLnVuc2hpZnQoWmlwTG9hZGVyLmZhY3RvcnkpO1xuaWYgKCF3aW5kb3cuTGl2ZTJEQ3ViaXNtQ29yZSkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBDdWJpc20gNCBydW50aW1lLiBUaGlzIHBsdWdpbiByZXF1aXJlcyBsaXZlMmRjdWJpc21jb3JlLmpzIHRvIGJlIGxvYWRlZC5cIik7XG59XG5jbGFzcyBDdWJpc200RXhwcmVzc2lvbk1hbmFnZXIgZXh0ZW5kcyBFeHByZXNzaW9uTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIHN1cGVyKHNldHRpbmdzLCBvcHRpb25zKTtcbiAgICB0aGlzLnF1ZXVlTWFuYWdlciA9IG5ldyBDdWJpc21Nb3Rpb25RdWV1ZU1hbmFnZXIoKTtcbiAgICB0aGlzLmRlZmluaXRpb25zID0gKF9hID0gc2V0dGluZ3MuZXhwcmVzc2lvbnMpICE9IG51bGwgPyBfYSA6IFtdO1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG4gIGlzRmluaXNoZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucXVldWVNYW5hZ2VyLmlzRmluaXNoZWQoKTtcbiAgfVxuICBnZXRFeHByZXNzaW9uSW5kZXgobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmRlZmluaXRpb25zLmZpbmRJbmRleCgoZGVmKSA9PiBkZWYuTmFtZSA9PT0gbmFtZSk7XG4gIH1cbiAgZ2V0RXhwcmVzc2lvbkZpbGUoZGVmaW5pdGlvbikge1xuICAgIHJldHVybiBkZWZpbml0aW9uLkZpbGU7XG4gIH1cbiAgY3JlYXRlRXhwcmVzc2lvbihkYXRhLCBkZWZpbml0aW9uKSB7XG4gICAgcmV0dXJuIEN1YmlzbUV4cHJlc3Npb25Nb3Rpb24uY3JlYXRlKGRhdGEpO1xuICB9XG4gIF9zZXRFeHByZXNzaW9uKG1vdGlvbikge1xuICAgIHJldHVybiB0aGlzLnF1ZXVlTWFuYWdlci5zdGFydE1vdGlvbihtb3Rpb24sIGZhbHNlLCBwZXJmb3JtYW5jZS5ub3coKSk7XG4gIH1cbiAgc3RvcEFsbEV4cHJlc3Npb25zKCkge1xuICAgIHRoaXMucXVldWVNYW5hZ2VyLnN0b3BBbGxNb3Rpb25zKCk7XG4gIH1cbiAgdXBkYXRlUGFyYW1ldGVycyhtb2RlbCwgbm93KSB7XG4gICAgcmV0dXJuIHRoaXMucXVldWVNYW5hZ2VyLmRvVXBkYXRlTW90aW9uKG1vZGVsLCBub3cpO1xuICB9XG59XG5jbGFzcyBDdWJpc200TW9kZWxTZXR0aW5ncyBleHRlbmRzIE1vZGVsU2V0dGluZ3Mge1xuICBjb25zdHJ1Y3Rvcihqc29uKSB7XG4gICAgc3VwZXIoanNvbik7XG4gICAgaWYgKCFDdWJpc200TW9kZWxTZXR0aW5ncy5pc1ZhbGlkSlNPTihqc29uKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgSlNPTi5cIik7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24odGhpcywgbmV3IEN1YmlzbU1vZGVsU2V0dGluZ3NKc29uKGpzb24pKTtcbiAgfVxuICBzdGF0aWMgaXNWYWxpZEpTT04oanNvbikge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gISEoanNvbiA9PSBudWxsID8gdm9pZCAwIDoganNvbi5GaWxlUmVmZXJlbmNlcykgJiYgdHlwZW9mIGpzb24uRmlsZVJlZmVyZW5jZXMuTW9jID09PSBcInN0cmluZ1wiICYmICgoX2EgPSBqc29uLkZpbGVSZWZlcmVuY2VzLlRleHR1cmVzKSA9PSBudWxsID8gdm9pZCAwIDogX2EubGVuZ3RoKSA+IDAgJiYganNvbi5GaWxlUmVmZXJlbmNlcy5UZXh0dXJlcy5ldmVyeSgoaXRlbSkgPT4gdHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpO1xuICB9XG4gIHJlcGxhY2VGaWxlcyhyZXBsYWNlKSB7XG4gICAgc3VwZXIucmVwbGFjZUZpbGVzKHJlcGxhY2UpO1xuICAgIGlmICh0aGlzLm1vdGlvbnMpIHtcbiAgICAgIGZvciAoY29uc3QgW2dyb3VwLCBtb3Rpb25zXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLm1vdGlvbnMpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW90aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG1vdGlvbnNbaV0uRmlsZSA9IHJlcGxhY2UobW90aW9uc1tpXS5GaWxlLCBgbW90aW9ucy4ke2dyb3VwfVske2l9XS5GaWxlYCk7XG4gICAgICAgICAgaWYgKG1vdGlvbnNbaV0uU291bmQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgbW90aW9uc1tpXS5Tb3VuZCA9IHJlcGxhY2UobW90aW9uc1tpXS5Tb3VuZCwgYG1vdGlvbnMuJHtncm91cH1bJHtpfV0uU291bmRgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuZXhwcmVzc2lvbnMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5leHByZXNzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zW2ldLkZpbGUgPSByZXBsYWNlKHRoaXMuZXhwcmVzc2lvbnNbaV0uRmlsZSwgYGV4cHJlc3Npb25zWyR7aX1dLkZpbGVgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmFwcGx5TWl4aW5zKEN1YmlzbTRNb2RlbFNldHRpbmdzLCBbQ3ViaXNtTW9kZWxTZXR0aW5nc0pzb25dKTtcbmNsYXNzIEN1YmlzbTRNb3Rpb25NYW5hZ2VyIGV4dGVuZHMgTW90aW9uTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKHNldHRpbmdzLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIHN1cGVyKHNldHRpbmdzLCBvcHRpb25zKTtcbiAgICB0aGlzLmdyb3VwcyA9IHsgaWRsZTogXCJJZGxlXCIgfTtcbiAgICB0aGlzLm1vdGlvbkRhdGFUeXBlID0gXCJqc29uXCI7XG4gICAgdGhpcy5xdWV1ZU1hbmFnZXIgPSBuZXcgQ3ViaXNtTW90aW9uUXVldWVNYW5hZ2VyKCk7XG4gICAgdGhpcy5kZWZpbml0aW9ucyA9IChfYSA9IHNldHRpbmdzLm1vdGlvbnMpICE9IG51bGwgPyBfYSA6IHt9O1xuICAgIHRoaXMuZXllQmxpbmtJZHMgPSBzZXR0aW5ncy5nZXRFeWVCbGlua1BhcmFtZXRlcnMoKSB8fCBbXTtcbiAgICB0aGlzLmxpcFN5bmNJZHMgPSBzZXR0aW5ncy5nZXRMaXBTeW5jUGFyYW1ldGVycygpIHx8IFtdO1xuICAgIHRoaXMuaW5pdChvcHRpb25zKTtcbiAgfVxuICBpbml0KG9wdGlvbnMpIHtcbiAgICBzdXBlci5pbml0KG9wdGlvbnMpO1xuICAgIGlmICh0aGlzLnNldHRpbmdzLmV4cHJlc3Npb25zKSB7XG4gICAgICB0aGlzLmV4cHJlc3Npb25NYW5hZ2VyID0gbmV3IEN1YmlzbTRFeHByZXNzaW9uTWFuYWdlcih0aGlzLnNldHRpbmdzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgdGhpcy5xdWV1ZU1hbmFnZXIuc2V0RXZlbnRDYWxsYmFjaygoY2FsbGVyLCBldmVudFZhbHVlLCBjdXN0b21EYXRhKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoXCJtb3Rpb246XCIgKyBldmVudFZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICBpc0ZpbmlzaGVkKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXVlTWFuYWdlci5pc0ZpbmlzaGVkKCk7XG4gIH1cbiAgX3N0YXJ0TW90aW9uKG1vdGlvbiwgb25GaW5pc2gpIHtcbiAgICBtb3Rpb24uc2V0RmluaXNoZWRNb3Rpb25IYW5kbGVyKG9uRmluaXNoKTtcbiAgICB0aGlzLnF1ZXVlTWFuYWdlci5zdG9wQWxsTW90aW9ucygpO1xuICAgIHJldHVybiB0aGlzLnF1ZXVlTWFuYWdlci5zdGFydE1vdGlvbihtb3Rpb24sIGZhbHNlLCBwZXJmb3JtYW5jZS5ub3coKSk7XG4gIH1cbiAgX3N0b3BBbGxNb3Rpb25zKCkge1xuICAgIHRoaXMucXVldWVNYW5hZ2VyLnN0b3BBbGxNb3Rpb25zKCk7XG4gIH1cbiAgY3JlYXRlTW90aW9uKGRhdGEsIGdyb3VwLCBkZWZpbml0aW9uKSB7XG4gICAgY29uc3QgbW90aW9uID0gQ3ViaXNtTW90aW9uLmNyZWF0ZShkYXRhKTtcbiAgICBjb25zdCBqc29uID0gbmV3IEN1YmlzbU1vdGlvbkpzb24oZGF0YSk7XG4gICAgY29uc3QgZGVmYXVsdEZhZGluZ0R1cmF0aW9uID0gKGdyb3VwID09PSB0aGlzLmdyb3Vwcy5pZGxlID8gY29uZmlnLmlkbGVNb3Rpb25GYWRpbmdEdXJhdGlvbiA6IGNvbmZpZy5tb3Rpb25GYWRpbmdEdXJhdGlvbikgLyAxZTM7XG4gICAgaWYgKGpzb24uZ2V0TW90aW9uRmFkZUluVGltZSgpID09PSB2b2lkIDApIHtcbiAgICAgIG1vdGlvbi5zZXRGYWRlSW5UaW1lKGRlZmluaXRpb24uRmFkZUluVGltZSA+IDAgPyBkZWZpbml0aW9uLkZhZGVJblRpbWUgOiBkZWZhdWx0RmFkaW5nRHVyYXRpb24pO1xuICAgIH1cbiAgICBpZiAoanNvbi5nZXRNb3Rpb25GYWRlT3V0VGltZSgpID09PSB2b2lkIDApIHtcbiAgICAgIG1vdGlvbi5zZXRGYWRlT3V0VGltZShkZWZpbml0aW9uLkZhZGVPdXRUaW1lID4gMCA/IGRlZmluaXRpb24uRmFkZU91dFRpbWUgOiBkZWZhdWx0RmFkaW5nRHVyYXRpb24pO1xuICAgIH1cbiAgICBtb3Rpb24uc2V0RWZmZWN0SWRzKHRoaXMuZXllQmxpbmtJZHMsIHRoaXMubGlwU3luY0lkcyk7XG4gICAgcmV0dXJuIG1vdGlvbjtcbiAgfVxuICBnZXRNb3Rpb25GaWxlKGRlZmluaXRpb24pIHtcbiAgICByZXR1cm4gZGVmaW5pdGlvbi5GaWxlO1xuICB9XG4gIGdldE1vdGlvbk5hbWUoZGVmaW5pdGlvbikge1xuICAgIHJldHVybiBkZWZpbml0aW9uLkZpbGU7XG4gIH1cbiAgZ2V0U291bmRGaWxlKGRlZmluaXRpb24pIHtcbiAgICByZXR1cm4gZGVmaW5pdGlvbi5Tb3VuZDtcbiAgfVxuICB1cGRhdGVQYXJhbWV0ZXJzKG1vZGVsLCBub3cpIHtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZU1hbmFnZXIuZG9VcGRhdGVNb3Rpb24obW9kZWwsIG5vdyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgdGhpcy5xdWV1ZU1hbmFnZXIucmVsZWFzZSgpO1xuICAgIHRoaXMucXVldWVNYW5hZ2VyID0gdm9pZCAwO1xuICB9XG59XG5jb25zdCB0ZW1wTWF0cml4ID0gbmV3IEN1YmlzbU1hdHJpeDQ0KCk7XG5jbGFzcyBDdWJpc200SW50ZXJuYWxNb2RlbCBleHRlbmRzIEludGVybmFsTW9kZWwge1xuICBjb25zdHJ1Y3Rvcihjb3JlTW9kZWwsIHNldHRpbmdzLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmxpcFN5bmMgPSB0cnVlO1xuICAgIHRoaXMuYnJlYXRoID0gQ3ViaXNtQnJlYXRoLmNyZWF0ZSgpO1xuICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgQ3ViaXNtUmVuZGVyZXJfV2ViR0woKTtcbiAgICB0aGlzLmlkUGFyYW1BbmdsZVggPSBQYXJhbUFuZ2xlWDtcbiAgICB0aGlzLmlkUGFyYW1BbmdsZVkgPSBQYXJhbUFuZ2xlWTtcbiAgICB0aGlzLmlkUGFyYW1BbmdsZVogPSBQYXJhbUFuZ2xlWjtcbiAgICB0aGlzLmlkUGFyYW1FeWVCYWxsWCA9IFBhcmFtRXllQmFsbFg7XG4gICAgdGhpcy5pZFBhcmFtRXllQmFsbFkgPSBQYXJhbUV5ZUJhbGxZO1xuICAgIHRoaXMuaWRQYXJhbUJvZHlBbmdsZVggPSBQYXJhbUJvZHlBbmdsZVg7XG4gICAgdGhpcy5pZFBhcmFtQnJlYXRoID0gUGFyYW1CcmVhdGg7XG4gICAgdGhpcy5waXhlbHNQZXJVbml0ID0gMTtcbiAgICB0aGlzLmNlbnRlcmluZ1RyYW5zZm9ybSA9IG5ldyBNYXRyaXgoKTtcbiAgICB0aGlzLmNvcmVNb2RlbCA9IGNvcmVNb2RlbDtcbiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgdGhpcy5tb3Rpb25NYW5hZ2VyID0gbmV3IEN1YmlzbTRNb3Rpb25NYW5hZ2VyKHNldHRpbmdzLCBvcHRpb25zKTtcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuICBpbml0KCkge1xuICAgIHZhciBfYTtcbiAgICBzdXBlci5pbml0KCk7XG4gICAgaWYgKCgoX2EgPSB0aGlzLnNldHRpbmdzLmdldEV5ZUJsaW5rUGFyYW1ldGVycygpKSA9PSBudWxsID8gdm9pZCAwIDogX2EubGVuZ3RoKSA+IDApIHtcbiAgICAgIHRoaXMuZXllQmxpbmsgPSBDdWJpc21FeWVCbGluay5jcmVhdGUodGhpcy5zZXR0aW5ncyk7XG4gICAgfVxuICAgIHRoaXMuYnJlYXRoLnNldFBhcmFtZXRlcnMoW1xuICAgICAgbmV3IEJyZWF0aFBhcmFtZXRlckRhdGEodGhpcy5pZFBhcmFtQW5nbGVYLCAwLCAxNSwgNi41MzQ1LCAwLjUpLFxuICAgICAgbmV3IEJyZWF0aFBhcmFtZXRlckRhdGEodGhpcy5pZFBhcmFtQW5nbGVZLCAwLCA4LCAzLjUzNDUsIDAuNSksXG4gICAgICBuZXcgQnJlYXRoUGFyYW1ldGVyRGF0YSh0aGlzLmlkUGFyYW1BbmdsZVosIDAsIDEwLCA1LjUzNDUsIDAuNSksXG4gICAgICBuZXcgQnJlYXRoUGFyYW1ldGVyRGF0YSh0aGlzLmlkUGFyYW1Cb2R5QW5nbGVYLCAwLCA0LCAxNS41MzQ1LCAwLjUpLFxuICAgICAgbmV3IEJyZWF0aFBhcmFtZXRlckRhdGEodGhpcy5pZFBhcmFtQnJlYXRoLCAwLCAwLjUsIDMuMjM0NSwgMC41KVxuICAgIF0pO1xuICAgIHRoaXMucmVuZGVyZXIuaW5pdGlhbGl6ZSh0aGlzLmNvcmVNb2RlbCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRJc1ByZW11bHRpcGxpZWRBbHBoYSh0cnVlKTtcbiAgfVxuICBnZXRTaXplKCkge1xuICAgIHJldHVybiBbdGhpcy5jb3JlTW9kZWwuZ2V0TW9kZWwoKS5jYW52YXNpbmZvLkNhbnZhc1dpZHRoLCB0aGlzLmNvcmVNb2RlbC5nZXRNb2RlbCgpLmNhbnZhc2luZm8uQ2FudmFzSGVpZ2h0XTtcbiAgfVxuICBnZXRMYXlvdXQoKSB7XG4gICAgY29uc3QgbGF5b3V0ID0ge307XG4gICAgaWYgKHRoaXMuc2V0dGluZ3MubGF5b3V0KSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLnNldHRpbmdzLmxheW91dCkpIHtcbiAgICAgICAgY29uc3QgY29tbW9uS2V5ID0ga2V5LmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDEpO1xuICAgICAgICBsYXlvdXRbY29tbW9uS2V5XSA9IHRoaXMuc2V0dGluZ3MubGF5b3V0W2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsYXlvdXQ7XG4gIH1cbiAgc2V0dXBMYXlvdXQoKSB7XG4gICAgc3VwZXIuc2V0dXBMYXlvdXQoKTtcbiAgICB0aGlzLnBpeGVsc1BlclVuaXQgPSB0aGlzLmNvcmVNb2RlbC5nZXRNb2RlbCgpLmNhbnZhc2luZm8uUGl4ZWxzUGVyVW5pdDtcbiAgICB0aGlzLmNlbnRlcmluZ1RyYW5zZm9ybS5zY2FsZSh0aGlzLnBpeGVsc1BlclVuaXQsIHRoaXMucGl4ZWxzUGVyVW5pdCkudHJhbnNsYXRlKHRoaXMub3JpZ2luYWxXaWR0aCAvIDIsIHRoaXMub3JpZ2luYWxIZWlnaHQgLyAyKTtcbiAgfVxuICB1cGRhdGVXZWJHTENvbnRleHQoZ2wsIGdsQ29udGV4dElEKSB7XG4gICAgdGhpcy5yZW5kZXJlci5maXJzdERyYXcgPSB0cnVlO1xuICAgIHRoaXMucmVuZGVyZXIuX2J1ZmZlckRhdGEgPSB7XG4gICAgICB2ZXJ0ZXg6IG51bGwsXG4gICAgICB1djogbnVsbCxcbiAgICAgIGluZGV4OiBudWxsXG4gICAgfTtcbiAgICB0aGlzLnJlbmRlcmVyLnN0YXJ0VXAoZ2wpO1xuICAgIHRoaXMucmVuZGVyZXIuX2NsaXBwaW5nTWFuYWdlci5fY3VycmVudEZyYW1lTm8gPSBnbENvbnRleHRJRDtcbiAgICB0aGlzLnJlbmRlcmVyLl9jbGlwcGluZ01hbmFnZXIuX21hc2tUZXh0dXJlID0gdm9pZCAwO1xuICAgIEN1YmlzbVNoYWRlcl9XZWJHTC5nZXRJbnN0YW5jZSgpLl9zaGFkZXJTZXRzID0gW107XG4gIH1cbiAgYmluZFRleHR1cmUoaW5kZXgsIHRleHR1cmUpIHtcbiAgICB0aGlzLnJlbmRlcmVyLmJpbmRUZXh0dXJlKGluZGV4LCB0ZXh0dXJlKTtcbiAgfVxuICBnZXRIaXRBcmVhRGVmcygpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLnNldHRpbmdzLmhpdEFyZWFzKSA9PSBudWxsID8gdm9pZCAwIDogX2EubWFwKChoaXRBcmVhKSA9PiAoe1xuICAgICAgaWQ6IGhpdEFyZWEuSWQsXG4gICAgICBuYW1lOiBoaXRBcmVhLk5hbWUsXG4gICAgICBpbmRleDogdGhpcy5jb3JlTW9kZWwuZ2V0RHJhd2FibGVJbmRleChoaXRBcmVhLklkKVxuICAgIH0pKSkgIT0gbnVsbCA/IF9iIDogW107XG4gIH1cbiAgZ2V0RHJhd2FibGVJRHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29yZU1vZGVsLmdldERyYXdhYmxlSWRzKCk7XG4gIH1cbiAgZ2V0RHJhd2FibGVJbmRleChpZCkge1xuICAgIHJldHVybiB0aGlzLmNvcmVNb2RlbC5nZXREcmF3YWJsZUluZGV4KGlkKTtcbiAgfVxuICBnZXREcmF3YWJsZVZlcnRpY2VzKGRyYXdJbmRleCkge1xuICAgIGlmICh0eXBlb2YgZHJhd0luZGV4ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBkcmF3SW5kZXggPSB0aGlzLmNvcmVNb2RlbC5nZXREcmF3YWJsZUluZGV4KGRyYXdJbmRleCk7XG4gICAgICBpZiAoZHJhd0luZGV4ID09PSAtMSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuYWJsZSB0byBmaW5kIGRyYXdhYmxlIElEOiBcIiArIGRyYXdJbmRleCk7XG4gICAgfVxuICAgIGNvbnN0IGFyciA9IHRoaXMuY29yZU1vZGVsLmdldERyYXdhYmxlVmVydGljZXMoZHJhd0luZGV4KS5zbGljZSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBhcnJbaV0gPSBhcnJbaV0gKiB0aGlzLnBpeGVsc1BlclVuaXQgKyB0aGlzLm9yaWdpbmFsV2lkdGggLyAyO1xuICAgICAgYXJyW2kgKyAxXSA9IC1hcnJbaSArIDFdICogdGhpcy5waXhlbHNQZXJVbml0ICsgdGhpcy5vcmlnaW5hbEhlaWdodCAvIDI7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG4gIH1cbiAgdXBkYXRlVHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICAgIHRoaXMuZHJhd2luZ01hdHJpeC5jb3B5RnJvbSh0aGlzLmNlbnRlcmluZ1RyYW5zZm9ybSkucHJlcGVuZCh0aGlzLmxvY2FsVHJhbnNmb3JtKS5wcmVwZW5kKHRyYW5zZm9ybSk7XG4gIH1cbiAgdXBkYXRlKGR0LCBub3cpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgc3VwZXIudXBkYXRlKGR0LCBub3cpO1xuICAgIGR0IC89IDFlMztcbiAgICBub3cgLz0gMWUzO1xuICAgIGNvbnN0IG1vZGVsID0gdGhpcy5jb3JlTW9kZWw7XG4gICAgdGhpcy5lbWl0KFwiYmVmb3JlTW90aW9uVXBkYXRlXCIpO1xuICAgIGNvbnN0IG1vdGlvblVwZGF0ZWQgPSB0aGlzLm1vdGlvbk1hbmFnZXIudXBkYXRlKHRoaXMuY29yZU1vZGVsLCBub3cpO1xuICAgIHRoaXMuZW1pdChcImFmdGVyTW90aW9uVXBkYXRlXCIpO1xuICAgIG1vZGVsLnNhdmVQYXJhbWV0ZXJzKCk7XG4gICAgKF9hID0gdGhpcy5tb3Rpb25NYW5hZ2VyLmV4cHJlc3Npb25NYW5hZ2VyKSA9PSBudWxsID8gdm9pZCAwIDogX2EudXBkYXRlKG1vZGVsLCBub3cpO1xuICAgIGlmICghbW90aW9uVXBkYXRlZCkge1xuICAgICAgKF9iID0gdGhpcy5leWVCbGluaykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnVwZGF0ZVBhcmFtZXRlcnMobW9kZWwsIGR0KTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVGb2N1cygpO1xuICAgIHRoaXMudXBkYXRlTmF0dXJhbE1vdmVtZW50cyhkdCAqIDFlMywgbm93ICogMWUzKTtcbiAgICAoX2MgPSB0aGlzLnBoeXNpY3MpID09IG51bGwgPyB2b2lkIDAgOiBfYy5ldmFsdWF0ZShtb2RlbCwgZHQpO1xuICAgIChfZCA9IHRoaXMucG9zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLnVwZGF0ZVBhcmFtZXRlcnMobW9kZWwsIGR0KTtcbiAgICB0aGlzLmVtaXQoXCJiZWZvcmVNb2RlbFVwZGF0ZVwiKTtcbiAgICBtb2RlbC51cGRhdGUoKTtcbiAgICBtb2RlbC5sb2FkUGFyYW1ldGVycygpO1xuICB9XG4gIHVwZGF0ZUZvY3VzKCkge1xuICAgIHRoaXMuY29yZU1vZGVsLmFkZFBhcmFtZXRlclZhbHVlQnlJZCh0aGlzLmlkUGFyYW1FeWVCYWxsWCwgdGhpcy5mb2N1c0NvbnRyb2xsZXIueCk7XG4gICAgdGhpcy5jb3JlTW9kZWwuYWRkUGFyYW1ldGVyVmFsdWVCeUlkKHRoaXMuaWRQYXJhbUV5ZUJhbGxZLCB0aGlzLmZvY3VzQ29udHJvbGxlci55KTtcbiAgICB0aGlzLmNvcmVNb2RlbC5hZGRQYXJhbWV0ZXJWYWx1ZUJ5SWQodGhpcy5pZFBhcmFtQW5nbGVYLCB0aGlzLmZvY3VzQ29udHJvbGxlci54ICogMzApO1xuICAgIHRoaXMuY29yZU1vZGVsLmFkZFBhcmFtZXRlclZhbHVlQnlJZCh0aGlzLmlkUGFyYW1BbmdsZVksIHRoaXMuZm9jdXNDb250cm9sbGVyLnkgKiAzMCk7XG4gICAgdGhpcy5jb3JlTW9kZWwuYWRkUGFyYW1ldGVyVmFsdWVCeUlkKHRoaXMuaWRQYXJhbUFuZ2xlWiwgdGhpcy5mb2N1c0NvbnRyb2xsZXIueCAqIHRoaXMuZm9jdXNDb250cm9sbGVyLnkgKiAtMzApO1xuICAgIHRoaXMuY29yZU1vZGVsLmFkZFBhcmFtZXRlclZhbHVlQnlJZCh0aGlzLmlkUGFyYW1Cb2R5QW5nbGVYLCB0aGlzLmZvY3VzQ29udHJvbGxlci54ICogMTApO1xuICB9XG4gIHVwZGF0ZU5hdHVyYWxNb3ZlbWVudHMoZHQsIG5vdykge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSB0aGlzLmJyZWF0aCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnVwZGF0ZVBhcmFtZXRlcnModGhpcy5jb3JlTW9kZWwsIGR0IC8gMWUzKTtcbiAgfVxuICBkcmF3KGdsKSB7XG4gICAgY29uc3QgbWF0cml4ID0gdGhpcy5kcmF3aW5nTWF0cml4O1xuICAgIGNvbnN0IGFycmF5ID0gdGVtcE1hdHJpeC5nZXRBcnJheSgpO1xuICAgIGFycmF5WzBdID0gbWF0cml4LmE7XG4gICAgYXJyYXlbMV0gPSBtYXRyaXguYjtcbiAgICBhcnJheVs0XSA9IC1tYXRyaXguYztcbiAgICBhcnJheVs1XSA9IC1tYXRyaXguZDtcbiAgICBhcnJheVsxMl0gPSBtYXRyaXgudHg7XG4gICAgYXJyYXlbMTNdID0gbWF0cml4LnR5O1xuICAgIHRoaXMucmVuZGVyZXIuc2V0TXZwTWF0cml4KHRlbXBNYXRyaXgpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0UmVuZGVyU3RhdGUoZ2wuZ2V0UGFyYW1ldGVyKGdsLkZSQU1FQlVGRkVSX0JJTkRJTkcpLCB0aGlzLnZpZXdwb3J0KTtcbiAgICB0aGlzLnJlbmRlcmVyLmRyYXdNb2RlbCgpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIHRoaXMucmVuZGVyZXIucmVsZWFzZSgpO1xuICAgIHRoaXMuY29yZU1vZGVsLnJlbGVhc2UoKTtcbiAgICB0aGlzLnJlbmRlcmVyID0gdm9pZCAwO1xuICAgIHRoaXMuY29yZU1vZGVsID0gdm9pZCAwO1xuICB9XG59XG5sZXQgc3RhcnR1cFByb21pc2U7XG5sZXQgc3RhcnR1cFJldHJpZXMgPSAyMDtcbmZ1bmN0aW9uIGN1YmlzbTRSZWFkeSgpIHtcbiAgaWYgKEN1YmlzbUZyYW1ld29yay5pc1N0YXJ0ZWQoKSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuICBzdGFydHVwUHJvbWlzZSAhPSBudWxsID8gc3RhcnR1cFByb21pc2UgOiBzdGFydHVwUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmdW5jdGlvbiBzdGFydFVwV2l0aFJldHJ5KCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RhcnRVcEN1YmlzbTQoKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzdGFydHVwUmV0cmllcy0tO1xuICAgICAgICBpZiAoc3RhcnR1cFJldHJpZXMgPCAwKSB7XG4gICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFwiRmFpbGVkIHRvIHN0YXJ0IHVwIEN1YmlzbSA0IGZyYW1ld29yay5cIik7XG4gICAgICAgICAgZXJyLmNhdXNlID0gZTtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmxvZyhcIkN1YmlzbTRcIiwgXCJTdGFydHVwIGZhaWxlZCwgcmV0cnlpbmcgMTBtcyBsYXRlci4uLlwiKTtcbiAgICAgICAgc2V0VGltZW91dChzdGFydFVwV2l0aFJldHJ5LCAxMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXJ0VXBXaXRoUmV0cnkoKTtcbiAgfSk7XG4gIHJldHVybiBzdGFydHVwUHJvbWlzZTtcbn1cbmZ1bmN0aW9uIHN0YXJ0VXBDdWJpc200KG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIGxvZ0Z1bmN0aW9uOiBjb25zb2xlLmxvZyxcbiAgICBsb2dnaW5nTGV2ZWw6IExvZ0xldmVsLkxvZ0xldmVsX1ZlcmJvc2VcbiAgfSwgb3B0aW9ucyk7XG4gIEN1YmlzbUZyYW1ld29yay5zdGFydFVwKG9wdGlvbnMpO1xuICBDdWJpc21GcmFtZXdvcmsuaW5pdGlhbGl6ZSgpO1xufVxuTGl2ZTJERmFjdG9yeS5yZWdpc3RlclJ1bnRpbWUoe1xuICB2ZXJzaW9uOiA0LFxuICByZWFkeTogY3ViaXNtNFJlYWR5LFxuICB0ZXN0KHNvdXJjZSkge1xuICAgIHJldHVybiBzb3VyY2UgaW5zdGFuY2VvZiBDdWJpc200TW9kZWxTZXR0aW5ncyB8fCBDdWJpc200TW9kZWxTZXR0aW5ncy5pc1ZhbGlkSlNPTihzb3VyY2UpO1xuICB9LFxuICBpc1ZhbGlkTW9jKG1vZGVsRGF0YSkge1xuICAgIGlmIChtb2RlbERhdGEuYnl0ZUxlbmd0aCA8IDQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdmlldyA9IG5ldyBJbnQ4QXJyYXkobW9kZWxEYXRhLCAwLCA0KTtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSguLi52aWV3KSA9PT0gXCJNT0MzXCI7XG4gIH0sXG4gIGNyZWF0ZU1vZGVsU2V0dGluZ3MoanNvbikge1xuICAgIHJldHVybiBuZXcgQ3ViaXNtNE1vZGVsU2V0dGluZ3MoanNvbik7XG4gIH0sXG4gIGNyZWF0ZUNvcmVNb2RlbChkYXRhKSB7XG4gICAgY29uc3QgbW9jID0gQ3ViaXNtTW9jLmNyZWF0ZShkYXRhKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbW9kZWwgPSBtb2MuY3JlYXRlTW9kZWwoKTtcbiAgICAgIG1vZGVsLl9fbW9jID0gbW9jO1xuICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1vYy5yZWxlYXNlKCk7XG4gICAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfSxcbiAgY3JlYXRlSW50ZXJuYWxNb2RlbChjb3JlTW9kZWwsIHNldHRpbmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbW9kZWwgPSBuZXcgQ3ViaXNtNEludGVybmFsTW9kZWwoY29yZU1vZGVsLCBzZXR0aW5ncywgb3B0aW9ucyk7XG4gICAgY29uc3QgY29yZU1vZGVsV2l0aE1vYyA9IGNvcmVNb2RlbDtcbiAgICBpZiAoY29yZU1vZGVsV2l0aE1vYy5fX21vYykge1xuICAgICAgbW9kZWwuX19tb2MgPSBjb3JlTW9kZWxXaXRoTW9jLl9fbW9jO1xuICAgICAgZGVsZXRlIGNvcmVNb2RlbFdpdGhNb2MuX19tb2M7XG4gICAgICBtb2RlbC5vbmNlKFwiZGVzdHJveVwiLCByZWxlYXNlTW9jKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9LFxuICBjcmVhdGVQaHlzaWNzKGNvcmVNb2RlbCwgZGF0YSkge1xuICAgIHJldHVybiBDdWJpc21QaHlzaWNzLmNyZWF0ZShkYXRhKTtcbiAgfSxcbiAgY3JlYXRlUG9zZShjb3JlTW9kZWwsIGRhdGEpIHtcbiAgICByZXR1cm4gQ3ViaXNtUG9zZS5jcmVhdGUoZGF0YSk7XG4gIH1cbn0pO1xuZnVuY3Rpb24gcmVsZWFzZU1vYygpIHtcbiAgdmFyIF9hO1xuICAoX2EgPSB0aGlzLl9fbW9jKSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVsZWFzZSgpO1xufVxuZXhwb3J0IHsgQUN1YmlzbU1vdGlvbiwgQnJlYXRoUGFyYW1ldGVyRGF0YSwgQ1NNX0FTU0VSVCwgQ29uc3RhbnQsIEN1YmlzbTRFeHByZXNzaW9uTWFuYWdlciwgQ3ViaXNtNEludGVybmFsTW9kZWwsIEN1YmlzbTRNb2RlbFNldHRpbmdzLCBDdWJpc200TW90aW9uTWFuYWdlciwgQ3ViaXNtQmxlbmRNb2RlLCBDdWJpc21CcmVhdGgsIEN1YmlzbUNsaXBwaW5nQ29udGV4dCwgQ3ViaXNtQ2xpcHBpbmdNYW5hZ2VyX1dlYkdMLCBDdWJpc21Db25maWcsIEN1YmlzbURlYnVnLCBDdWJpc21FeHByZXNzaW9uTW90aW9uLCBDdWJpc21FeWVCbGluaywgQ3ViaXNtRnJhbWV3b3JrLCBDdWJpc21Mb2dEZWJ1ZywgQ3ViaXNtTG9nRXJyb3IsIEN1YmlzbUxvZ0luZm8sIEN1YmlzbUxvZ1ZlcmJvc2UsIEN1YmlzbUxvZ1dhcm5pbmcsIEN1YmlzbU1hdGgsIEN1YmlzbU1hdHJpeDQ0LCBDdWJpc21Nb2MsIEN1YmlzbU1vZGVsLCBDdWJpc21Nb2RlbFNldHRpbmdzSnNvbiwgQ3ViaXNtTW9kZWxVc2VyRGF0YSwgQ3ViaXNtTW9kZWxVc2VyRGF0YUpzb24sIEN1YmlzbU1vdGlvbiwgQ3ViaXNtTW90aW9uQ3VydmUsIEN1YmlzbU1vdGlvbkN1cnZlVGFyZ2V0LCBDdWJpc21Nb3Rpb25EYXRhLCBDdWJpc21Nb3Rpb25FdmVudCwgQ3ViaXNtTW90aW9uSnNvbiwgQ3ViaXNtTW90aW9uTWFuYWdlciwgQ3ViaXNtTW90aW9uUG9pbnQsIEN1YmlzbU1vdGlvblF1ZXVlRW50cnksIEN1YmlzbU1vdGlvblF1ZXVlTWFuYWdlciwgQ3ViaXNtTW90aW9uU2VnbWVudCwgQ3ViaXNtTW90aW9uU2VnbWVudFR5cGUsIEN1YmlzbVBoeXNpY3MsIEN1YmlzbVBoeXNpY3NJbnB1dCwgQ3ViaXNtUGh5c2ljc0pzb24sIEN1YmlzbVBoeXNpY3NPdXRwdXQsIEN1YmlzbVBoeXNpY3NQYXJ0aWNsZSwgQ3ViaXNtUGh5c2ljc1JpZywgQ3ViaXNtUGh5c2ljc1NvdXJjZSwgQ3ViaXNtUGh5c2ljc1N1YlJpZywgQ3ViaXNtUGh5c2ljc1RhcmdldFR5cGUsIEN1YmlzbVBvc2UsIEN1YmlzbVJlbmRlclRleHR1cmVSZXNvdXJjZSwgQ3ViaXNtUmVuZGVyZXIsIEN1YmlzbVJlbmRlcmVyX1dlYkdMLCBDdWJpc21TaGFkZXJfV2ViR0wsIEN1YmlzbVRleHR1cmVDb2xvciwgQ3ViaXNtVmVjdG9yMiwgRXZhbHVhdGlvbk9wdGlvbkZsYWcsIEV4cHJlc3Npb25CbGVuZFR5cGUsIEV4cHJlc3Npb25NYW5hZ2VyLCBFeWVTdGF0ZSwgRmlsZUxvYWRlciwgRm9jdXNDb250cm9sbGVyLCBIaXRBcmVhQm9keSwgSGl0QXJlYUhlYWQsIEhpdEFyZWFQcmVmaXgsIEludGVyYWN0aW9uTWl4aW4sIEludGVybmFsTW9kZWwsIEludmFsaWRNb3Rpb25RdWV1ZUVudHJ5SGFuZGxlVmFsdWUsIExPR0lDQUxfSEVJR0hULCBMT0dJQ0FMX1dJRFRILCBMaXZlMkRGYWN0b3J5LCBMaXZlMkRMb2FkZXIsIExpdmUyRE1vZGVsLCBMaXZlMkRUcmFuc2Zvcm0sIExvZ0xldmVsLCBNb2RlbFNldHRpbmdzLCBNb3Rpb25NYW5hZ2VyLCBNb3Rpb25QcmVsb2FkU3RyYXRlZ3ksIE1vdGlvblByaW9yaXR5LCBNb3Rpb25TdGF0ZSwgT3B0aW9ucywgUGFyYW1BbmdsZVgsIFBhcmFtQW5nbGVZLCBQYXJhbUFuZ2xlWiwgUGFyYW1Bcm1MQSwgUGFyYW1Bcm1MQiwgUGFyYW1Bcm1SQSwgUGFyYW1Bcm1SQiwgUGFyYW1CYXNlWCwgUGFyYW1CYXNlWSwgUGFyYW1Cb2R5QW5nbGVYLCBQYXJhbUJvZHlBbmdsZVksIFBhcmFtQm9keUFuZ2xlWiwgUGFyYW1CcmVhdGgsIFBhcmFtQnJvd0xBbmdsZSwgUGFyYW1Ccm93TEZvcm0sIFBhcmFtQnJvd0xYLCBQYXJhbUJyb3dMWSwgUGFyYW1Ccm93UkFuZ2xlLCBQYXJhbUJyb3dSRm9ybSwgUGFyYW1Ccm93UlgsIFBhcmFtQnJvd1JZLCBQYXJhbUJ1c3RYLCBQYXJhbUJ1c3RZLCBQYXJhbUNoZWVrLCBQYXJhbUV5ZUJhbGxGb3JtLCBQYXJhbUV5ZUJhbGxYLCBQYXJhbUV5ZUJhbGxZLCBQYXJhbUV5ZUxPcGVuLCBQYXJhbUV5ZUxTbWlsZSwgUGFyYW1FeWVST3BlbiwgUGFyYW1FeWVSU21pbGUsIFBhcmFtSGFpckJhY2ssIFBhcmFtSGFpckZsdWZmeSwgUGFyYW1IYWlyRnJvbnQsIFBhcmFtSGFpclNpZGUsIFBhcmFtSGFuZEwsIFBhcmFtSGFuZFIsIFBhcmFtTW91dGhGb3JtLCBQYXJhbU1vdXRoT3BlblksIFBhcmFtTk9ORSwgUGFyYW1TaG91bGRlclksIFBhcnREYXRhLCBQYXJ0c0FybUxQcmVmaXgsIFBhcnRzQXJtUHJlZml4LCBQYXJ0c0FybVJQcmVmaXgsIFBhcnRzSWRDb3JlLCBQaHlzaWNzSnNvbkVmZmVjdGl2ZUZvcmNlcywgU2hhZGVyTmFtZXMsIFNvdW5kTWFuYWdlciwgVkVSU0lPTiwgWEhSTG9hZGVyLCBaaXBMb2FkZXIsIGFwcGx5TWl4aW5zLCBjbGFtcCwgY29uZmlnLCBjb3B5QXJyYXksIGNvcHlQcm9wZXJ0eSwgY3NtUmVjdCwgY3ViaXNtNFJlYWR5LCBmb2xkZXJOYW1lLCBmcmFnbWVudFNoYWRlclNyY01hc2tJbnZlcnRlZFByZW11bHRpcGxpZWRBbHBoYSwgZnJhZ21lbnRTaGFkZXJTcmNNYXNrUHJlbXVsdGlwbGllZEFscGhhLCBmcmFnbWVudFNoYWRlclNyY1ByZW11bHRpcGxpZWRBbHBoYSwgZnJhZ21lbnRTaGFkZXJTcmNzZXR1cE1hc2ssIGxvZ2dlciwgcmFuZCwgcmVtb3ZlLCBzdGFydFVwQ3ViaXNtNCwgdmVydGV4U2hhZGVyU3JjLCB2ZXJ0ZXhTaGFkZXJTcmNNYXNrZWQsIHZlcnRleFNoYWRlclNyY1NldHVwTWFzayB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pixi-live2d-display/dist/cubism4.es.js\n");

/***/ })

};
;